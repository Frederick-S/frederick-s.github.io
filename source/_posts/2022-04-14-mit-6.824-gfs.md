title: 'MIT 6.824 - GFS'
tags:
- MIT 6.824
- GFS
---

## 介绍
在 [MapReduce: Simplified Data Processing on Large Clusters](https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf) 中提到，`MapReduce` 任务的输入输出构建在 `GFS` 之上，`GFS` 是 `Google` 内部开发的一个分布式文件系统，用于应对大型的数据密集型系统。在 `GFS` 之前，业界已经存在了一些分布式文件系统的实现，为什么 `Google` 还要再实现一套？和传统的分布式文件系统一样，`GFS` 在设计时同样考虑了性能、可扩展性、可靠性和可用性，然而除此以外，基于 `Google` 内部应用的特点，有别于传统的分布式文件系统，`GFS` 在设计时还考虑了以下三个方面：

1. 组件异常经常出现而不是偶尔出现。`GFS` 构建在成百上千台廉价的机器上，并同时被同等数量的客户端访问。在这个量级规模下，在任何时候某个组件都有可能发生异常以及发生异常后无法自动恢复。这里的异常不只包括硬件的异常，还包括软件的异常以及人为的错误。因此，对于异常的监控和检测，容错，以及异常的自动恢复是系统不可或缺的一个部分。
2. 以传统的分布式文件系统的视角来看，`Google` 要处理的都是大文件，几G的文件随处可见。
3. 对于 `Google` 的数据应用来说，大部分对文件的写操作是追加操作而不是覆盖操作。对文件的随机写几乎可以说是不存在。文件一旦写入完成后，基本上就不会被再次修改，剩下的都是读操作，且大部分场景下是顺序读。`MapReduce` 系统就是这个应用场景的典型例子，`map` 任务持续顺序追加生成中间结果文件，`reduce` 任务不断的从中间结果文件中顺序读取。根据这个特点，追加写就成为了系统性能优化以及写操作原子性保证的主要设计方向。
4. 将应用程序和文件系统的 `API` 协同设计有利于增加系统的灵活性。例如，`GFS` 提供了原子性的追加写操作，多个客户端可以并发追加写，而无需在应用程序层面进行加锁。

## 设计


参考：

* [The Google File System](https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf)