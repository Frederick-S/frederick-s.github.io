title: 'MIT 6.824 - Chain Replication for Supporting High Throughput and Availability'
tags:
- MIT 6.824
- Paper
- Distributed Systems
---

## 介绍
一个存储系统一般来说会实现一些接口使得客户端能够存储，获取，或者修改数据。文件系统和数据库系统是最广为人知的例子。对于文件系统来说，对单个文件的操作（读和写）是原子的；对于数据库系统来说，每个操作（事务）可能会访问多个对象，并且是可串行化的。

本文关注的存储系统介于文件系统和数据库系统之间。特别的，本文关注的存储系统，在这之后称之为存储服务，有以下功能：

* 存储对象
* 支持查询操作，能够返回单个对象的衍生数据
* 支持更新操作，能原子的基于单个对象之前的状态根据某些预编程的计算（可能是非确定性的）来修改对象的状态

文件系统的写操作是上述存储服务的更新操作的一个特例，而上述存储服务的更新操作又是数据库事务的一个特例。

越来越多的在线零售商（例如 `Amazon.com`），搜索引擎（例如 `Google` 和 `FAST`），以及很多信息密集型服务通过将大型存储系统使用网络互联来提供服务。相对于文件系统和数据库系统来说，存储系统对于这些应用来说是较为适合的方案，因为数据库系统成本和代价过大，而文件系统则缺少丰富的操作语义。

构建大型存储服务的一个挑战是如何伴随着异常和配置更改（异常组件能被检测到并被替换）的同时维持系统的高可用和高吞吐。

一致性保证对于存储服务来说同样很重要。即使不重要，如果有了强一致性的保证，则能简化基于存储服务的应用程序构建，强一致性保证了：

1. 对单个对象的读写操作会按照某个顺序执行
2. 读操作一定能读取到之前的更新操作的结果

强一致性保证经常被认为和高吞吐、高可用是冲突的。系统设计者一般不会牺牲系统的吞吐或者可用性，而是牺牲强一致性保证。`The Google File System`（`GFS`）就体现了这样的思想。实际上，大型存储服务的强一致性保证和高吞吐、高可用并不是冲突的。本文介绍的 `chain replication` 方式在对 `fail-stop` 类型异常容错的同时，能同时支持高吞吐，高可用和强一致性。

## 存储服务接口
客户端会向存储系统发起查询和更新操作的请求。虽然能做到每一个到达存储服务的请求都能保证被执行，不过在论文 [End-to-end arguments in system design](https://dl.acm.org/doi/10.1145/357401.357402) 中提到这样做意义不大。存储服务可以简单的只处理能到达的请求，并在请求完成时响应客户端，这样就不用区分对待请求丢失和响应丢失这两种情况：客户端可以在一段时间没有收到响应后重新发起请求。

* `query(objId, opts)` 会返回 `objId` 对应的对象的衍生数据；`opts` 指定了需要返回对象中的哪部分数据。`objId` 所对应对象的值不会被修改。
* `update(objId, newVal, opts)` 的返回值取决于 `opts`，一般来说，返回值 `V` 会根据某些预编程的非确定性计算基于 `objId` 对应的对象的当前值和（或）新值 `newVal` 求得；`V` 会成为 `objId` 对应的对象的新值。

查询操作是幂等的，但是更新操作不一定幂等。当客户端重新发起某个非确定性的更新操作时，必须确保上一次的请求并没有被执行。例如，客户端在重新发起更新操作前可以先执行一个查询操作，来确认该对象的值是否已经被更新。

如果某个请求没有响应，那么并不能区分是因为客户端的请求在到达存储服务前丢失还是客户端的请求被存储服务所忽略。这样当存储服务经历短暂的异常而丢弃了客户端的请求时，客户端可以简单的重新发起请求，而无需对这一异常场景单独处理。当然出于客户端性能的考虑，会尽可能降低系统异常的频率和持续时间。

在链式复制（`chain replication`）模式下，系统异常的时间远小于移除一个异常的节点或者增加一个新节点的时间。所以，遇到系统异常，恢复和其他配置变更时，对客户端请求的影响能降低到最小。而其他大多数的副本管理协议（`replica-management protocols`）要么会阻塞某些操作，要么在异常后或者配置变更期间牺牲一致性保证。

通过客户端视角下对象的状态以及查询和更新操作下客户端状态的转换，本文定义了所描述的存储系统的功能。下图通过伪代码的方式描述了该存储系统的功能：

![alt](/images/chain-replication-1.png)

上图通过两个变量定义了 $objID$ 所对应对象的状态：$Hist_{objID}$ 表示 $objID$ 所对应对象已执行的更新操作，$Pending_{objID}$ 表示待处理的请求。

上图也同时列出了可能的状态转换。`T1` 声明了新到达的请求会被添加到 $Pending_{objID}$。`T2` 声明了 $Pending_{objID}$ 中的请求被系统忽略时会从 $Pending_{objID}$ 中移除，不过这种情况不会频繁发生。`T3` 展示了高层次的请求处理过程：首先请求 `r` 会从 $Pending_{objID}$ 中移除；然后查询操作会生成相应的响应，而更新操作在生成响应之外还会将请求 `r` 添加到 $Hist_{objID}$ 中。

## 链式复制协议
本文描述的服务器假定具有 `fail-stop` 特性：

* 每台服务器发生异常时会停机，而不是继续执行错误的状态转换
* 服务器的异常能够被系统检测

对于有 `t` 个副本的对象来说，可以容忍 `t - 1` 个副本异常而不影响可用性。所以存储对象的可用性就取决于所有持有该对象副本的服务器都发生了异常的概率。因此，本文假定最多有 `t - 1` 个服务器会同时发生异常。

![alt](/images/chain-replication-2.png)

如上图所示，在链式复制模式下，各节点以一条链的形式来复制对象。链中的第一个节点被称为头结点，最后一个节点被称为尾节点，系统以如下的方式处理请求：

* 生成响应：每个请求的响应都只由尾节点生成并发送给客户端。
* 查询处理：每个查询请求都只由尾节点处理，并根据 $objID$ 查询尾节点本地的数据。
* 更新处理：每个更新请求都交由头结点处理。首先头结点根据 $objID$ 更新本地的数据，然后将更新请求以 `FIFO` 的顺序交由后继节点处理，以此类推，一直传递到尾节点处理。

在上述流程下，系统能保证强一致性，因为查询操作只由尾节点处理，而直到尾节点处理更新操作前，该更新结果都不会暴露给客户端，一旦尾节点更新完成，则后续的查询操作就能读到最新的请求。另外，各节点间 `FIFO` 的请求传递顺序也保证了某个对象更新的全局顺序性。

## 参考

* [Chain Replication for Supporting High Throughput and Availability](https://pdos.csail.mit.edu/6.824/papers/cr-osdi04.pdf)