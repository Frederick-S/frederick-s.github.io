title: 'MIT 6.824 - Chain Replication for Supporting High Throughput and Availability'
tags:
- MIT 6.824
- Paper
- Distributed Systems
---

## 介绍
一个存储系统一般来说会实现一些接口使得客户端能够存储，获取，或者修改数据。文件系统和数据库系统是最广为人知的例子。对于文件系统来说，对单个文件的操作（读和写）是原子的；对于数据库系统来说，每个操作（事务）可能会访问多个对象，并且是可串行化的。

本文关注的存储系统介于文件系统和数据库系统之间。特别的，本文关注的存储系统，在这之后称之为存储服务，有以下功能：

* 存储对象
* 支持查询操作，能够返回单个对象的衍生数据
* 支持更新操作，能原子的基于单个对象之前的状态根据某些预编程的计算（可能是非确定性的）来修改对象的状态

文件系统的写操作是上述存储服务的更新操作的一个特例，而上述存储服务的更新操作又是数据库事务的一个特例。

越来越多的在线零售商（例如 `Amazon.com`），搜索引擎（例如 `Google` 和 `FAST`），以及很多信息密集型服务通过将大型存储系统使用网络互联来提供服务。相对于文件系统和数据库系统来说，存储系统对于这些应用来说是较为适合的方案，因为数据库系统成本和代价过大，而文件系统则缺少丰富的操作语义。

构建大型存储服务的一个挑战是如何伴随着异常和配置更改（异常组件能被检测到并被替换）的同时维持系统的高可用和高吞吐。

一致性保证对于存储服务来说同样很重要。即使不重要，如果有了强一致性的保证，则能简化基于存储服务的应用程序构建，强一致性保证了：

1. 对单个对象的读写操作会按照某个顺序执行
2. 读操作一定能读取到之前的更新操作的结果

强一致性保证经常被认为和高吞吐、高可用是冲突的。系统设计者一般不会牺牲系统的吞吐或者可用性，而是牺牲强一致性保证。`The Google File System`（`GFS`）就体现了这样的思想。实际上，大型存储服务的强一致性保证和高吞吐、高可用并不是冲突的。本文介绍的 `chain replication` 方式在对 `fail-stop` 类型异常容错的同时，能同时支持高吞吐，高可用和强一致性。

## 存储服务接口
客户端会向存储系统发起查询和更新操作的请求。虽然能做到每一个到达存储服务的请求都能保证被执行，不过在论文 [End-to-end arguments in system design](https://dl.acm.org/doi/10.1145/357401.357402) 中提到这样做意义不大。存储服务可以简单的只处理能到达的请求，并在请求完成时响应客户端，这样就不用区分对待请求丢失和响应丢失这两种情况：客户端可以在一段时间没有收到响应后重新发起请求。

* `query(objId, opts)` 会返回 `objId` 对应的对象的衍生数据；`opts` 指定了需要返回对象中的哪部分数据。`objId` 所对应对象的值不会被修改。
* `update(objId, newVal, opts)` 的返回值取决于 `opts`，一般来说，返回值 `V` 会根据某些预编程的非确定性计算基于 `objId` 对应的对象的当前值和（或）新值 `newVal` 求得；`V` 会成为 `objId` 对应的对象的新值。

## 参考

* [Chain Replication for Supporting High Throughput and Availability](https://pdos.csail.mit.edu/6.824/papers/cr-osdi04.pdf)