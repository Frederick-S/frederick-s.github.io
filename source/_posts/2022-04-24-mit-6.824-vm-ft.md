title: 'MIT 6.824 - The Design of a Practical System for Fault-Tolerant Virtual Machines'
tags:
- MIT 6.824
- Paper
---

## 介绍
和一般描述的应用级别的主从备份不同，本文描述的是虚拟机的主从备份。主从备份作为一种常见的容错实现手段，当主节点异常时，从节点能取代主节点从而保证系统依然可用。作为从节点，它的状态必须尽可能的与主节点随时保持一致，这样当主节点异常时从节点能马上取代主节点，而客户端也不会感知到异常，同时也没有数据丢失。其中一种同步主从节点状态的方式是持续将主节点的所有修改发送给从节点，这里的修改包括 `CPU`、内存以及 `IO` 设备。然而，采用这种同步方式需要大量的网络带宽，尤其是发送内存的修改。

另一种只需要耗费少量带宽的方式是状态机（`state machine`）同步。该方法将主从同步抽象为确定性状态机（`deterministic state machine`）同步问题，在确定性状态机模型下，对于两个初始状态一样的状态机来说，按照相同的顺序执行相同的一系列输入指令后，最后的状态也一定是相同的。然而，对于大部分的服务来说，存在某些非确定性的操作，例如生成一个随机数，这时候就需要额外的协调使得主从间依然是同步的，即从节点也要生成一模一样的随机数。不过，处理这种情况所需要维护的额外信息相比于主节点状态的修改（主要是内存的修改）来说不值一提。

对于物理机来说，随着主频的增加，同步主从间的确定性操作也愈发困难。然而对于运行在 `hypervisor` 上的虚拟机来说却非常适合实现状态机同步。一个虚拟机本身就可以看做一个明确的状态机，它的所有操作就是被虚拟化的机器的操作（包括所有的设备）。和物理机一样，虚拟机也存在一些非确定性的操作（例如读取当前时间或者发送一个中断），所以也需要发送额外的信息给从节点来保证主从同步。因为 `hypervisor` 掌管着虚拟机的执行，包括发送所有的输入给被虚拟化的机器，所以它能捕获到执行非确定性操作的所有需要的信息，从而能正确的在从节点上执行重放操作。

因此，基于状态机同步的主从同步方式可以在不需要修改硬件的情况下在廉价的硬件上实现，使得容错技术适用于最新的微处理器。另外，对带宽较低的要求使得长距离的虚拟机主从同步成为了可能。例如，可以在跨校园间不同的物理机上做主从同步，相比于同大厦内的主从同步更为可靠。

目前在 `VMware vSphere 4.0` 平台上已经实现了这种容错技术，该平台能高效完整的虚拟化 `x86` 架构的机器。因为 `VMware vSphere` 实现了一个完全的 `x86` 虚拟机，所以可以自动的对任何 `x86` 的操作系统和应用提供容错支持。通过确定性重放（`deterministic replay`），系统可以记录下主节点的执行并且确保能在从节点执行相同的操作。`VMware vSphere Fault Tolerance (FT)` 在此基础之上增加了额外的功能和协议来支持构建一个可完全容错的系统。除了对硬件的容错外，当主节点异常时，系统能自动的在本地集群中启动一台可用的从节点来接管主节点。在该篇论文发表的时候，确定性重放技术和 `VMware FT` 仅支持单核的虚拟机。受限于严重的性能问题，多核虚拟机的重放支持仍在进行中，因为在多核场景下，几乎每一个对共享内存的访问都是一个非确定性的操作。

`Bressoud` 和 `Schneider` 针对惠普的 `PA-RISC` 平台的虚拟机容错做了个原型实现。`VMware` 的实现与其类似，不过出于性能的考虑做了些根本的修改以及调研了一些其他实现方案。另外，为了能构建一个高效、可用的容错系统来支持用户的企业级应用，`VMware` 还设计和实现了许多其他组件以及解决一些实际的问题。和大多数实际的系统要解决的问题一样，这里的容错针对的是 `fail-stop` 的异常，即在造成外部可见的不正确的行为前可被监测到的异常，例如磁盘空间不足、网络无法连通等等，而诸如应用程序的 `bug` 或者人为失误等则不属于 `fail-stop` 异常，系统也无法进行容错。

## 基础设计
![alt](/images/vm-ft-1.png)

上图展示了支持容错的虚拟机的基本配置。对于每一台需要支持容错的虚拟机（`primary VM`），系统会在其他物理机上同时运行一台备份虚拟机（`backup VM`），备份虚拟机和主虚拟机会保持同步，并执行和主虚拟机相同的指令，不过会存在一定的延迟。这两台虚拟机被称为处于 `virtual lockstep` 状态。同时，虚拟机连接着相同的共享存储，输入和输出都可以被主从虚拟机访问。不过，只有主虚拟机才会暴露在网络中，所以所有的网络输入都会只发送给主虚拟机。同样的，其他所有的输入（例如键盘和鼠标输入）也都只会发送给主虚拟机。

主虚拟机收到的所有输入都会通过 `logging channel` 发送给从虚拟机。对系统来说，主要的输入负载就是网络和磁盘。为了保证从虚拟机能和主虚拟机执行相同的非确定性操作，还需要发送一些额外的信息给从虚拟机。从结果上来说，从虚拟机会始终执行和主虚拟机相同的操作。不过，所有从虚拟机的输出都会被 `hypervisor` 丢弃，只有主虚拟机的输出才会返回给客户端。后面会提到，主从虚拟机间的通信会遵循一个特定的协议，包括从虚拟机对消息的确认，来保证当主虚拟机异常时不会发生数据丢失。

为了监测主虚拟机或者从虚拟机是否发生异常，系统会通过和主从虚拟机间的心跳以及 `logging channel` 的流量来判断。另外，系统必须保证在任一时间只有一台主虚拟机或者从虚拟机作为对外执行的入口，即使主虚拟机和从虚拟机间失联发生脑裂的场景。

### 确定性重放的实现
在前面提到过，主从虚拟机的同步可以抽象为确定性状态机同步问题。如果两个确定性状态机以相同的初始状态启动，并且按照相同的顺序执行相同的输入，那么这两个状态机会经历相同的状态流转并输出相同的结果。一台虚拟机会有一系列的输入，包括网络包，磁盘读取，以及键盘和鼠标输入。而非确定性的事件（例如虚拟中断（`virtual interrupts`））和非确定性的操作（例如读取当前处理器的时钟周期数）也会影响虚拟机的内部状态。这就给重放执行一台运行着任意操作系统和任意服务的虚拟机带来了3个挑战：

1. 需要正确的捕捉到主虚拟机的所有输入和非确定性的操作
2. 需要正确的将输入和非确定性操作在从虚拟机上重放
3. 不能影响系统性能

另外，`x86` 处理器中很多复杂的操作往往伴有副作用，因此也是非确定性的操作，如何捕捉到这些非确定性的操作并正确的在从虚拟机上重放也是一个挑战。

`VMware vSphere` 平台为 `x86` 虚拟机提供了上述的重放功能。确定性重放技术会将主虚拟机的所有输入和所有可能的非确定性操作写入到日志文件中。从虚拟机就可以读取日志文件并执行和主虚拟机一样的操作。对于非确定性的操作来说，系统会写入一些额外的信息来保证重放时生成相同的虚拟机状态和输出。对于非确定性的事件例如计时器或者 `IO` 完成中断，在事件发生时所执行的指令也会记录在日志中。在重放时，事件会和指令一同出现在指令流中。

`Bressound` 和 `Schneider` 在其实现中提到将虚拟机的执行以 `epoch` 为单位进行切分，其中所有的非确定性操作例如中断都放在 `epoch` 的最后。这个想法是出于批量处理的考虑，因为单独将每一个中断和中断发生时对应的指令重放执行代价较大。不过 `VMware` 的实现足够高效使得不需要借助 `epoch` 来实现确定性重放，每一个中断都能被准确的记录并伴随着发生中断时的指令一起执行。

### `FT` 协议


参考：

* [The Design of a Practical System for Fault-Tolerant Virtual Machines](https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf)
* [6.824 2022 Lecture 4: Primary/Backup Replication](https://pdos.csail.mit.edu/6.824/notes/l-vm-ft.txt)