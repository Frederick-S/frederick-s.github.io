title: 'MIT 6.824 - The Design of a Practical System for Fault-Tolerant Virtual Machines'
tags:
- MIT 6.824
- Paper
---

## 介绍
和一般描述的应用级别的主从备份不同，本文描述的是虚拟机的主从备份。主从备份作为一种常见的容错实现手段，当主节点异常时，从节点能取代主节点从而保证系统依然可用。作为从节点，它的状态必须尽可能的与主节点随时保持一致，这样当主节点异常时从节点能马上取代主节点，而客户端也不会感知到异常，同时也没有数据丢失。其中一种同步主从节点状态的方式是持续将主节点的所有修改发送给从节点，这里的修改包括 `CPU`、内存以及 `IO` 设备。然而，采用这种同步方式需要大量的网络带宽，尤其是发送内存的修改。

另一种只需要耗费少量带宽的方式是状态机（`state machine`）同步。该方法将主从同步抽象为确定性状态机（`deterministic state machine`）同步问题，在确定性状态机模型下，对于两个初始状态一样的状态机来说，按照相同的顺序执行相同的一系列输入指令后，最后的状态也一定是相同的。然而，对于大部分的服务来说，存在某些非确定性的操作，例如生成一个随机数，这时候就需要额外的协调使得主从间依然是同步的，即从节点也要生成一模一样的随机数。不过，处理这种情况所需要维护的额外信息相比于主节点状态的修改（主要是内存的修改）来说不值一提。

对于物理机来说，随着主频的增加，同步主从间的确定性操作也愈发困难。然而对于运行在 `hypervisor` 上的虚拟机来说却非常适合实现状态机同步。一个虚拟机本身就可以看做一个明确的状态机，它的所有操作就是被虚拟化的机器的操作（包括所有的设备）。和物理机一样，虚拟机也存在一些非确定性的操作（例如读取当前时间或者发送一个中断），所以也需要发送额外的信息给从节点来保证主从同步。因为 `hypervisor` 掌管着虚拟机的执行，包括发送所有的输入给被虚拟化的机器，所以它能捕获到执行非确定性操作的所有需要的信息，从而能正确的在从节点上执行重放操作。

因此，基于状态机同步的主从同步方式可以在不需要修改硬件的情况下在廉价的硬件上实现，使得容错技术适用于最新的微处理器。另外，对带宽较低的要求使得长距离的虚拟机主从同步成为了可能。例如，可以在跨校园间不同的物理机上做主从同步，相比于同大厦内的主从同步更为可靠。

目前在 `VMware vSphere 4.0` 平台上已经实现了这种容错技术，该平台能高效完整的虚拟化 `x86` 架构的机器。因为 `VMware vSphere` 实现了一个完全的 `x86` 虚拟机，所以可以自动的对任何 `x86` 的操作系统和应用提供容错支持。通过确定性重放（`deterministic replay`），系统可以记录下主节点的执行并且确保能在从节点执行相同的操作。`VMware vSphere Fault Tolerance (FT)` 在此基础之上增加了额外的功能和协议来支持构建一个可完全容错的系统。除了对硬件的容错外，当主节点异常时，系统能自动的在本地集群中启动一台可用的从节点来接管主节点。在该篇论文发表的时候，确定性重放技术和 `VMware FT` 仅支持单核的虚拟机。受限于严重的性能问题，多核虚拟机的重放支持仍在进行中，因为在多核场景下，几乎每一个对共享内存的访问都是一个非确定性的操作。

`Bressoud` 和 `Schneider` 针对惠普的 `PA-RISC` 平台的虚拟机容错做了个原型实现。`VMware` 的实现与其类似，不过出于性能的考虑做了些根本的修改以及调研了一些其他实现方案。另外，为了能构建一个高效、可用的容错系统来支持用户的企业级应用，`VMware` 还设计和实现了许多其他组件以及解决一些实际的问题。和大多数实际的系统要解决的问题一样，这里的容错针对的是 `fail-stop` 的异常，即在造成外部可见的不正确的行为前可被监测到的异常，例如磁盘空间不足、网络无法连通等等，而诸如应用程序的 `bug` 或者人为失误等则不属于 `fail-stop` 异常，系统也无法进行容错。

## 基础设计
![alt](/images/vm-ft-1.png)

上图展示了支持容错的虚拟机的基本配置。对于每一台需要支持容错的虚拟机（`primary VM`），系统会在其他物理机上同时运行一台备份虚拟机（`backup VM`），备份虚拟机和主虚拟机会保持同步，并执行和主虚拟机相同的指令，不过会存在一定的延迟。这两台虚拟机被称为处于 `virtual lockstep` 状态。同时，虚拟机连接着相同的共享存储，输入和输出都可以被主从虚拟机访问。不过，只有主虚拟机才会暴露在网络中，所以所有的网络输入都会只发送给主虚拟机。同样的，其他所有的输入（例如键盘和鼠标输入）也都只会发送给主虚拟机。

主虚拟机收到的所有输入都会通过 `logging channel` 发送给从虚拟机。对系统来说，主要的输入负载就是网络和磁盘。为了保证从虚拟机能和主虚拟机执行相同的非确定性操作，还需要发送一些额外的信息给从虚拟机。从结果上来说，从虚拟机会始终执行和主虚拟机相同的操作。不过，所有从虚拟机的输出都会被 `hypervisor` 丢弃，只有主虚拟机的输出才会返回给客户端。后面会提到，主从虚拟机间的通信会遵循一个特定的协议，包括从虚拟机对消息的确认，来保证当主虚拟机异常时不会发生数据丢失。

为了监测主虚拟机或者从虚拟机是否发生异常，系统会通过和主从虚拟机间的心跳以及 `logging channel` 的流量来判断。另外，系统必须保证在任一时间只有一台主虚拟机或者从虚拟机作为对外执行的入口，即使主虚拟机和从虚拟机间失联发生脑裂的场景。

### 确定性重放的实现
在前面提到过，主从虚拟机的同步可以抽象为确定性状态机同步问题。如果两个确定性状态机以相同的初始状态启动，并且按照相同的顺序执行相同的输入，那么这两个状态机会经历相同的状态流转并输出相同的结果。一台虚拟机会有一系列的输入，包括网络包，磁盘读取，以及键盘和鼠标输入。而非确定性的事件（例如虚拟中断（`virtual interrupts`））和非确定性的操作（例如读取当前处理器的时钟周期数）也会影响虚拟机的内部状态。这就给重放执行一台运行着任意操作系统和任意服务的虚拟机带来了3个挑战：

1. 需要正确的捕捉到主虚拟机的所有输入和非确定性的操作
2. 需要正确的将输入和非确定性操作在从虚拟机上重放
3. 不能影响系统性能

另外，`x86` 处理器中很多复杂的操作往往伴有副作用，因此也是非确定性的操作，如何捕捉到这些非确定性的操作并正确的在从虚拟机上重放也是一个挑战。

`VMware vSphere` 平台为 `x86` 虚拟机提供了上述的重放功能。确定性重放技术会将主虚拟机的所有输入和所有可能的非确定性操作写入到日志文件中。从虚拟机就可以读取日志文件并执行和主虚拟机一样的操作。对于非确定性的操作来说，系统会写入一些额外的信息来保证重放时生成相同的虚拟机状态和输出。对于非确定性的事件例如计时器或者 `IO` 完成中断，在事件发生时所执行的指令也会记录在日志中。在重放时，事件会和指令一同出现在指令流中。借助联合 `AMD` 和 `Intel` 开发的 `hardware performance counter`（一组特殊寄存器用来记录硬件相关事件发生的次数）和其他技术，`VMware` 确定性重放技术能高效的记录和重放非确定性的事件。

`Bressound` 和 `Schneider` 在其实现中提到将虚拟机的执行以 `epoch` 为单位进行切分，其中所有的非确定性操作例如中断都放在 `epoch` 的最后。这个想法是出于批量处理的考虑，因为单独将每一个中断和中断发生时对应的指令重放执行代价较大。不过 `VMware` 的实现足够高效使得不需要借助 `epoch` 来实现确定性重放，每一个中断都能被准确的记录并伴随着发生中断时的指令一起执行。

### `FT` 协议
`VMware FT` 使用确定性重放技术将主虚拟机的执行流记录到日志中，不过主虚拟机并不是将日志写入到磁盘上，而是通过 `logging channel` 将日志发送给从虚拟机。从虚拟机能实时的读取日志并将其重放，从而执行和主虚拟机一样的操作。然而，双方在 `logging channel` 的通信必须遵循 `FT` 协议来保证容错。其中一条基本的要求是：

> `Output Requirement`：当主虚拟机异常，从虚拟机接管执行时，从虚拟机的输出必须和先前主虚拟机已经发送给客户端的输出一致。

当异常发生时（主虚拟机异常，从虚拟机接管执行），从虚拟机的执行可能会和在没有异常发生时主虚拟机的执行不同，因为在执行时会有很多非确定性的操作。然而，只要从虚拟机的输出满足 `Output Requirement`，则在主从切换时就不会有外部可见的状态或者数据丢失，而客户端也不会感知到中断或者服务的不一致。

通过主虚拟机的延迟输出，保证从虚拟机确认收到了所有日志后，主虚拟机才将输出返回给客户端来实现 `Output Requirement`。一个先决的条件是主虚拟机在执行输出操作前，从虚拟机必须已经收到所有的日志。这些日志能保证从虚拟机执行到主虚拟机最新的执行点。然而，假设当主虚拟机刚开始执行输出操作时发生了异常，此时发生了主从切换，从虚拟机必须先将未处理完的日志进行重放，然后才能 `go live`（不再执行重放，接管成为主虚拟机）。如果在这之前从虚拟机 `go live`，可能会有一些非确定性的事件（例如计时器中断）在从虚拟机执行输出操作前改变了执行的路径。

针对上述的要求，最简单的实现 `Output Requirement` 的方式是为每一条输出操作创建一条特殊的日志，从而可以通过以下规则来保证 `Output Requirement`：

> `Output Rule`：在从虚拟机确认收到输出操作对应的日志前，主虚拟机不能执行输出操作。

如果从虚拟机收到了所有的日志，包括输出操作对应的日志，那么从虚拟机就能重放出和主虚拟机在执行输出操作时一模一样的状态，当主虚拟机异常时，从虚拟机就能恢复到主虚拟机执行输出操作前一致的状态。相反的，如果从虚拟机在没有收到日志前就接管了主虚拟机的操作，那么它的状态就和主虚拟机是不一致的，从而导致最终的输出也不一致。

注意 `Output Rule` 并没有要求在从虚拟机确认收到输出日志前停止主虚拟机的执行。这里只是延迟了主虚拟机的输出，它依然可以执行其他指令。因为操作系统以异步中断的方式来通知非阻塞网络和磁盘输出的完成，主虚拟机可以在这期间轻易的执行其他指令，而不用阻塞等待。相反的，在其他的一些实现中，在从虚拟机确认收到输出日志前，主虚拟机必须完全停止等待。

![alt](/images/vm-ft-2.png)

上图展示了 `FT` 协议的要求。主虚拟机到从虚拟机的箭头表示日志的发送，从虚拟机到主虚拟机的箭头表示日志的确认。所有异步事件，输入和输出的操作都必须发送给从虚拟机并得到确认。只有当从虚拟机确认了某条输出操作的日志后，主虚拟机才能执行输出操作。所以只要遵循了 `Output Rule`，从虚拟机在接管执行时就能保持和主虚拟机一致的状态。

不过在异常发生时，`VMware FT` 并不能保证所有的输出只发送一次。在缺少两阶段提交的帮助下，从虚拟机不能知晓主虚拟机在发送某条输出之前还是之后发生了异常。不过，网络协议（包括常见的 `TCP` 协议）在设计时就已经考虑了包的丢失和重复包的情况，所以这里无需特殊处理。另外，在主虚拟机异常时发送给主虚拟机的输入也有可能丢失，因此从虚拟机也会丢失这部分的输入。不过，即使在主虚拟机没有异常的情况下，网络包本身就有可能丢失，所以这里同样也不需要特殊处理，不管是网络协议、操作系统还是应用程序，在设计和编写时本身已经考虑到了包丢失的情况。

### 监测和响应异常
之前提到过，当主虚拟机或者从虚拟机发生异常时，双方都必须能快速响应。当从虚拟机异常时，主虚拟机会进入 `go live` 模式，即不再记录执行日志，以常规的方式执行。当主虚拟机异常时，从虚拟机也会进入 `go live` 模式，不过相比于主虚拟机略微复杂些。因为从虚拟机在执行上本身就落后于主虚拟机，在主虚拟机异常时，从虚拟机已经收到和确认了一部分执行日志，但是还没有执行重放，此时从虚拟机的状态和主虚拟机还是不一致的。所以，从虚拟机必须先将暂存的日志进行重放，当所有重放都执行完成后，从虚拟机就会进行 `go live` 模式，正式接管主虚拟机（此时缺少一个从虚拟机）。因为此时这台从虚拟机不再是从虚拟机，被虚拟化的操作系统所执行的输出操作都会发送给客户端。在这个转换期间，可能也需要某些设备执行一些特定的操作来保证后续输出的正确性。特别是对于网络输出来说，`VMware FT` 会自动的将新的主虚拟机的 `MAC` 地址在网络中广播，使得物理交换机知道最新的主虚拟机的地址。另外，后文会提到新的主虚拟机可能会重新发起一些磁盘 `IO` 操作。

有很多种方式来监测主虚拟机和从虚拟机的异常。`VMware FT` 通过 `UDP` 心跳来监测启用了容错的虚拟机是否发生了异常。另外，`VMware FT` 还会监控 `logging channel` 中的流量，包括主虚拟机发送给从虚拟机的日志，以及从虚拟机的确认回执。因为操作系统本身存在时钟中断，所以理论上来说 `logging channel` 中的流量应该是连续不断的。因此，如果监测到 `logging channel` 中没有流量了，那么就可以推断出某台虚拟机发生了异常。如果没有心跳或者 `logging channel` 中没有流量超过一段指定的时间（近似几秒钟），那么系统就会声明这台虚拟机发生了异常。

然而，这种异常监测机制可能会引发脑裂问题。如果从虚拟机不再接收到来自主虚拟机的心跳，那么有可能说明主虚拟机发生了异常，但也有可能只是双方间的网络断开。如果此时从虚拟机进入 `go live` 模式，由于此时主虚拟机依然存活，就有可能给客户端造成数据损坏或其他问题。因此，当监测到异常时必须保证只有一台主虚拟机或者从虚拟机进入 `go live` 模式。为了解决脑裂问题，`VMware FT` 借助了虚拟机所连接的共享存储。当主虚拟机或者从虚拟机希望进入 `go live` 模式时，它会向共享存储发起一个原子性的 `test-and-test` 操作。如果操作成功，那么当前虚拟机可以进入 `go live` 模式，如果操作失败，说明已经有其他虚拟机先进入了 `go live` 模式，所以当前虚拟机就将自己挂起。如果虚拟机访问共享存储失败，那么它会一直等待直到访问成功。如果共享存储由于网络问题造成无法访问，那么虚拟机本身也做不了什么因为它的虚拟磁盘就挂载在共享存储上。所以使用共享存储来解决脑裂问题不会带来其他可用性问题。

最后一个设计的点是如果虚拟机发生了异常，使得某台虚拟机进入了 `go live` 模式，那么 `VMware FT` 会自动在其他物理机上启动一台新的备份虚拟机。

## `FT` 的实际实现
上节主要描述了 `FT` 的基础设计和协议。然而，为了构建一个可用，健壮和自动化的系统，还需要设计和实现很多其他的组件。

### 启动和重启 `FT` 虚拟机
其中一个至关重要的组件是如何启动一台有着和主虚拟机一模一样状态的备份虚拟机。这个同时也会在当某台虚拟机异常需要重新启动一台备份虚拟机时用到。因此，这个组件必须能够在主虚拟机处于任意状态的时候复制一台一模一样的备份虚拟机（而不仅仅是初始状态）。另外，这个启动操作还不能影响到主虚拟机的执行，因为这有可能影响到当前所有连接着的客户端。

对于 `VMware FT` 来说，它借用了 `VMware vSphere` 平台已有的 `VMotion` 的功能。`VMware VMotion` 能以极小的代价将一台运行中的虚拟机迁移到另一台机器上——虚拟机的暂停时间一般在一秒内。`VMware FT` 对 `VMotion` 做了些改动使得在不销毁当前虚拟机的情况下，在远程服务器上复制一台和当前虚拟机一模一样的虚拟机。即修改版的 `FT VMotion` 做的是虚拟机的复制而不是迁移。`FT VMotion` 也会同时建立一条 `logging channel`，源虚拟机作为主虚拟机就会将执行日志写入到 `logging channel`，而复制后的虚拟机作为从虚拟机开始重放执行。和常规的 `VMotion` 一样，`FT VMotion` 也能将对主虚拟机的暂停控制在一秒以内。因此，对某台运行中的虚拟机开启 `FT` 功能非常简单，且没有破坏性。

参考：

* [The Design of a Practical System for Fault-Tolerant Virtual Machines](https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf)
* [6.824 2022 Lecture 4: Primary/Backup Replication](https://pdos.csail.mit.edu/6.824/notes/l-vm-ft.txt)
* [Hardware performance counter](https://en.wikipedia.org/wiki/Hardware_performance_counter)