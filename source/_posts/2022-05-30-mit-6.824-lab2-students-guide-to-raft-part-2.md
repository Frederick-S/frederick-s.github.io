title: "MIT 6.824 - Lab 3 (1): Students' Guide to Raft（续）"
tags:
- MIT 6.824
- Go
- Raft
- Distributed Systems
---

[Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/) 是 [MIT 6.824: Distributed Systems](https://pdos.csail.mit.edu/6.824/) 之前的助教写给学生看的实验生存指南。在 [MIT 6.824 - Lab 2 (1): Students' Guide to Raft](/2022/05/06/mit-6.824-lab2-students-guide-to-raft/) 中介绍了关于 `Lab 2` 的部分，本文将继续介绍关于 `Lab 3` 的部分。

在 `Lab 3` 中，我们需要实现一个基于 `Raft` 的 `Key-Value` 数据库，本文描述了某些对实现可能有帮助的细节。

## 提交客户端操作
实现客户端请求时可能会先直接发一个请求给客户端所认为的主节点，然后对应的服务端等待 `Raft` 应用日志，接着服务端执行客户端的请求逻辑，最后再把结果返回给客户端。这种方式适合单客户端的系统，不过不适合多客户端并发的系统。在多客户端请求下，每个客户端请求都有可能修改系统状态，即使各 `Raft` 节点的日志保持一致，由于各客户端请求间可能相互交替执行，服务端本地状态可能和 `Raft` 节点的最新日志不一致，除非使用全局的锁隔离各客户端请求，不过系统会退化为串行程序。

文中建议将服务端当做状态机处理，每个客户端的请求本质上都是将状态机从一个状态转变为另一个状态。服务端中有一个专门的线程来处理客户端请求，该线程每次获取一个客户端请求，然后将其提交给 `Raft`，之后收到 `Raft` 应用日志的通知后，按顺序将客户端命令应用到服务端的本地状态机中，这里虽然看起来也是串行处理客户端请求，不过由于 `Raft.Start()` 方法会立即返回，当瞬时大量请求过来时，`Raft` 在实现时会批量发送日志。这个线程是整个服务端中唯一能修改本地状态机的地方，所以服务端的 `RPC` 就简化为了向任务队列中提交任务，并且当 `applyCh` 接收到可以执行的日志时，将日志所对应的命令应用到本地状态机中，然后响应客户端。

不过，这也带来了一个问题：什么时候知道某个客户端请求执行完成了？这在一切正常的情况下非常简单，因为我们是按序将客户端请求提交给 `Raft`，所以最后从 `applyCh` 中出来的日志的顺序就是和提交客户端请求的顺序一致。不过，当前客户端所通信的服务端有可能在中途不再是主节点，客户端所发送的日志有可能被丢弃，此时客户端需要能够知道发送异常，然后尝试换一个服务端。

## 参考

* [Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/)