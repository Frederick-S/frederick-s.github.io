title: "MIT 6.824 - Lab 3 (1): Students' Guide to Raft（续）"
tags:
- MIT 6.824
- Go
- Raft
- Distributed Systems
---

[Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/) 是 [MIT 6.824: Distributed Systems](https://pdos.csail.mit.edu/6.824/) 之前的助教写给学生看的实验生存指南。在 [MIT 6.824 - Lab 2 (1): Students' Guide to Raft](/2022/05/06/mit-6.824-lab2-students-guide-to-raft/) 中介绍了关于 `Lab 2` 的部分，本文将继续介绍关于 `Lab 3` 的部分。

在 `Lab 3` 中，我们需要实现一个基于 `Raft` 的 `Key-Value` 数据库，本文描述了某些对实现可能有帮助的细节。

## 提交客户端操作
实现客户端请求时可能会先直接发一个请求给客户端所认为的主节点，然后对应的服务端等待 `Raft` 应用日志，接着服务端执行客户端的请求逻辑，最后再把结果返回给客户端。这种方式适合单客户端的系统，不过不适合多客户端并发的系统。在多客户端请求下，每个客户端请求都有可能修改系统状态，即使各 `Raft` 节点的日志保持一致，由于各客户端请求间可能相互交替执行，服务端本地状态可能和 `Raft` 节点的最新日志不一致，除非使用全局的锁隔离各客户端请求，不过系统会退化为串行程序。

文中建议将服务端当做状态机处理，每个客户端的请求本质上都是将状态机从一个状态转变为另一个状态。服务端中有一个专门的线程来处理客户端请求，该线程每次获取一个客户端请求，然后将其提交给 `Raft`，之后收到 `Raft` 应用日志的通知后，按顺序将客户端命令应用到服务端的本地状态机中，这里虽然看起来也是串行处理客户端请求，不过由于 `Raft.Start()` 方法会立即返回，当瞬时大量请求过来时，`Raft` 在实现时会批量发送日志。这个线程是整个服务端中唯一能修改本地状态机的地方，所以服务端的 `RPC` 就简化为了向任务队列中提交任务，并且当 `applyCh` 接收到可以执行的日志时，将日志所对应的命令应用到本地状态机中，然后响应客户端。

不过，这也带来了一个问题：什么时候知道某个客户端请求执行完成了？这在一切正常的情况下非常简单，因为我们是按序将客户端请求提交给 `Raft`，所以最后从 `applyCh` 中出来的日志的顺序就是提交客户端请求的顺序。不过，当前客户端所通信的服务端有可能在中途不再是主节点，客户端所发送的日志有可能被丢弃，此时客户端需要能够知道发生了异常，然后尝试换一个服务端。

一个简单的方法是记录提交客户端请求时 `Raft` 返回的日志索引，然后从 `applyCh` 收到对应索引的日志时，判断该条日志是否对应最初的客户端请求（可以向 `ApplyMsg.Command` 添加额外的信息来标识是否是当初的请求）。如果不是同一条请求，则说明发生了异常。

## 识别重复请求
因为客户端异常重试的机制存在，所以服务端需要能识别出重复的客户端请求：例如某个客户端发送 `APPEND` 请求，当前服务端成功执行但是客户端没有收到响应，客户端会选择一个新的服务端发送请求，新的服务端需要确保 `APPEND` 请求不会被执行两次。因此，每个客户端请求需要一个唯一的标识，使得服务端能够识别已经执行的请求。另外，由于客户端会选择不同的服务端发送请求，各服务端需要对已执行的客户端请求达成共识。

有很多方法来为客户端请求生成唯一的标识符。一种简单并且相对有效的方法是给先每个客户端分配一个唯一的标识符，然后给每一个请求附带一个递增的序列号。如果某个客户端重新发送请求，则会复用之前的请求序列号。每个服务端需要维护每个客户端已处理的请求序列号，如果服务端发现客户端的请求序列号小于当前最新的请求序列号，则直接忽略该请求。

## 参考

* [Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/)