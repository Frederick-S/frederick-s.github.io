title: "MIT 6.824 - Lab 2 (1): Students' Guide to Raft"
tags:
- MIT 6.824
- Go
- Raft
- Distributed Systems
---

[Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/) 是 [MIT 6.824: Distributed Systems](https://pdos.csail.mit.edu/6.824/) 之前的助教写给学生看的实验生存指南。

## 实现 Raft
论文中的 `Figure 2` 和 `Figure 13` 描述了实现 `Raft` 的主要接口，以及各节点需要维护的状态和响应接口时的行为逻辑，所以在做 `Lab 2` 之前需要先充分理解这部分的内容。文中的建议是**必须**严格落实图中的每一句话，而不是仅仅实现了功能，否则就有可能遇到奇怪的问题或不正确的系统行为。

文中举了三个例子。第一，每次收到 `AppendEntries` 或 `RequestVote` 请求就重置 `election timeout`，因为收到这两个请求说明存在主节点或者正在选主。不过，图中还有描述：

> If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate.

重置 `electino timeout` 有两个关键条件：`AppendEntries` 要求发送请求的主节点是当前任期的主节点；`RequestVote` 要求成功投出选票。

先看第一个条件，假设当前任期的主节点异常，此时还有一个之前任期的主节点存活在不断发送 `AppendEntries` 请求，假设此时某个从节点马上要进入选主状态，但由于收到了 `AppendEntries` 请求又没有校验任期就重置了 `election timeout`，造成无主状态时间延长。这个场景下如果过期的主节点不实现下面的逻辑杀伤力倍增：

> If RPC request or response contains term T > currentTerm: set currentTerm = T, convert to follower

如果不实现上面的逻辑，那么过期的主节点会一直是主节点，然后一直重置其他本来可以成为候选节点的从节点。

再来看第二个条件，假设当前任期的主节点异常，各从节点准备进入选主状态，此时一个不可能成为主节点的从节点先变成了候选节点（该节点的日志相对于其他任何一个从节点来说都不够新，即最后一条日志的任期不够大，或者任期相同但是日志条数不够多），`RequestVote` 永远不会成功，如果各从节点一收到 `RequestVote` 就重置 `election timeout`，就会造成始终没有主节点的情况。

第二个例子，从节点收到心跳 `AppendEntries` 后就直接返回 `success = true` 和重置 `election timeout`。重置 `election timeout` 的危害上面已经说过，充当心跳的 `AppendEntries` 是不带日志的请求，文中提到学生在实现时容易将心跳 `AppendEntries` 特殊对待，而不进行 `prevLogIndex` 和 `prevLogTerm` 的校验。从节点返回 `true` 时主节点就会认为从节点的日志和自己匹配，从而错误的认为某些日志已经复制到了从节点上，从而可以提交日志。第一眼看到这里的时候可能会问，为什么主节点收到心跳返回后会提交日志，提交日志不应该是在非心跳 `AppendEntries` 的结果中处理吗？因为主节点会异常，假设主节点将某条日志复制到了过半数的节点，没有来得及提交就异常了，该节点马上恢复后再次被选为主节点，但是它并不知道哪些日志已经被提交了，只能通过 `AppendEntries` 心跳的 `prevLogIndex` 和 `prevLogTerm` 来交换信息，从而知道哪些日志可以提交。所以，如果从节点收到心跳不校验 `prevLogIndex` 和 `prevLogTerm`，那么主节点就会错误的将不该提交的日志提交。

引申开来，假设系统中此时 `x = 1`，有个客户端发送了 `write x = 2` 的请求，主节点成功将日志复制到了过半数的节点上，但是还没有响应客户端就异常了。系统重新选主后，此时有个客户端发送请求 `read x`，`x` 应该返回多少？应该是2，因为在 `Raft` 层面，一条日志是否已提交只取决于是否复制到了过半数的节点上，而不是取决于客户端是否收到响应，而只要日志提交了就可以被应用到状态机。类似的场景可以想象一下平时填了某个表单，提交时提示系统异常，但是刷新页面后表单信息已更新。

第三个例子，

## 参考

* [Students' Guide to Raft](https://thesquareplanet.com/blog/students-guide-to-raft/)