title: 'MIT 6.824 - ZooKeeper: Wait-free coordination for Internet-scale systems'
tags:
- MIT 6.824
- Paper
- Distributed Systems
- ZooKeeper
---

## 介绍
大型分布式系统需要各式各样的协同。配置就是其中一种最基础的形式，在其最简单的形式中，配置只是一系列供系统使用的参数，而对于更复杂的系统来说，配置还可以动态更新。群组成员关系和选主同样在分布式系统中很常见：通常各进程需要知道哪些进程还存活，以及哪些进程在负责统一管理。另外，分布式锁作为一种强大的协调原语能够对临界资源提供互斥访问保护。

一种实现协同的方式是为每一个不同的协同需求开发一个服务。例如，`Amazon Simple Queue Service` 专注于消息队列。同时也存在专门为了选主和配置所开发的服务。针对较强的原语开发的服务能够用于实现较弱一级的原语。例如，`Chubby` 是一个强同步性保证的锁服务。则可以借助锁来实现选主，群组成员关系等服务。

相较于在服务端实现特定的协同原语，`ZooKeeper` 的作者选择暴露某些 `API` 来让应用开发者自行实现需要的原语。这种设计选择需要实现一个协同内核（`coordination kernel`）使得新原语的开发不需要修改核心服务端代码。这种方式能够适配应用程序对不同协同形式的需求，而不是让开发者受限于某几个固定的原语。

在设计 `ZooKeeper` 的 `API` 时，设计者移除了阻塞原语，例如锁。一个协同服务的阻塞原语会导致某些问题，缓慢或出错的客户端会拖慢快速的客户端的性能。如果服务处理请求时需要依赖响应以及负责客户端的异常检测，那么服务的实现会变得更为复杂。因此，`ZooKeeper` 实现了一套 `API` 能够操作以类似文件系统的方式组织的无等待（`wait-free`）对象。实际上，`ZooKeeper` 的 `API` 类似于其他任何的文件系统，以及和去除了加锁（`lock`），打开（`open`），关闭（`close`）这些方法的 `Chubby` 类似。实现了无等待对象的 `ZooKeeper` 显著有别于其他基于阻塞原语（例如锁）的系统。

虽然无等待这一特性对于性能和容错很重要，但是对于协同来说来不够。`ZooKeeper` 还需要对各操作提供其他保证。对客户端 `FIFO` 的操作保证和线性化写入的保证确保了服务的高效实现，同时也能够满足应用程序实现自定义协同原语的需求。实际上，利用 `ZooKeeper` 的 `API` 可以实现任意节点数量的共识算法。

`ZooKeeper` 服务通过服务器间的复制来实现高可用和性能。它的高性能使得大量客户端进程能通过协同内核来管理方方面面的协同需求。通过一种简单的管道架构来实现 `ZooKeeper` 使得服务在承受几百或上千的请求的同时依然保持着低延迟。这种管道方式天然的支持对同一个客户端的请求以 `FIFO` 的方式执行。对客户端请求的 `FIFO` 执行的保证使得客户端能异步的提交请求。异步提交也使得客户端同一时间有多个操作。这个特性很有用，例如当某个客户端成为主节点后，它需要操作元数据然后更新。如果缺少了多操作同时进行的特性，那么这个主节点初始化的时间可能达到秒级的数量级而不是亚秒级。

为了满足写入的线性化保证，`ZooKeeper` 实现了一个基于主节点的原子广播协议，即 `Zab`。典型的 `ZooKeeper` 应用属于读密集型应用，所以需要保证读操作的扩展性。`ZooKeeper` 的读操作由当前服务器完成，不涉及和其他服务器的交互，也不会使用 `Zab` 来保证读取的顺序性。

在客户端缓存数据是提高读性能的重要手段。例如，客户端可以缓存当前主节点的信息而不是每次请求 `ZooKeeper`。`ZooKeeper` 同时提供了监听机制来协助客户端缓存数据而无需直接管理客户端的缓存。借助这个机制，客户端可以对某个数据进行更新监听，从而在数据更新时收到通知。而 `Chubby` 会直接管理客户端的缓存，它会阻塞某个数据的更新直到所有缓存了该数据的客户端都清除了缓存。在这个设计下，如果某个客户端运行缓慢或者出错，则会拖慢数据的更新。`Chubby` 使用租约来避免某个客户端永久的阻塞系统。不过，租约只是确保了运行缓慢或者出错的客户端对性能的影响的上限，而 `ZooKeeper` 的监听机制则是完全的避免了这个问题。

本文主要介绍了 `ZooKeeper` 的设计和实现。借助 `ZooKeeper`，我们可以实现应用程序所需要的所有协同原语，即使只有写入是线性化保证的。为了验证这个设计，本文介绍了如何使用 `ZooKeeper` 来实现某些协同原语。

本文的关键点如下：

* 协同内核（`Coordination kernel`）：本文提出了一种供分布式系统使用的无等待、宽松一致性保证的协同服务。特别的，本文描述了一种协同内核的设计和实现，并且已经在很多重要的应用程序中所使用来实现各种各样的协同服务。
* 协同示例（`Coordination recipes`）：本文描述了如何使用 `ZooKeeper` 来实现高层次的协同原语，包括在分布式应用中经常用到的阻塞和强一致性的原语。
* 使用协同的经验（`Experience with Coordination`）：本文分享了使用 `ZooKeeper` 的方式以及评估了其性能。

## ZooKeeper 服务
客户端通过 `ZooKeeper` 提供的客户端类库来向 `ZooKeeper` 提交请求。除了向客户端暴露 `ZooKeeper` 提供的 `API` 外，客户端类库还负责维护客户端和 `ZooKeeper` 服务器间的连接。

本节会首先从高层次来介绍 `ZooKeeper` 服务，然后再讨论客户端和 `ZooKeeper` 交互的 `API`。

术语：本文使用客户端（`client`）来表示使用 `ZooKeeper` 服务的一个用户；使用服务端（`server`）来表示 `ZooKeeper` 的服务提供者；使用 `znode` 来表示 `ZooKeeper` 的一个内存数据节点，这些数据节点以层次化的命名空间的形式所组织，即 `data tree`。同时，本文使用更新（`update`）和写入（`write`）来表示任何修改 `data tree` 状态的操作。客户端和 `ZooKeeper` 通过建立 `session` 进行连接，并且通过 `session handle` 发送请求。

### 服务概览
`ZooKeeper` 将数据抽象成数据节点（`znodes`）后供客户端访问，所有数据节点以层次化的命名空间进行组织。`znodes` 是客户端可通过 `ZooKeeper` 的 `API` 操作的数据对象。层次化的命名空间通常被用于文件系统。因为用户已经习惯了这种抽象，所以 `ZooKeeper` 很自然的以这种方式来管理数据，另外这也能更好的管理应用程序的元数据。`ZooKeeper` 使用和标准 `UNIX` 文件系统命名一样的方式来表示一个 `znode`。例如，`A/B/C` 表示 `znode` `C` 的路径，并且 `C` 的父节点是 `B`，`B` 的父节点是 `A`。每个 `znode` 都会保存数据，而且除了临时节点之外的所有节点都可以有子节点。

客户端可以创建两种类型的 `znode`：

* 常规（`Regular`）：客户端可以显式的创建和删除常规节点。
* 临时（`Ephemeral`）：客户端创建临时节点后，可以显式的删除，或者当客户端和 `ZooKeeper` 的 `session` 结束后（客户端主动断开连接或者由于异常失去连接）由系统自动删除。

另外，客户端在创建一个 `znode` 时可以设置一个顺序标记。设置了顺序标记所创建的节点会在节点名称后追加一个单调递增的序号。如果 `n` 是一个新的 `znode`，`p` 是 `n` 的父节点，那么 `n` 的序号一定不会比在 `n` 之前所创建的 `p` 的子节点的序号小。

`ZooKeeper` 实现了监听器使得客户端能及时的收到数据修改的通知而无需轮询。当客户端发起一个读操作并设置监听时，这个读操作会和普通的读操作一样正常返回，不过当数据更新时，系统能通知客户端。监听器在单次 `session` 内只会被触发一次，一旦监听器被触发或者 `session` 关闭，该监听器就会被注销。监听器被触发表示监听的数据发生了修改，但是不会告知被修改后的值。例如，如果一个客户端在 `"/foo"` 被修改了两次之前执行了 `getData("/foo", true)`，那么客户端会收到一次通知表示 `"/foo"` 指向的数据被修改了。一些 `session` 级别的事件，例如连接丢失，也能通过监听回调通知给客户端，那么客户端就会知道监听通知可能会延迟。

#### 数据模型
`ZooKeeper` 的数据模型基本上等同于简化版 `API` 的文件系统，只能一次性读取或者写入全部数据；或者等同于是一个以层次结构组织键的键值表。层次结构的命名空间能够为不同的应用程序分配子命名空间，同时也方便为不同的子命名空间分配访问权限。同时 `ZooKeeper` 在客户端这层提供了文件夹的概念，能够用于构建高层次的原语。

和文件系统中的文件不同，`znodes` 的设计目的并不是为了通用数据存储。相反，`znodes` 是作为客户端应用程序的抽象，典型场景是用于协同目的的元数据。在下图中有两个子树，其中一个用于应用程序1（`/app1`），另一个用于应用程序2（`/app2`）。应用程序1对应的子树实现了一个简单的群组成员关系协议：每个客户端 `p_i` 在 `/app1` 下会创建一个 `znode` `p_i`，只要客户端还存活，对应的节点就会存在，那么，根据 `/app1` 下的节点数量就能知道当前应用程序有多少个存活的进程能提供服务。

![alt](/images/zookeeper-1.png)

虽然 `znodes` 的设计目的不是为了通用数据存储，不过 `ZooKeeper` 也允许客户端在 `znode` 中保存数据，例如分布式计算需要用到的元数据或者配置信息。例如，在一个基于选主的应用中，一个刚启动的应用程序节点需要知道当前的主节点是谁。为了实现这个目的，可以让当前主节点将主节点的信息写入到某个约定的 `znode` 路径中。此外，`znode` 本身也提供了时间戳和版本号这样的元数据，使得客户端能够监控 `znodes` 的数据变化，从而根据 `znode` 的版本进行数据更新。

## 参考

* [ZooKeeper: Wait-free coordination for Internet-scale systems](https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf)