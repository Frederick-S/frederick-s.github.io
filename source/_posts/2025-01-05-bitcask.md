title: '【读】Bitcask - A Log-Structured Hash Table for Fast Key/Value Data'
tags:
- Bitcask
---

## 介绍
`Bitcask` 是一个单机 `KV` 存储引擎，项目源于 `Riak` 分布式 `KV` 数据库需要一个能满足以下条件的单机 `KV` 存储引擎：
* 低延迟的单条读写
* 高吞吐，尤其是面对流式随机 `KV` 写入
* 能支持远比内存大的数据量
* 能从崩溃中快速恢复以及不丢失数据
* 能轻松的备份数据和还原
* 相对简单，易理解的代码结构和数据格式
* 在高负载和大数据场景下系统的行为是可预期的
* 软件的许可证要能轻易配合在 `Riak` 中使用

作者看了一圈发现市面上还没有一款 `KV` 存储能全部满足这些条件，因此 `Bitcask` 就应运而生。

## API
`Bitcask` 的接口非常精简：

|接口   |描述   |
|---|---|
|bitcask:open(DirectoryName, Opts) -> BitCaskHandle \| {error, any()}   |在指定目录下以指定选项打开或新建一个 `Bitcask` 实例。支持的选项包括 `read_write` 或者 `sync_on_put`：<ul><li>`read_write`：可读可写</li><li>`sync_on_put`：每次写操作后刷盘</li></ul> 连接的进程需要有 `DirectoryName` 对应目录的读写权限，同时一个时刻只能有一个进程以 `read_write` 的方式打开 `Bitcask` 实例。  |
|bitcask:open(DirectoryName) -> BitCaskHandle \| {error, any()}   |在指定目录下以只读模式打开或新建一个 `Bitcask` 实例。连接的进程需要有 `DirectoryName` 对应目录及其内部所有文件的读权限。   |
|bitcask:get(BitCaskHandle, Key) -> not_found \| {ok, Value}   |获取指定键对应的值。   |
|bitcask:put(BitCaskHandle, Key, Value) -> ok \| {error, any()}   |插入一个键值对。   |
|bitcask:delete(BitCaskHandle, Key) -> ok \| {error, any()}   |删除指定键。   |
|bitcask:list_keys(BitCaskHandle) -> [Key] \| {error, any()}   |返回所有的键。   |
|bitcask:fold(BitCaskHandle, Fun, Acc0) -> Acc   |对每一个键值对应用 `Fun` 函数，`Fun` 的函数签名为 `F(K, V, Acc0) -> Acc`。类似于 `JavaScript` 的 `reduce`。   |
|bitcask:merge(DirectoryName) -> ok \| {error, any()}   |合并目录下的数据文件以减少重复的键值对。同时生成 `hintfile` 辅助加速程序启动时间。   |
|bitcask:sync(BitCaskHandle) -> ok   |强制刷盘。   |
|bitcask:close(BitCaskHandle) -> ok   |关闭 `Bitcask` 实例的连接并刷盘。   |

## 参考
* [Bitcask - A Log-Structured Hash Table for Fast Key/Value Data](https://riak.com/assets/bitcask-intro.pdf)
