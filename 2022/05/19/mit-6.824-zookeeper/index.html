<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frederick-s.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍 大型分布式系统需要各式各样的协同。配置就是其中一种最基础的形式，在其最简单的形式中，配置只是一系列供系统使用的参数，而对于更复杂的系统来说，配置还可以动态更新。群组成员关系和选主同样在分布式系统中很常见：通常各进程需要知道哪些进程还存活，以及哪些进程在负责统一管理。另外，分布式锁作为一种强大的协调原语能够对临界资源提供互斥访问保护。 一种实现协同的方式是为每一个不同的协同需求开发一个服务。">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.824 - ZooKeeper: Wait-free coordination for Internet-scale systems">
<meta property="og:url" content="https://frederick-s.github.io/2022/05/19/mit-6.824-zookeeper/index.html">
<meta property="og:site_name" content="Übung macht den Meister">
<meta property="og:description" content="介绍 大型分布式系统需要各式各样的协同。配置就是其中一种最基础的形式，在其最简单的形式中，配置只是一系列供系统使用的参数，而对于更复杂的系统来说，配置还可以动态更新。群组成员关系和选主同样在分布式系统中很常见：通常各进程需要知道哪些进程还存活，以及哪些进程在负责统一管理。另外，分布式锁作为一种强大的协调原语能够对临界资源提供互斥访问保护。 一种实现协同的方式是为每一个不同的协同需求开发一个服务。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://frederick-s.github.io/images/zookeeper-1.png">
<meta property="og:image" content="https://frederick-s.github.io/images/zookeeper-2.png">
<meta property="article:published_time" content="2022-05-18T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-18T16:00:00.000Z">
<meta property="article:author" content="Xiaodan Mao">
<meta property="article:tag" content="Paper">
<meta property="article:tag" content="MIT 6.824">
<meta property="article:tag" content="Distributed Systems">
<meta property="article:tag" content="ZooKeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://frederick-s.github.io/images/zookeeper-1.png">

<link rel="canonical" href="https://frederick-s.github.io/2022/05/19/mit-6.824-zookeeper/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>MIT 6.824 - ZooKeeper: Wait-free coordination for Internet-scale systems | Übung macht den Meister</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J1NC2B33VK"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J1NC2B33VK');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Übung macht den Meister" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Übung macht den Meister</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fas fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-mit-6.824">

    <a href="/mit-6.824/" rel="section"><i class="fas fa-landmark fa-fw"></i>MIT 6.824</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fas fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Frederick-S" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/05/19/mit-6.824-zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT 6.824 - ZooKeeper: Wait-free coordination for Internet-scale systems
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-19T00:00:00+08:00">2022-05-19</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>26 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>大型分布式系统需要各式各样的协同。配置就是其中一种最基础的形式，在其最简单的形式中，配置只是一系列供系统使用的参数，而对于更复杂的系统来说，配置还可以动态更新。群组成员关系和选主同样在分布式系统中很常见：通常各进程需要知道哪些进程还存活，以及哪些进程在负责统一管理。另外，分布式锁作为一种强大的协调原语能够对临界资源提供互斥访问保护。</p>
<p>一种实现协同的方式是为每一个不同的协同需求开发一个服务。例如，<code>Amazon Simple Queue Service</code> 专注于消息队列。同时也存在专门为了选主和配置所开发的服务。针对较强的原语开发的服务能够用于实现较弱一级的原语。例如，<code>Chubby</code> 是一个强同步性保证的锁服务。则可以借助锁来实现选主，群组成员关系等服务。</p>
<p>相较于在服务端实现特定的协同原语，<code>ZooKeeper</code> 的作者选择暴露某些 <code>API</code> 来让应用开发者自行实现需要的原语。这种设计选择需要实现一个协同内核（<code>coordination kernel</code>）使得新原语的开发不需要修改核心服务端代码。这种方式能够适配应用程序对不同协同形式的需求，而不是让开发者受限于某几个固定的原语。</p>
<p>在设计 <code>ZooKeeper</code> 的 <code>API</code> 时，设计者移除了阻塞原语，例如锁。一个协同服务的阻塞原语会导致某些问题，缓慢或出错的客户端会拖慢快速的客户端的性能。如果服务处理请求时需要依赖响应以及负责客户端的异常检测，那么服务的实现会变得更为复杂。因此，<code>ZooKeeper</code> 实现了一套 <code>API</code> 能够操作以类似文件系统的方式组织的无等待（<code>wait-free</code>）对象。实际上，<code>ZooKeeper</code> 的 <code>API</code> 类似于其他任何的文件系统，以及和去除了加锁（<code>lock</code>），打开（<code>open</code>），关闭（<code>close</code>）这些方法的 <code>Chubby</code> 类似。实现了无等待对象的 <code>ZooKeeper</code> 显著有别于其他基于阻塞原语（例如锁）的系统。</p>
<p>虽然无等待这一特性对于性能和容错很重要，但是对于协同来说来不够。<code>ZooKeeper</code> 还需要对各操作提供其他保证。对客户端 <code>FIFO</code> 的操作保证和线性化写入的保证确保了服务的高效实现，同时也能够满足应用程序实现自定义协同原语的需求。实际上，利用 <code>ZooKeeper</code> 的 <code>API</code> 可以实现任意节点数量的共识算法。</p>
<p><code>ZooKeeper</code> 服务通过服务器间的复制来实现高可用和性能。它的高性能使得大量客户端进程能通过协同内核来管理方方面面的协同需求。通过一种简单的管道架构来实现 <code>ZooKeeper</code> 使得服务在承受几百或上千的请求的同时依然保持着低延迟。这种管道方式天然的支持对同一个客户端的请求以 <code>FIFO</code> 的方式执行。对客户端请求的 <code>FIFO</code> 顺序执行的保证使得客户端能异步的提交请求。异步提交也使得客户端同一时间有多个操作。这个特性很有用，例如当某个客户端成为主节点后，它需要操作元数据然后更新。如果缺少了多操作同时进行的特性，那么这个主节点初始化的时间可能达到秒级的数量级而不是亚秒级。</p>
<p>为了满足写入的线性化保证，<code>ZooKeeper</code> 实现了一个基于主节点的原子广播协议，即 <code>Zab</code>。典型的 <code>ZooKeeper</code> 应用属于读密集型应用，所以需要保证读操作的扩展性。<code>ZooKeeper</code> 的读操作由当前服务器完成，不涉及和其他服务器的交互，也不会使用 <code>Zab</code> 来保证读取的顺序性。</p>
<p>在客户端缓存数据是提高读性能的重要手段。例如，客户端可以缓存当前主节点的信息而不是每次请求 <code>ZooKeeper</code>。<code>ZooKeeper</code> 同时提供了监听机制来协助客户端缓存数据而无需直接管理客户端的缓存。借助这个机制，客户端可以对某个数据进行更新监听，从而在数据更新时收到通知。而 <code>Chubby</code> 会直接管理客户端的缓存，它会阻塞某个数据的更新直到所有缓存了该数据的客户端都清除了缓存。在这个设计下，如果某个客户端运行缓慢或者出错，则会拖慢数据的更新。<code>Chubby</code> 使用租约来避免某个客户端永久的阻塞系统。不过，租约只是确保了运行缓慢或者出错的客户端对性能的影响的上限，而 <code>ZooKeeper</code> 的监听机制则是完全的避免了这个问题。</p>
<p>本文主要介绍了 <code>ZooKeeper</code> 的设计和实现。借助 <code>ZooKeeper</code>，我们可以实现应用程序所需要的所有协同原语，即使只有写入是线性化保证的。为了验证这个设计，本文介绍了如何使用 <code>ZooKeeper</code> 来实现某些协同原语。</p>
<p>本文的关键点如下：</p>
<ul>
<li>协同内核（<code>Coordination kernel</code>）：本文提出了一种供分布式系统使用的无等待、宽松一致性保证的协同服务。特别的，本文描述了一种协同内核的设计和实现，并且已经在很多重要的应用程序中使用来实现各种各样的协同服务。</li>
<li>协同示例（<code>Coordination recipes</code>）：本文描述了如何使用 <code>ZooKeeper</code> 来实现高层次的协同原语，包括在分布式应用中经常用到的阻塞和强一致性的原语。</li>
<li>使用协同的经验（<code>Experience with Coordination</code>）：本文分享了使用 <code>ZooKeeper</code> 的方式以及评估了其性能。</li>
</ul>
<h2 id="zookeeper-服务"><a class="markdownIt-Anchor" href="#zookeeper-服务"></a> ZooKeeper 服务</h2>
<p>客户端通过 <code>ZooKeeper</code> 提供的客户端类库来向 <code>ZooKeeper</code> 提交请求。除了向客户端暴露 <code>ZooKeeper</code> 提供的 <code>API</code> 外，客户端类库还负责维护客户端和 <code>ZooKeeper</code> 服务器间的连接。</p>
<p>本节会首先从高层次来介绍 <code>ZooKeeper</code> 服务，然后再讨论客户端和 <code>ZooKeeper</code> 交互的 <code>API</code>。</p>
<p>术语：本文使用客户端（<code>client</code>）来表示使用 <code>ZooKeeper</code> 服务的一个用户；使用服务端（<code>server</code>）来表示 <code>ZooKeeper</code> 的服务提供者；使用 <code>znode</code> 来表示 <code>ZooKeeper</code> 的一个内存数据节点，这些数据节点以层次化的命名空间的形式所组织，即 <code>data tree</code>。同时，本文使用更新（<code>update</code>）和写入（<code>write</code>）来表示任何修改 <code>data tree</code> 状态的操作。客户端和 <code>ZooKeeper</code> 通过建立 <code>session</code> 进行连接，并且通过 <code>session handle</code> 发送请求。</p>
<h3 id="服务概览"><a class="markdownIt-Anchor" href="#服务概览"></a> 服务概览</h3>
<p><code>ZooKeeper</code> 将数据抽象成数据节点（<code>znodes</code>）后供客户端访问，所有数据节点以层次化的命名空间进行组织。<code>znodes</code> 是客户端可通过 <code>ZooKeeper</code> 的 <code>API</code> 操作的数据对象。层次化的命名空间通常被用于文件系统。因为用户已经习惯了这种抽象，所以 <code>ZooKeeper</code> 很自然的以这种方式来管理数据，另外这也能更好的管理应用程序的元数据。<code>ZooKeeper</code> 使用和标准 <code>UNIX</code> 文件系统命名一样的方式来表示一个 <code>znode</code>。例如，<code>A/B/C</code> 表示 <code>znode</code> <code>C</code> 的路径，并且 <code>C</code> 的父节点是 <code>B</code>，<code>B</code> 的父节点是 <code>A</code>。每个 <code>znode</code> 都会保存数据，而且除了临时节点之外的所有节点都可以有子节点。</p>
<p>客户端可以创建两种类型的 <code>znode</code>：</p>
<ul>
<li>常规（<code>Regular</code>）：客户端可以显式的创建和删除常规节点。</li>
<li>临时（<code>Ephemeral</code>）：客户端创建临时节点后，可以显式的删除，或者当客户端和 <code>ZooKeeper</code> 的 <code>session</code> 结束后（客户端主动断开连接或者由于异常失去连接）由系统自动删除。</li>
</ul>
<p>另外，客户端在创建一个 <code>znode</code> 时可以设置一个顺序标记。设置了顺序标记所创建的节点会在节点名称后追加一个单调递增的序号。如果 <code>n</code> 是一个新的 <code>znode</code>，<code>p</code> 是 <code>n</code> 的父节点，那么 <code>n</code> 的序号一定不会比在 <code>n</code> 之前所创建的 <code>p</code> 的子节点的序号小。</p>
<p><code>ZooKeeper</code> 实现了监听器使得客户端能及时的收到数据修改的通知而无需轮询。当客户端发起一个读操作并设置监听时，这个读操作会和普通的读操作一样正常返回，不过当数据更新时，系统能通知客户端。监听器在单次 <code>session</code> 内只会被触发一次，一旦监听器被触发或者 <code>session</code> 关闭，该监听器就会被注销。监听器被触发表示监听的数据发生了修改，但是不会告知被修改后的值。例如，如果一个客户端在 <code>&quot;/foo&quot;</code> 被修改了两次之前执行了 <code>getData(&quot;/foo&quot;, true)</code>，那么客户端会收到一次通知表示 <code>&quot;/foo&quot;</code> 指向的数据被修改了。一些 <code>session</code> 级别的事件，例如连接丢失，也能通过监听回调通知给客户端，那么客户端就会知道监听通知可能会延迟。</p>
<h4 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h4>
<p><code>ZooKeeper</code> 的数据模型基本上等同于简化版 <code>API</code> 的文件系统，只能一次性读取或者写入全部数据；或者等同于是一个以层次结构组织键的键值表。层次结构的命名空间能够为不同的应用程序分配子命名空间，同时也方便为不同的子命名空间分配访问权限。同时 <code>ZooKeeper</code> 在客户端这层提供了文件夹的概念，能够用于构建高层次的原语。</p>
<p>和文件系统中的文件不同，<code>znodes</code> 的设计目的并不是为了通用数据存储。相反，<code>znodes</code> 是作为客户端应用程序的抽象，典型场景是用于保存协同目的的元数据。在下图中有两个子树，其中一个用于应用程序1（<code>/app1</code>），另一个用于应用程序2（<code>/app2</code>）。应用程序1对应的子树实现了一个简单的群组成员关系协议：每个客户端 <code>p_i</code> 在 <code>/app1</code> 下会创建一个 <code>znode</code> <code>p_i</code>，只要客户端还存活，对应的节点就会存在，那么，根据 <code>/app1</code> 下的节点数量就能知道当前应用程序有多少个存活的进程能提供服务。</p>
<p><img src="/images/zookeeper-1.png" alt="alt" /></p>
<p>虽然 <code>znodes</code> 的设计目的不是为了通用数据存储，不过 <code>ZooKeeper</code> 也允许客户端在 <code>znode</code> 中保存数据，例如分布式计算需要用到的元数据或者配置信息。例如，在一个基于选主的应用中，一个刚启动的应用程序节点需要知道当前的主节点是谁。为了实现这个目的，可以让当前主节点将主节点的信息写入到某个约定的 <code>znode</code> 路径中。此外，<code>znode</code> 本身也提供了时间戳和版本号这样的元数据，使得客户端能够监控 <code>znodes</code> 的数据变化，从而根据 <code>znode</code> 的数据版本进行数据更新。</p>
<h4 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h4>
<p>一个客户端连接到 <code>ZooKeeper</code> 时会初始化一个 <code>session</code>。每一个 <code>session</code> 伴随着一个超时时间。如果在一个超时时间之内 <code>ZooKeeper</code> 没有收到来自客户端的任何请求，那么 <code>ZooKeeper</code> 就会认为这个客户端发生了异常。客户端可以主动通过关闭 <code>session handle</code> 来结束一个 <code>session</code> 或者 <code>ZooKeeper</code> 监测到客户端发生异常而自动关闭 <code>session</code>。在一个 <code>session</code> 内，客户端所观察到的系统状态变化和其提交的操作一一顺序对应。在一个 <code>session</code> 内，如果当前客户端连接的 <code>ZooKeeper</code> 节点发生异常，<code>ZooKeeper</code> 客户端类库能无缝的将其连接到一台新的 <code>ZooKeeper</code> 节点上，从而在各节点间完成持久化。</p>
<h3 id="客户端-api"><a class="markdownIt-Anchor" href="#客户端-api"></a> 客户端 API</h3>
<p><code>ZooKeeper</code> 提供了以下的核心 <code>API</code>：</p>
<ul>
<li><code>create(path, data, flags)</code>：创建一个路径为 <code>path</code> 的 <code>znode</code>，并将数据 <code>data[]</code> 保存其中，然后返回新建的 <code>znode</code> 的名称。<code>flags</code> 用于指定 <code>znode</code> 的类型：常规节点，临时节点，以及设置顺序标记。</li>
<li><code>delete(path, version)</code>：如果指定路径 <code>path</code> 下的 <code>znode</code> 的版本号和 <code>version</code> 匹配，则删除该节点。</li>
<li><code>exists(path, watch)</code>：如果指定路径 <code>path</code> 下的 <code>znode</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。如果 <code>watch</code> 为 <code>true</code>，则当 <code>znode</code> 的数据发生变化时，客户端会收到通知。</li>
<li><code>getData(path, watch)</code>：获取指定路径 <code>path</code> 下的 <code>znode</code> 的数据和元数据，例如版本信息。<code>watch</code> 的功能和 <code>exists()</code> 中的 <code>watch</code> 的功能一致，只不过如果当前节点不存在，则 <code>watch</code> 不会生效。</li>
<li><code>setData(path, data, version)</code>：如果指定路径 <code>path</code> 下的 <code>znode</code> 的版本号和 <code>version</code> 匹配，则将数据 <code>data[]</code> 写入到该节点。</li>
<li><code>getChildren(path, watch)</code>：返回指定路径 <code>path</code> 下的 <code>znode</code> 的子节点的名称。</li>
<li><code>sync(path)</code>：阻塞等待直到在操作开始时所有进行中的更新操作都同步到了当前客户端所连接的服务端。<code>path</code> 参数当前未使用。</li>
</ul>
<p><code>ZooKeeper</code> 通过 <code>API</code> 为每个方法提供了同步和异步两个版本。当应用程序希望执行单一 <code>ZooKeeper</code> 操作而且没有其他并发任务要执行时，可以选择调用同步方法。而如果应用程序希望同时执行多个 <code>ZooKeeper</code> 操作以及有其他任务需要并发执行时，可以选择调用异步方法。<code>ZooKeeper</code> 客户端类库保证了异步方法的回调顺序和提交请求的顺序一致。</p>
<p><code>ZooKeeper</code> 不直接通过 <code>handles</code> 来访问 <code>znodes</code>。每个客户端请求会带上所要操作的 <code>znode</code> 的全路径。这不仅简化了 <code>API</code>（没有 <code>open()</code> 或者 <code>close()</code> 方法），同时服务端也不需要维护额外的状态。</p>
<p>客户端对 <code>ZooKeeper</code> 每个更新操作都会带上一个期望的版本号，这就能实现按条件更新。如果当前 <code>znode</code> 的版本号和期望的版本号不一致，那么此次更新就会失败并返回版本不匹配错误。如果传入的版本号是-1，则表示不进行版本号校验。</p>
<h3 id="zookeeper-的保证"><a class="markdownIt-Anchor" href="#zookeeper-的保证"></a> ZooKeeper 的保证</h3>
<p><code>ZooKeeper</code> 有两个基本的顺序保证：</p>
<ul>
<li>线性化写入（<code>Linearizable writes</code>）：所有对 <code>ZooKeeper</code> 的状态修改都会按序串行化执行。</li>
<li>先来先执行的客户端顺序（<code>FIFO client order</code>）：来自同一个客户端的所有请求会按照请求发送的顺序执行。</li>
</ul>
<p><code>ZooKeeper</code> 提出的线性化和 <code>Herlihy</code> 提出的线性化有所不同，<code>ZooKeeper</code> 的作者称之为 <code>A-linearizability</code>（<code>asynchronous linearizability</code>）。在 <code>Herlihy</code> 的线性化定义下，一个客户端只能有一个进行中的操作（一个客户端对应一个线程）。而在 <code>ZooKeeper</code> 中，一个客户端允许有多个进行中的操作，那么从设计上可以选择对多个进行中的任务不保证执行顺序，或者保证 <code>FIFO</code> 顺序。<code>ZooKeeper</code> 选择了后者。如果一系列操作的结果适用于 <code>linearizable</code> 的对象，那么也同时适用于 <code>A-linerizalbe</code> 的对象，因为 <code>A-linearizability</code> 本身就满足线性化。因为只有更新操作需要满足 <code>A-linerizalbe</code>，所以 <code>ZooKeeper</code> 的读操作可以直接通过本地副本执行。进一步使得添加新的服务器时能实现对服务的线性扩展。</p>
<p>下面将通过一个场景示例来说明上述两个保证是如何交互的。某个系统需要选举一个主节点来分配任务给其他工作节点执行。每当新选举了一个主节点，它需要更新大量的配置参数并且当更新完成时通知其他的工作节点。这就带来了两个重要的需求：</p>
<ul>
<li>当主节点在更新配置参数时，其他工作节点不能使用还未更新完成的配置参数。</li>
<li>如果主节点在配置参数更新完成前发生异常，其他工作节点也不能使用未更新完成的配置参数。</li>
</ul>
<p>类似 <code>Chubby</code> 提供的分布式锁能满足第一个需求，但是不足以满足第二个需求，因为当其他工作节点获取锁读取配置参数时，它并不能知道配置参数是否已更新完成。在 <code>ZooKeeper</code> 中，主节点可以在某个约定的路径创建一个 <code>ready</code> 节点，只有在 <code>ready</code> 节点存在的情况下，其他工作节点才可以认为配置参数已更新完成。在更新配置参数前，主节点会先删除 <code>ready</code> 节点，然后更新配置参数，最后再创建 <code>ready</code> 节点。所有这些操作都可以以管道的方式进行并异步提交请求，从而使得配置参数能快速更新。虽然一次更新操作的耗时是2毫秒的数量级，但是如果主节点需要阻塞的依次更新5000个配置参数的话则一共需要10秒才能完成；通过异步提交更新，所有的请求能在一秒内完成。因为 <code>ZooKeeper</code> 的顺序性保证，如果某个工作节点发现 <code>ready</code> 节点存在，那么就说明配置参数也必然更新完成了，因为 <code>ready</code> 节点的创建晚于配置参数的更新。如果主节点在配置参数更新完成前发生异常，那么也就不会创建 <code>ready</code> 节点，其他工作节点就知道配置参数更新未完成。</p>
<p>不过上述方案还存在一个问题：如果某个工作节点此时看见 <code>ready</code> 节点存在，但是同时主节点删除了 <code>ready</code> 节点然后开始更新配置参数，那么工作节点就会读取到正在更新的配置参数。这个问题通过监听通知的顺序性保证来解决：如果客户端对某个节点 <code>A</code> 开启了监听，此时系统先对节点 <code>A</code> 进行了修改，然后对另一个节点 <code>B</code> 进行了修改，此时客户端发起了对节点 <code>B</code> 的读请求，那么 <code>ZooKeeper</code> 会保证客户端先收到节点 <code>A</code> 修改的异步通知。所以，如果客户端在判断 <code>ready</code> 节点是否存在时开启了监听，那么它就会在读取到修改中的配置参数前先收到 <code>ready</code> 节点修改的通知，从而可以中断配置参数的读取。</p>
<p>如果客户端之间还有除了 <code>ZooKeeper</code> 之外的通信方式也会引发另一个问题。例如，两个客户端 <code>A</code> 和 <code>B</code> 通过 <code>ZooKeeper</code> 共享配置，然后通过其他某种方式通信。如果 <code>A</code> 修改了 <code>ZooKeeper</code> 中的配置然后告诉 <code>B</code>，那么 <code>B</code> 收到通知后读取 <code>ZooKeeper</code> 就期望能获取到修改后的配置。不过如果 <code>B</code> 连接的 <code>ZooKeeper</code> 副本落后于主节点，那么 <code>B</code> 可能无法读取到最新的配置。而采用写入 <code>ready</code> 节点再读取的方式能保证 <code>B</code> 读取到最新的配置。<code>ZooKeeper</code> 提供了 <code>sync</code> 方法来更高效的解决这个问题：如果 <code>sync</code> 请求之后有一个读请求，则 <code>ZooKeeper</code> 会暂缓这个读请求。<code>sync</code> 会同步在这之前进行中的写请求，而无需等待当前所有的待写入操作完成。这个原语类似于 <code>ISIS</code> 中的 <code>flush</code> 原语。</p>
<p><code>ZooKeeper</code> 同时也有存活性（<code>liveness</code>）和持久性（<code>durability</code>）的保证：只要 <code>ZooKeeper</code> 集群中过半数的机器存活，那么访问 <code>ZooKeeper</code> 服务就没有问题；如果 <code>ZooKeeper</code> 成功响应了某个修改请求，只要过半数的机器在异常后最终能恢复，那么不管经历了多少次系统异常这个更新都不会丢失。</p>
<h3 id="原语示例"><a class="markdownIt-Anchor" href="#原语示例"></a> 原语示例</h3>
<p>本节描述了如何利用 <code>ZooKeeper</code> 的 <code>API</code> 来构建更强大的原语。对于 <code>ZooKeeper</code> 来说，它并不知晓这些原语的存在，因为这些原语是由客户端通过 <code>API</code> 自行实现的。一些通用的原语例如群组成员关系和配置管理都是无等待原语。对于其他原语如 <code>rendezvous</code>，客户端则需要等待某个事件发生。虽然 <code>ZooKeeper</code> 是无等待服务，客户端也同样可以实现阻塞的原语。<code>ZooKeeper</code> 的顺序保证可以高效的审视系统的状态，而监听机制则实现了高效的等待。</p>
<h4 id="配置管理configuration-management"><a class="markdownIt-Anchor" href="#配置管理configuration-management"></a> 配置管理（Configuration Management）</h4>
<p><code>ZooKeeper</code> 可以用于分布式系统中实现动态配置管理。在最简单的形式中，配置信息保存在一个 <code>znode</code> 中，例如 <code>z_c</code>。应用启动时会读取 <code>z_c</code> 的数据并设置监听状态。如果 <code>z_c</code> 的数据更新了，那么应用就会收到通知，然后就可以读取最新的配置，并继续设置监听状态。</p>
<p>在这个例子以及其他大多数使用监听器的例子中，监听器确保了应用能获取到最新的数据。例如，如果某个监听 <code>z_c</code> 的应用收到了 <code>z_c</code> 的修改通知，而在这个应用读取 <code>z_c</code> 之前，<code>z_c</code> 又被修改了3次，那么这个应用不会再收到通知。这并不会影响应用的行为，因为 <code>ZooKeeper</code> 的变更通知不会返回更新后的数据，应用需要再次读取才能获得节点最新的数据，只通知一次已经使得应用知道当前节点的数据已经过期，没有必要重复通知。</p>
<h4 id="rendezvous"><a class="markdownIt-Anchor" href="#rendezvous"></a> Rendezvous</h4>
<p>有时候在分布式系统中并不能清晰的预知系统的最终配置是什么。例如，某个客户端可能会希望启动一个主节点和几个工作节点，不过由于节点的启动是由某个调度器执行，客户端并不能事先知道某些需要的信息，例如工作节点需要连接的主节点的地址和端口号。这个问题可以由客户端通过 <code>ZooKeeper</code> 创建一个 <code>rendezvous</code> 节点 <code>z_r</code> 来解决。客户端将 <code>z_r</code> 的全路径作为启动参数传给主节点和工作节点。当主节点启动后，它就将自己的地址和端口号写入到 <code>z_r</code> 中。当工作节点启动后，它就能从 <code>z_r</code> 中读取主节点的地址和端口号，并设置节点的监听状态。如果工作节点启动时主节点还未写入数据到 <code>z_r</code>，那么工作节点就会等待数据写入的通知。如果 <code>z_r</code> 是临时节点，那么创建 <code>z_r</code> 节点的客户端下线后，主节点和工作节点就能收到节点删除通知，并在完成资源清理后退出。</p>
<h4 id="群组成员关系group-membership"><a class="markdownIt-Anchor" href="#群组成员关系group-membership"></a> 群组成员关系（Group Membership）</h4>
<p>客户端可以利用临时节点的特性来实现群组成员关系管理。这里利用了可以通过监听临时节点来观测创建该节点的 <code>session</code> 状态的特性。首先创建一个节点 <code>z_g</code> 来表示群组。当群组中的某个进程启动时，它会在 <code>z_g</code> 下创建一个临时的子节点。如果每个进程都有唯一的命名或标识，那么这个命名或标识就可以作为 <code>ZooKeeper</code> 节点的名称；否则就可以在创建节点时设置 <code>SEQUENTIAL</code> 标记让 <code>ZooKeeper</code> 自动在节点名称后追加一个单调递增的数字，以保证名称的唯一性。各进程可以将进程相关的信息放到临时节点中，例如当前进程的地址和端口号。</p>
<p>当进程在节点 <code>z_g</code> 下创建完临时进程后就可以正常启动。它不需要做其他任何事。如果这个进程发生异常或者主动结束，那么它所创建的临时节点也会自动被删除。</p>
<p>各进程可以简单的通过查询 <code>z_g</code> 的所有子节点来获取当前群组成员的信息。如果某个进程想要监控群组成员的变化，那么它可以设置监听标记（通过 <code>getChildren(path, watch)</code> 方法设置 <code>watch</code>），然后在收到通知时更新群组信息。</p>
<h4 id="简单锁simple-locks"><a class="markdownIt-Anchor" href="#简单锁simple-locks"></a> 简单锁（Simple Locks）</h4>
<p>虽然 <code>ZooKeeper</code> 不是一个锁服务，但也可以用来实现锁。使用 <code>ZooKeeper</code> 的应用通常使用同步原语来适配其需求。本节通过使用 <code>ZooKeeper</code> 实现锁来展示可以通过 <code>ZooKeeper</code> 来实现各种各样的通用同步原语。</p>
<p>最简单的锁实现借助于 <code>lock files</code>。使用一个 <code>znode</code> 来表示一把锁。为了获取锁，客户端会尝试以 <code>EPHEMERAL</code> 标记创建一个临时节点。如果创建成功，那么这个客户端就获得了锁。否则，客户端就会去读取这个 <code>znode</code> 并设置监听状态，从而当这个临时节点被删除时能收到通知。当持有锁的客户端发生异常或者主动删除该节点时，则代表释放了锁。其他监听的客户端就会收到通知并尝试重新创建临时节点来获取锁。</p>
<p>虽然这种方式能实现锁，不过也存在几个问题。首先，它会造成羊群效应（<code>herd effect</code>）。如果有大量的客户端在等待释放锁，那么当锁被释放时，这些客户端都会被通知然后都会尝试获取锁，而实际上只会有一个客户端能获得锁。第二，这种方式只实现了互斥锁。下面两种原语展示了如何解决这两个问题。</p>
<h4 id="没有羊群效应的简单锁simple-locks-without-herd-effect"><a class="markdownIt-Anchor" href="#没有羊群效应的简单锁simple-locks-without-herd-effect"></a> 没有羊群效应的简单锁（Simple Locks without Herd Effect）</h4>
<p>首先定义节点 <code>l</code> 来实现锁。然后，将所有希望获取锁的客户端按照请求顺序排序，之后这些客户端就能按照请求的顺序获取锁。客户端希望获取锁时需要执行下面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock</span><br><span class="line">1 n &#x3D; create(l + &quot;&#x2F;lock-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C &#x3D; getChildren(l, false)</span><br><span class="line">3 if n is lowest znode in C, exit</span><br><span class="line">4 p &#x3D; znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for watch event</span><br><span class="line">6 goto 2</span><br><span class="line"></span><br><span class="line">Unlock</span><br><span class="line">1 delete(n)</span><br></pre></td></tr></table></figure>
<p>第一行 <code>SEQUENTIAL</code> 的标记用来将所有希望获取锁的客户端进行排序。每个客户端首先在节点 <code>l</code> 下创建一个临时顺序的子节点，然后获取 <code>l</code> 的所有子节点。之后在第三行判断自己创建的节点是否在所有子节点中有着最小的序号，如果是，则表示当前客户端获得了锁。如果不是，说明有其他序号更小的子节点存在，当前客户端需要排在这之后获取锁。然后客户端会尝试判断排在当前序号前的子节点是否存在，如果存在则设置监听状态等待前一个节点删除的通知，如果不存在，则继续回到第二行执行。每个客户端只监听排在自己前面的子节点避免了羊群效应，因为任何一个子节点删除的通知只会发给其中的一个客户端。每当客户端收到前面节点删除的通知时，需要再次获取 <code>l</code> 的所有子节点来判断自己是否是最小子节点（因为排在前面的子节点并不一定持有锁，可能是更前面的子节点持有锁。这里能否直接复用第一次请求 <code>getChildren</code> 的信息？实现起来会较麻烦些，因为需要挨个判断排在前面的子节点是否还存在，不如直接拉取一份最新的子节点信息）。</p>
<p>释放锁就是简单的删除对应的临时节点 <code>n</code>。而通过 <code>EPHEMERAL</code> 创建节点能保证进程异常时自动释放锁或者放弃对锁的获取请求。</p>
<p>这种锁实现有以下几个优势：</p>
<ol>
<li>一个节点的删除只会唤醒一个客户端，因为每个节点都只会被一个客户端监听，所以也不会有羊群效应。</li>
<li>锁的获取和释放不依赖轮询或超时。</li>
<li>使用这种方式创建锁使得可以通过查看 <code>ZooKeeper</code> 中的数据来监测锁竞争的数量，以及调试锁相关的问题。</li>
</ol>
<h4 id="读写锁readwrite-locks"><a class="markdownIt-Anchor" href="#读写锁readwrite-locks"></a> 读写锁（Read/Write Locks）</h4>
<p>在前面锁的基础上稍加修改就能实现一个读写锁。释放锁的操作和前面的相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Write Lock</span><br><span class="line">1 n &#x3D; create(l + &quot;&#x2F;write-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C &#x3D; getChildren(l, false)</span><br><span class="line">3 if n is lowest znode in C, exit</span><br><span class="line">4 p &#x3D; znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for watch event</span><br><span class="line">6 goto 2</span><br><span class="line"></span><br><span class="line">Read Lock</span><br><span class="line">1 n &#x3D; create(l + &quot;&#x2F;read-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C &#x3D; getChildren(l, false)</span><br><span class="line">3 if no write znodes lower than n in C, exit</span><br><span class="line">4 p &#x3D; write znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for watch event</span><br><span class="line">6 goto 3</span><br></pre></td></tr></table></figure>
<p>写锁是互斥锁，这里的实现和前面的锁的实现一模一样，只是改变了创建节点的名称。而由于读锁之间没有互斥，所以获取读锁时只需要检查有没有序号更小的写锁即可。另外，读锁实现时最后的 <code>goto</code> 直接跳到了第三行而没有到第二行，这个在 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/zookeeper-faq.txt">ZooKeeper FAQ</a> 中也提到可能是个笔误。这里看起来会有羊群效应，即存在大量的客户端会监听某个写锁，当写锁被删除时这些客户端都会收到通知，不过这本身就是预期的行为，因为读锁之间没有互斥，写锁释放后就应该唤醒所有等待中的读锁。</p>
<h4 id="双屏障double-barrier"><a class="markdownIt-Anchor" href="#双屏障double-barrier"></a> 双屏障（Double Barrier）</h4>
<p>双屏障用于客户端在某个计算开始和结束时进行同步，当指定数量的进程加入到屏障中后，就可以开始各自的计算任务，每个进程在整个计算任务结束后就可以离开屏障。<code>MapReduce</code> 任务就是一个典型示例，<code>reduce</code> 任务的开始需要所有 <code>map</code> 任务的完成，当所有 <code>map</code> 任务完成后，各进程就可以进入屏障开始 <code>reduce</code> 任务，而整个 <code>MapRecuce</code> 任务的完成依赖所有 <code>reduce</code> 任务的完成，当所有 <code>reduce</code> 任务完成后，各进程就可以离开屏障。客户端可以使用一个 <code>znode</code> 来表示屏障，记作 <code>b</code>。每个进程在 <code>b</code> 下创建一个子节点来表示进入屏障，通过删除子节点来表示离开屏障。如果 <code>b</code> 下的子节点的数量超过了指定值，那么就允许开始执行计算任务。当 <code>b</code> 下的子节点都被删除后，进程就可以离开屏障。这里同样使用监听机制来高效的等待进入屏障和离开屏障的事件发生。一旦 <code>b</code> 下的子节点数量满足了阈值，创建最后一个子节点的进程会同时创建一个 <code>ready</code> 子节点，那么通过监听 <code>ready</code> 子节点是否存在就可以判断是否可以开始计算。另一方面，论文中提到通过监听某个特定的子节点来判断是否可以离开屏障，这里略显模糊，这个特定的子节点是谁创建的？创建了这个子节点的进程什么时候可以删除这个子节点？<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/zookeeper-faq.txt">ZooKeeper FAQ</a> 中提出了另一种方案，每个进程各自监听 <code>b</code> 下的子节点，并且在任务完成后删除所创建的节点，如果各进程发现 <code>b</code> 下没有子节点了，就说明可以离开屏障，整个计算任务已结束。</p>
<h2 id="zookeeper-的实现"><a class="markdownIt-Anchor" href="#zookeeper-的实现"></a> ZooKeeper 的实现</h2>
<p><code>ZooKeeper</code> 通过将数据复制到每台服务器上来实现服务的高可用。<code>ZooKeeper</code> 处理的服务器异常针对的是服务器宕机，且这些异常的服务器可能之后会恢复。下图展示了 <code>ZooKeeper</code> 服务的主要组件。当 <code>ZooKeeper</code> 服务收到一个请求时，会对这个请求进行预处理（<code>request processor</code>），如果这个请求需要各服务器协同完成（例如写请求），则会通过一致性协议处理（一种 <code>atomic broadcast</code> 的实现），最终 <code>ZooKeeper</code> 会将修改提交到各服务器副本中。而对于读请求，服务端则直接从本地数据库中读取数据然后返回给客户端。</p>
<p><img src="/images/zookeeper-2.png" alt="alt" /></p>
<p>上图中的复制数据库是包含了整个数据树（<code>data tree</code>）的内存数据库。每个 <code>znode</code> 默认最多保存 <code>1MB</code> 数据，不过这个值可以根据需要通过配置修改。从可恢复性考虑，<code>ZooKeeper</code> 会高效的将更新写入到磁盘，并且将更新写入到内存数据库前会先强制将数据刷新到磁盘中。类似于 <code>Chubby</code>，<code>ZooKeeper</code> 也会将提交的操作写入到重放日志中，并且会周期性的对内存数据库生成快照。</p>
<p>每个 <code>ZooKeeper</code> 服务端都能对客户端提供服务。客户端只会连接一个服务端然后提交请求。在之前提到过，读请求会直接返回当前服务端本地的数据。而修改系统状态的请求、写请求则会交由一致性协议处理。</p>
<p>作为一致性协议的一部分，客户端的写请求会转发给单台服务器，称之为主节点（<code>leader</code>）。其他的 <code>ZooKeeper</code> 服务器被称之为从节点（<code>followers</code>），从节点会收到来自主节点的状态更新请求，并就状态更新达成一致。</p>
<h3 id="请求处理器request-processor"><a class="markdownIt-Anchor" href="#请求处理器request-processor"></a> 请求处理器（Request Processor）</h3>
<p>由于 <code>ZooKeeper</code> 的消息层是原子的，它保证各副本的状态不会和主节点产生分歧，虽然在任一时间点有可能某些副本会比其他副本多提交一些事务。和客户端发送的请求不同，<code>ZooKeeper</code> 中的事务是幂等的。当主节点收到一个写请求时，它会先计算出系统提交了这个写请求后的系统状态，然后将其转化为一个能达到该系统状态的事务。这里之所以要先计算出将来的状态是因为当前可能存在未提交的事务。例如，当前客户端正在进行一个 <code>setData</code> 的条件更新，请求中的版本号和被修改的 <code>znode</code> 的某个未来的版本号所匹配，<code>ZooKeeper</code> 会生成一个 <code>setDataTXN</code> 事务，这个事务包含了更新后的数据，更新后的版本号，以及更新的时间戳。而如果发生了异常，例如 <code>setData</code> 期望的版本号不匹配或者要更新的 <code>znode</code> 不存在，则会生成一个 <code>errorTXN</code> 错误。</p>
<h3 id="原子广播atomic-broadcast"><a class="markdownIt-Anchor" href="#原子广播atomic-broadcast"></a> 原子广播（Atomic Broadcast）</h3>
<p>所有更新 <code>ZooKeeper</code> 状态的请求都会被转发给主节点。主节点会执行写请求然后将写请求通过 <code>Zab</code> 协议广播给所有的从节点，<code>Zab</code> 是一种原子的广播协议。当主节点就更新达成一致后，会返回结果给客户端。<code>Zab</code> 默认使用的是简单的大多数同意协议，所以只有过半数的节点存活时 <code>Zab</code> 和 <code>ZooKeeper</code> 才能正常工作（例如，由 <code>2f + 1</code> 个节点组成的 <code>ZooKeeper</code> 系统可以最多容忍 <code>f</code> 台节点异常）。</p>
<p>为了提高系统的吞吐，<code>ZooKeeper</code> 会尽量保持请求处理管道满载运行。请求管道的不同部分可能有着几千个请求。因为系统状态变更依赖于之前的状态变更，所以 <code>Zab</code> 比常规的原子广播协议提供了更强的顺序保证。具体来说，<code>Zab</code> 保证了主节点广播的状态变更被分发执行的顺序和主节点发出广播的顺序一致，同时 <code>Zab</code> 会先将之前主节点的修改先发送给新的主节点，等到这些修改都执行完成后，新的主节点才能广播自己的修改。</p>
<p>另外还有些实现细节有利于高性能。<code>ZooKeeper</code> 使用 <code>TCP</code> 协议来发送消息，所以消息的有序性天然得到了保证，这同时也简化了实现。<code>ZooKeeper</code> 使用 <code>Zab</code> 协议选择的主节点作为集群的主节点，这就使得创建事务的节点同时也能发起事务。<code>ZooKeeper</code> 使用日志来记录事务的发起，这同时也作为内存数据库的预写日志，从而避免了将消息写入到磁盘两次。</p>
<p>在正常情况下 <code>Zab</code> 协议能按序发送所有消息，且每条消息只发送一次，不过由于 <code>Zab</code> 不会持久化已发送的消息的 <code>id</code>，所以在宕机恢复时可能会重复发送消息。因为 <code>ZooKeeper</code> 的事务是原子的，所以只要消息依然能保证有序发送，重复发送就没有问题。实际上，<code>ZooKeeper</code> 会要求 <code>Zab</code> 再次发送至少上次快照开始后的所有已发送的消息。</p>
<h3 id="复制数据库replicated-database"><a class="markdownIt-Anchor" href="#复制数据库replicated-database"></a> 复制数据库（Replicated Database）</h3>
<p>每个副本在内存中都有一份 <code>ZooKeeper</code> 状态的拷贝。当 <code>ZooKeeper</code> 宕机重启后，它需要能恢复到宕机前的状态。如果重新发送所有已发送的消息来恢复状态则需要较长时间，尤其是当服务器已经运行了一段时间之后，所以 <code>ZooKeeper</code> 周期性的对系统状态建立快照，并且只重新发送快照之后的所有消息。<code>ZooKeeper</code> 的快照被称之为 <code>fuzzy snapshots</code> 因为执行快照时不会加锁；<code>ZooKeeper</code> 会对数据树进行深度优先搜索，并且能原子的读取每个 <code>znode</code> 的数据和元数据，然后将其写入到磁盘中。这种方式生成的快照有可能包含部分在生成快照期间执行的事务的结果，最终生成的快照可能不会和任一时间点的 <code>ZooKeeper</code> 状态一致。不过由于状态更新是原子的，<code>ZooKeeper</code> 可以在后续恢复阶段重新按序执行已提交的事务。</p>
<p>例如，当 <code>ZooKeeper</code> 开始执行快照时有两个节点 <code>/foo</code> 和 <code>/goo</code>，对应的节点值分别为 <code>f1</code> 和 <code>g1</code>，节点值的版本号都是1。此时，对系统状态的修改以 <code>&lt;transactionType, path, value, new-version&gt;</code> 的形式到达：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;SetDataTXN, &#x2F;foo, f2, 2&gt;</span><br><span class="line">&lt;SetDataTXN, &#x2F;goo, g2, 2&gt;</span><br><span class="line">&lt;SetDataTXN, &#x2F;foo, f3, 3&gt;</span><br></pre></td></tr></table></figure>
<p>当系统执行了这些更新后，节点 <code>/foo</code> 的值变为 <code>f3</code>，对应版本号为3，而节点 <code>/goo</code> 的值变为 <code>g2</code>，对应版本号为2。不过，执行 <code>fuzzy snapshot</code> 后的快照中的节点 <code>/foo</code> 的值可能是 <code>f3</code>，而节点 <code>/goo</code> 的值可能是 <code>g1</code>，对应版本号分别为3和1，这并不是一个有效的 <code>ZooKeeper</code> 系统状态。如果服务器宕机后恢复，系统会先读取快照然后重新发送状态更新消息，由于消息执行的顺序性，最终系统的状态和宕机前的状态保存一致。</p>
<h3 id="客户端-服务端交互client-server-interactions"><a class="markdownIt-Anchor" href="#客户端-服务端交互client-server-interactions"></a> 客户端-服务端交互（Client-Server Interactions）</h3>
<p>当 <code>ZooKeeper</code> 处理了一个写请求时，它会给所有监听了该节点的客户端发送数据更新通知，并同时删除该节点的监听（因为监听只会触发一次）。服务端会按顺序处理写请求，而且同时不会并发的处理其他写请求或者读请求。这就保证了严格的监听通知顺序。不过服务端的监听通知是由各服务器自行负责，只有和当前服务器连接的客户端才会收到通知，其他客户端对同一节点的监听由其他服务器负责。</p>
<p>读请求由当前客户端所连接的服务端直接读取内存中的数据返回。每个读请求处理时会标记上一个 <code>zxid</code>，这个 <code>zxid</code> 对应当前服务端所知道的最新的事务。这个 <code>zxid</code> 定义了读写操作之间的相对顺序。通过直接读取内存中的数据返回的方式来处理读请求，<code>ZooKeeper</code> 能保证非常好的读性能，因为这不涉及任何磁盘 <code>IO</code> 或者其他一致性协议。这个设计是满足读密集型应用对性能要求的关键点。</p>
<p>直接从本地内存读取数据的一个缺点是不保证一定能读取到最新更新的数据，即可能返回过期的数据，即使当前节点的更新已经被 <code>ZooKeeper</code> 所提交，因为只要过半数的节点已完成数据更新就可以认为本次数据已提交，而当前节点可能还没有执行更新。对于必须保证读操作能读取到最新的数据的应用，<code>ZooKeeper</code> 提供了 <code>sync</code> 接口。<code>sync</code> 原语能异步执行，并且会由主节点将所有待写入的更新应用到当前副本中。如果希望读操作能读取到最新的数据，客户端需要在执行读操作前调用 <code>sync</code> 方法。<code>ZooKeeper</code> 对客户端操作的 <code>FIFO</code> 执行顺序保证以及 <code>sync</code> 写操作的全局顺序保证使得读操作在执行读时 <code>sync</code> 发起之前的所有写操作都已经应用到了当前服务器中。在 <code>ZooKeeper</code> 的实现中，执行 <code>sync</code> 操作时不需要原子广播协议，因为使用了基于主节点的算法，只需要将 <code>sync</code> 请求放在主节点和当前节点的请求队列的末尾即可。这种方式能正确工作的前提是当前的主节点依然是主节点。如果当前主节点还有进行中的事务并提交，那么从节点就可以认为当前主节点依然是主节点。如果主节点的请求队列为空，那么主节点就会先提交一个空的事务然后再发起 <code>sync</code> 请求。这样当主节点处于低负载运行时，不需要生成额外的广播请求。在 <code>ZooKeeper</code> 的实现中，主节点会有一段过期时间，所以主节点自己就能知道什么时候不再是主节点，从而不再发起空事务。</p>
<p><code>ZooKeeper</code> 的服务器会以 <code>FIFO</code> 的顺序来处理客户端请求。响应结果中会附带上 <code>zxid</code>。即使客户端和服务端之间没有请求，在常规的心跳返回中也会附带上当前服务端所知道的最新的 <code>zxid</code>。如果客户端连接上了一台新的服务器，那么这个服务器会保证自己所知道的 <code>zxid</code> 不会比客户端的 <code>zxid</code> 旧。如果客户端发送的 <code>zxid</code> 更新，那么服务端在将自己本地的数据更新到最新前不会和客户端再建立连接。而 <code>ZooKeeper</code> 能保证客户端能连接上一台数据版本满足 <code>zxid</code> 的服务端，因为客户端连接到的服务器必然是过半数有着最新系统状态的服务器之一。这个行为对保证持久性来说至关重要。</p>
<p><code>ZooKeeper</code> 使用超时来检测客户端的 <code>session</code> 异常。如果在 <code>session timeout</code> 期间没有一台服务器收到来自客户端的请求，那么主节点就会认为发生了异常。如果客户端发送请求的频率足够高，那么就不需要发送其他消息来告诉主节点没有异常。否则，在非活跃期间客户端会发送心跳来维持连接。如果客户端和某台服务器无法发送请求或者心跳，那么客户端会和另外一台服务器建立连接。为了避免客户端的 <code>session</code> 过期，<code>ZooKeeper</code> 客户端类库会在 <code>session</code> 空闲了 <code>s/3</code> 毫秒后发送心跳，并且如果在 <code>2s/3</code> 毫秒内没有收到响应则会连接上另外一台服务器，这里的 <code>s</code> 指的是 <code>session</code> 的过期时间，以毫秒为单位。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf">ZooKeeper: Wait-free coordination for Internet-scale systems</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/zookeeper-faq.txt">ZooKeeper FAQ</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Xiaodan Mao
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://frederick-s.github.io/2022/05/19/mit-6.824-zookeeper/" title="MIT 6.824 - ZooKeeper: Wait-free coordination for Internet-scale systems">https://frederick-s.github.io/2022/05/19/mit-6.824-zookeeper/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Paper/" rel="tag"># Paper</a>
              <a href="/tags/MIT-6-824/" rel="tag"># MIT 6.824</a>
              <a href="/tags/Distributed-Systems/" rel="tag"># Distributed Systems</a>
              <a href="/tags/ZooKeeper/" rel="tag"># ZooKeeper</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/15/mit-6.824-lab2-implementation/" rel="prev" title="MIT 6.824 - Lab 2 (3): 实现">
      <i class="fa fa-chevron-left"></i> MIT 6.824 - Lab 2 (3): 实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/25/mit-6.824-chain-replication/" rel="next" title="MIT 6.824 - Chain Replication for Supporting High Throughput and Availability">
      MIT 6.824 - Chain Replication for Supporting High Throughput and Availability <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text"> 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper-%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.</span> <span class="nav-text"> ZooKeeper 服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88"><span class="nav-number">2.1.</span> <span class="nav-text"> 服务概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text"> 数据模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">2.1.2.</span> <span class="nav-text"> 会话</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-api"><span class="nav-number">2.2.</span> <span class="nav-text"> 客户端 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper-%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">2.3.</span> <span class="nav-text"> ZooKeeper 的保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E8%AF%AD%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.4.</span> <span class="nav-text"> 原语示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86configuration-management"><span class="nav-number">2.4.1.</span> <span class="nav-text"> 配置管理（Configuration Management）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rendezvous"><span class="nav-number">2.4.2.</span> <span class="nav-text"> Rendezvous</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BE%A4%E7%BB%84%E6%88%90%E5%91%98%E5%85%B3%E7%B3%BBgroup-membership"><span class="nav-number">2.4.3.</span> <span class="nav-text"> 群组成员关系（Group Membership）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%94%81simple-locks"><span class="nav-number">2.4.4.</span> <span class="nav-text"> 简单锁（Simple Locks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94%E7%9A%84%E7%AE%80%E5%8D%95%E9%94%81simple-locks-without-herd-effect"><span class="nav-number">2.4.5.</span> <span class="nav-text"> 没有羊群效应的简单锁（Simple Locks without Herd Effect）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81readwrite-locks"><span class="nav-number">2.4.6.</span> <span class="nav-text"> 读写锁（Read&#x2F;Write Locks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%B1%8F%E9%9A%9Cdouble-barrier"><span class="nav-number">2.4.7.</span> <span class="nav-text"> 双屏障（Double Barrier）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text"> ZooKeeper 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%99%A8request-processor"><span class="nav-number">3.1.</span> <span class="nav-text"> 请求处理器（Request Processor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%B9%BF%E6%92%ADatomic-broadcast"><span class="nav-number">3.2.</span> <span class="nav-text"> 原子广播（Atomic Broadcast）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BA%93replicated-database"><span class="nav-number">3.3.</span> <span class="nav-text"> 复制数据库（Replicated Database）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92client-server-interactions"><span class="nav-number">3.4.</span> <span class="nav-text"> 客户端-服务端交互（Client-Server Interactions）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text"> 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiaodan Mao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaodan Mao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
