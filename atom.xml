<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Übung macht den Meister</title>
  
  
  <link href="https://frederick-s.github.io/atom.xml" rel="self"/>
  
  <link href="https://frederick-s.github.io/"/>
  <updated>2025-02-26T16:00:00.000Z</updated>
  <id>https://frederick-s.github.io/</id>
  
  <author>
    <name>Xiaodan Mao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【读】The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, Out-of-Order Data Processing</title>
    <link href="https://frederick-s.github.io/2025/02/27/the-dataflow-model/"/>
    <id>https://frederick-s.github.io/2025/02/27/the-dataflow-model/</id>
    <published>2025-02-26T16:00:00.000Z</published>
    <updated>2025-02-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>面对日益增长的大规模无界、无序数据的处理需求，当前的技术手段存在诸多不足：</p><ul><li>以 <code>MapRecue</code> 为代表的批处理系统无法满足数据处理的及时性要求，因为需要先收集所有的数据，然后再处理</li><li>很多流式系统对于大规模处理下的容错性缺少明确的保证</li><li>能够提供大规模处理和容错性的系统又缺少表达性和正确性</li><li>很多系统也缺少 <code>exactly-once</code> 语义保证，从而影响正确性</li><li>缺少对窗口（<code>windowing</code>）计算的支持或支持有限</li><li>某些支持基于事件时间（<code>event-time</code>）的窗口计算的系统要么要求事件必须有序，要么窗口触发语义不够丰富</li><li>缺少高层次的编程模型能够直观的支持基于事件时间的会话（<code>session</code>）</li><li>虽然 <code>Lambda</code> 架构能够解决大部分的问题，但是需要同时构建和维护两套系统，增加了成本</li></ul><p>当前已有系统的主要问题在于认为数据是有界的，这个假设对当下海量且无序的数据处理的需求是不成立的；另外，需要一个简单但又强大的工具在满足上述场景的同时，又能在正确性，延迟和成本之间取得平衡；最后，需要转变由执行引擎决定系统语义的思想，不管是批处理，微批处理，还是流式处理，只要经过了合理的设计和实现，都能提供同等水平的正确性保证，而这三种执行引擎如今都广泛用于处理无界的数据。因此，在正确性保证的前提下，选择不同的执行引擎的决定因素就在于延迟和资源成本。</p><p>本文提出了一个统一的数据处理模型：</p><ul><li>对无界，无序的数据，能够根据事件本身的维度特征进行窗口聚合，并按照事件时间排序计算，并且在正确性，延迟，和成本之间灵活调优</li><li>将 <code>pipeline</code> 的实现拆解为四个维度，以提供清晰性，可组合性和灵活性：<ul><li><code>What</code>：计算的结果是什么</li><li><code>Where</code>：参与计算的事件时间</li><li><code>When</code>：数据处理时间</li><li><code>How</code>：先前的计算结果如何与后续优化关联</li></ul></li><li>将数据处理的逻辑概念与底层物理实现剥离，对于批处理，微批处理，和流式处理的选择，取决于用户对正确性，延迟，和成本的考量</li></ul><p>具体来说，本文的主要贡献在于提出了：</p><ul><li>窗口模型：支持非对齐的事件时间窗口，并提供简单的 <code>API</code> 用于创建和使用窗口</li><li>触发模型：将数据处理结果的输出时机与 <code>pipeline</code> 的运行时特征相绑定，并提供了强大和灵活的声明式 <code>API</code> 来描述触发的语义</li><li>增量式的处理模型：集成窗口模型和触发模型，支持计算的撤销和更新</li><li>可扩展的实现：既支持流式处理引擎（<code>MillWheel</code>），也支持批处理引擎（<code>FlumeJava</code>），以及对 <code>Google Cloud Dataflow</code> 的外部二次实现，并提供了运行时无关的开源 <code>SDK</code></li><li>一系列指导本文描述的模型设计的核心准则</li><li><code>Google</code> 产线环境下大规模无界，无序数据处理的真实案例探讨，正是这些真实需求驱动了本文描述的模型的开发</li></ul><h3 id="无界有界与流式批"><a class="markdownIt-Anchor" href="#无界有界与流式批"></a> 无界/有界与流式/批</h3><p>相比于流式/批，本文倾向于使用无界/有界来描述无限/有限的数据集，因为前者可能暗示使用了特定的执行引擎。实际上，无界的数据同样可以用连续运行的批处理引擎处理，而设计合理的流式处理引擎同样可以处理有界的数据。</p><h3 id="窗口"><a class="markdownIt-Anchor" href="#窗口"></a> 窗口</h3><p>窗口将一个数据集划分为有限个数的组。在处理无界数据时，窗口对于某些操作是必须的（如聚合，外连接，以时间为界的操作），而对于其他操作（如过滤，映射，内连接）则不是必须的。对于有界数据来说，窗口是可选的，不过依然在很多场景下适用（如对已经处理过的无界数据的一部分进行大批量的更新，即 <code>backfill</code>）。窗口始终是基于时间的，虽然某些系统支持基于元组的窗口，不过这依然是基于时间的窗口，其中有序的元素隐含着对应递增的逻辑时间。窗口分为对齐和非对齐，前者窗口的边界与特定的时间间隔同步，后者不同的窗口可以在不同的时间开始和结束。</p><h4 id="固定窗口"><a class="markdownIt-Anchor" href="#固定窗口"></a> 固定窗口</h4><p><img src="/images/dataflow-1.png" alt="alt" /></p><p>也称为滚动窗口（<code>tumbling window</code>），每个窗口都是固定的大小，且彼此之间没有重叠，通常都是对齐的，例如，每小时生成大小为1小时的窗口：</p><ul><li>窗口1：[12:00, 13:00)</li><li>窗口2：[13:00, 14:00)</li><li>窗口3：[14:00, 15:00)</li><li>…</li></ul><p>不过，有时候为了保证窗口对齐，会将窗口按照键以某个随机值进行偏移。</p><h4 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h4><p><img src="/images/dataflow-2.png" alt="alt" /></p><p>滑动窗口由窗口大小和滑动周期构成，例如，每分钟生成大小为1小时的窗口：</p><ul><li>窗口1：[12:00, 13:00)</li><li>窗口2：[12:01, 13:01)</li><li>窗口3：[12:02, 13:02)</li><li>…</li></ul><p>滑动周期可能会小于窗口大小，所以相邻两个窗口之间有重叠，当滑动周期等于窗口大小的时候，滑动窗口就退化成了滚动窗口。滑动窗口一般也是对齐的。</p><h4 id="会话窗口"><a class="markdownIt-Anchor" href="#会话窗口"></a> 会话窗口</h4><p><img src="/images/dataflow-3.png" alt="alt" /></p><p>会话窗口用于框住某段时间内产生的数据子集，其大小一般以超时时间来衡量，在该超时时间内发生的事件都会归于该会话窗口。会话窗口一般是非对齐的。</p><h3 id="时间"><a class="markdownIt-Anchor" href="#时间"></a> 时间</h3><p>数据处理中有两类时间：</p><ul><li>事件时间：事件实际发生的时间</li><li>处理时间：事件被系统观测到并处理的时间</li></ul><p>一般来说事件时间一旦生成后就不会改变，而处理时间则随着事件在系统中流动而不断变化。理想情况下，如果分别对事件时间和处理时间画一条线，那么这两条线是重合的。不过在实际中，由于通信延迟，调度算法，处理单个事件需要的耗时，以及 <code>pipeline</code> 的序列化等因素，事件时间与处理时间之间存在偏差（如下图所示）。本文使用类似于 <code>MillWheel</code> 的 <code>watermark</code> 来表示这种偏差，<code>watermark</code> 定义了事件时间的一个下界，表示所有事件时间小于 <code>watermark</code> 的事件都已经处理完毕。不过，这依然是个理想情况，为了容忍一定程度的事件到达系统的延迟，<code>watermark</code> 会滞后于最新的事件时间，而这个容忍时间又不可能无限长，所以实际中即使生成 <code>watermark</code> 后也依然有可能存在事件时间比 <code>watermark</code> 小的事件到达系统，这些事件称为 <code>late event</code>。</p><p><img src="/images/dataflow-4.png" alt="alt" /></p><h2 id="dataflow-模型"><a class="markdownIt-Anchor" href="#dataflow-模型"></a> Dataflow 模型</h2><h3 id="核心原语"><a class="markdownIt-Anchor" href="#核心原语"></a> 核心原语</h3><p>在批处理下，<code>Dataflow SDK</code> 提供了操作 <code>(key, value)</code> 键值对的两种方式：</p><ul><li><code>ParDo</code>：对每个输入，通过调用用户定义的方法（在 <code>Dataflow</code> 中称为 <code>DoFn</code>），返回0个或者多个输出，各输入之间无关联，天然的适用于无界数据处理</li><li><code>GroupByKey</code>：将相同键的值聚合在一起，不过对于无界数据来说，何时将相同键聚合后的数据发给下游成为了一个问题，因为无法预知数据的边界，通用的解决方法是借助窗口</li></ul><p>以下是一个 <code>ParDo</code> 的例子，对于每个输入，通过调用 <code>ExpandPrefixes</code> 方法，返回每个键的所有可能的前缀：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mtext>fix</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fit</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>ParDo(ExpandPrefixes)</mtext><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>f</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fi</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fix</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>f</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fi</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fit</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{fix}, 1), (\text{fit}, 2) \\\bigg\downarrow \quad \text{ParDo(ExpandPrefixes)} \\\bigg\downarrow \\(\text{f}, 1), (\text{fi}, 1), (\text{fix}, 1), (\text{f}, 2), (\text{fi}, 2), (\text{fit}, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fix</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fit</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">ParDo(ExpandPrefixes)</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fi</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fix</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fi</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fit</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p><p>以下是一个 <code>GroupByKey</code> 的例子，将相同键的值聚合在一起：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mtext>f</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fi</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fix</mtext><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>f</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fi</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fit</mtext><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>GroupByKey</mtext><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>f</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fi</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fix</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>fit</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{f}, 1), (\text{fi}, 1), (\text{fix}, 1), (\text{f}, 2), (\text{fi}, 2), (\text{fit}, 2) \\\bigg\downarrow \quad \text{GroupByKey} \\\bigg\downarrow \\(\text{f}, [1, 2]), (\text{fi}, [1, 2]), (\text{fix}, [1]), (\text{fit}, [2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fi</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fix</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fi</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fit</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">GroupByKey</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fi</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fix</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fit</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><h3 id="窗口-2"><a class="markdownIt-Anchor" href="#窗口-2"></a> 窗口</h3><p>支持按键聚合的系统一般会将 <code>GroupByKey</code> 以 <code>GroupByKeyAndWindow</code> 的形式实现，本文的首要贡献在于支持非对齐的窗口。具体来说：</p><ol><li><code>Dataflow</code> 模型的视角下可以将所有窗口都当做非对齐的，并交由具体实现来为对齐式的窗口场景优化</li><li>窗口计算可以拆解为两个操作：<ul><li><code>Set&lt;Window&gt; AssignWindows(T datum)</code>：将输入分配给0个或者多个窗口</li><li><code>Set&lt;Window&gt; MergeWindows(Set&lt;Window&gt; windows)</code>：聚合时将多个窗口合并为一个</li></ul></li></ol><p>为了支持基于事件时间的窗口，需要将数据传输的格式从 <code>(key, value)</code> 改为 <code>(key, value, event_time, window)</code>，<code>event_time</code> 是事件时间，<code>window</code> 默认是一个全局窗口，覆盖所有的事件，同时也适配了有界数据的场景。</p><h4 id="窗口分配"><a class="markdownIt-Anchor" href="#窗口分配"></a> 窗口分配</h4><p>如果一个输入属于多个窗口，那么窗口分配会给每个窗口创建一个输入的副本。</p><p>在下面这个例子中，键值对 <code>(k, v1)</code> 和 <code>(k, v2)</code> 分别复制到了两个窗口中。窗口的分配也不需要等到聚合时，可以在 <code>pipeline</code> 的任意执行点发生：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mtext>k</mtext><mo separator="true">,</mo><mtext>v1</mtext><mo separator="true">,</mo><mtext>12:00</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mtext>k</mtext><mo separator="true">,</mo><mtext>v2</mtext><mo separator="true">,</mo><mtext>12:01</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>AssignWindows(Sliding(2m, 1m))</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k</mtext><mo separator="true">,</mo><mtext>v1</mtext><mo separator="true">,</mo><mtext>12:00</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>11</mn><mo>:</mo><mn>59</mn><mo separator="true">,</mo><mn>12</mn><mo>:</mo><mn>01</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k</mtext><mo separator="true">,</mo><mtext>v1</mtext><mo separator="true">,</mo><mtext>12:00</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>12</mn><mo>:</mo><mn>00</mn><mo separator="true">,</mo><mn>12</mn><mo>:</mo><mn>02</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k</mtext><mo separator="true">,</mo><mtext>v2</mtext><mo separator="true">,</mo><mtext>12:01</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>12</mn><mo>:</mo><mn>00</mn><mo separator="true">,</mo><mn>12</mn><mo>:</mo><mn>02</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k</mtext><mo separator="true">,</mo><mtext>v2</mtext><mo separator="true">,</mo><mtext>12:01</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>12</mn><mo>:</mo><mn>01</mn><mo separator="true">,</mo><mn>12</mn><mo>:</mo><mn>03</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{k}, \text{v1}, \text{12:00}, [0, \infty)), (\text{k}, \text{v2}, \text{12:01}, [0, \infty)) \\\bigg\downarrow \quad \text{AssignWindows(Sliding(2m, 1m))} \\(\text{k}, \text{v1}, \text{12:00}, [11:59, 12:01)), \\(\text{k}, \text{v1}, \text{12:00}, [12:00, 12:02)), \\(\text{k}, \text{v2}, \text{12:01}, [12:00, 12:02)), \\(\text{k}, \text{v2}, \text{12:01}, [12:01, 12:03))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">12:00</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">12:01</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">AssignWindows(Sliding(2m, 1m))</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">12:00</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">12:00</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">12:01</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">12:01</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">3</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><h4 id="窗口合并"><a class="markdownIt-Anchor" href="#窗口合并"></a> 窗口合并</h4><p>窗口合并发生于 <code>GroupByKeyAndWindow</code> 操作，我们以超时时间为30分钟的会话窗口为例，假设有 <code>(k1, v1)</code>，<code>(k2, v2)</code>，<code>(k1, v3)</code>，<code>(k1, v4)</code> 四个事件，其初始默认的窗口都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, \infty]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">]</span></span></span></span>。然后，<code>AssignWindows</code> 根据每个事件到达的起始时间分配一个时长为30分钟的会话窗口，在这期间如果有相同键的事件到达，则也将其归到同一个窗口内。然后，<code>GroupByKeyAndWindow</code> 操作可以拆解为如下步骤：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v1</mtext><mo separator="true">,</mo><mtext>13:02</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mtext>v2</mtext><mo separator="true">,</mo><mtext>13:14</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v3</mtext><mo separator="true">,</mo><mtext>13:57</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v4</mtext><mo separator="true">,</mo><mtext>13:20</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>AssignWindows(Sessions(30m))</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v1</mtext><mo separator="true">,</mo><mtext>13:02</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>02</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>32</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mtext>v2</mtext><mo separator="true">,</mo><mtext>13:14</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>14</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>44</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v3</mtext><mo separator="true">,</mo><mtext>13:57</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>57</mn><mo separator="true">,</mo><mn>14</mn><mo>:</mo><mn>27</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v4</mtext><mo separator="true">,</mo><mtext>13:20</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>20</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>50</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>DropTimestamps</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v1</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>02</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>32</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mtext>v2</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>14</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>44</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v3</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>57</mn><mo separator="true">,</mo><mn>14</mn><mo>:</mo><mn>27</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>v4</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>20</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>50</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>GroupByKey</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext>v1</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>02</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>32</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>v3</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>57</mn><mo separator="true">,</mo><mn>14</mn><mo>:</mo><mn>27</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>v4</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>20</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>50</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext>v2</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>14</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>44</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>MergeWindows(Sessions(30m))</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext>v1</mtext><mo separator="true">,</mo><mrow><mtext mathvariant="bold">[13:02,</mtext><mtext> </mtext><mtext mathvariant="bold">13:50)</mtext></mrow><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>v3</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>57</mn><mo separator="true">,</mo><mn>14</mn><mo>:</mo><mn>27</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>v4</mtext><mo separator="true">,</mo><mrow><mtext mathvariant="bold">[13:02,</mtext><mtext> </mtext><mtext mathvariant="bold">13:50)</mtext></mrow><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext>v2</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>14</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>44</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>GroupAlsoByWindow</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mrow><mtext mathvariant="bold">[v1,</mtext><mtext> </mtext><mtext mathvariant="bold">v4]</mtext></mrow><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>02</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>50</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext mathvariant="bold">[v3]</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>57</mn><mo separator="true">,</mo><mn>14</mn><mo>:</mo><mn>27</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mtext mathvariant="bold">[v2]</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>14</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>44</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo fence="false">↓</mo><mspace width="1em"/><mtext>ExpandToElements</mtext><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>[v1, v4]</mtext><mo separator="true">,</mo><mtext mathvariant="bold">13:50</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>02</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>50</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k1</mtext><mo separator="true">,</mo><mtext>[v3]</mtext><mo separator="true">,</mo><mtext mathvariant="bold">14:27</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>57</mn><mo separator="true">,</mo><mn>14</mn><mo>:</mo><mn>27</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mtext>k2</mtext><mo separator="true">,</mo><mtext>[v2]</mtext><mo separator="true">,</mo><mtext mathvariant="bold">13:44</mtext><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>13</mn><mo>:</mo><mn>14</mn><mo separator="true">,</mo><mn>13</mn><mo>:</mo><mn>44</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{k1}, \text{v1}, \text{13:02}, [0, \infty)), \\(\text{k2}, \text{v2}, \text{13:14}, [0, \infty)), \\(\text{k1}, \text{v3}, \text{13:57}, [0, \infty)), \\(\text{k1}, \text{v4}, \text{13:20}, [0, \infty)), \\\bigg\downarrow \quad \text{AssignWindows(Sessions(30m))} \\(\text{k1}, \text{v1}, \text{13:02}, [13:02, 13:32)), \\(\text{k2}, \text{v2}, \text{13:14}, [13:14, 13:44)), \\(\text{k1}, \text{v3}, \text{13:57}, [13:57, 14:27)), \\(\text{k1}, \text{v4}, \text{13:20}, [13:20, 13:50)) \\\bigg\downarrow \quad \text{DropTimestamps} \\(\text{k1}, \text{v1}, [13:02, 13:32)), \\(\text{k2}, \text{v2}, [13:14, 13:44)), \\(\text{k1}, \text{v3}, [13:57, 14:27)), \\(\text{k1}, \text{v4}, [13:20, 13:50)) \\\bigg\downarrow \quad \text{GroupByKey} \\(\text{k1}, [(\text{v1}, [13:02, 13:32)), \\            (\text{v3}, [13:57, 14:27)), \\            (\text{v4}, [13:20, 13:50))]), \\(\text{k2}, [(\text{v2}, [13:14, 13:44))]) \\\bigg\downarrow \quad \text{MergeWindows(Sessions(30m))} \\(\text{k1}, [(\text{v1}, \textbf{[13:02, 13:50)}), \\            (\text{v3}, [13:57, 14:27)), \\            (\text{v4}, \textbf{[13:02, 13:50)})]), \\(\text{k2}, [(\text{v2}, [13:14, 13:44))]) \\\bigg\downarrow \quad \text{GroupAlsoByWindow} \\(\text{k1}, [(\textbf{[v1, v4]}, [13:02, 13:50)), \\            (\textbf{[v3]}, [13:57, 14:27))]), \\(\text{k2}, [(\textbf{[v2]}, [13:14, 13:44))]) \\\bigg\downarrow \quad \text{ExpandToElements} \\(\text{k1}, \text{[v1, v4]}, \textbf{13:50}, [13:02, 13:50)), \\(\text{k1}, \text{[v3]}, \textbf{14:27}, [13:57, 14:27))), \\(\text{k2}, \text{[v2]}, \textbf{13:44}, [13:14, 13:44))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:02</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:14</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v3</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:57</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v4</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:20</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">AssignWindows(Sessions(30m))</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:02</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:14</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v3</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:57</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v4</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">13:20</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">DropTimestamps</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v3</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">v4</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">GroupByKey</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">v3</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">v4</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">MergeWindows(Sessions(30m))</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord text"><span class="mord">v1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textbf">[13:02, 13:50)</span></span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">v3</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">v4</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textbf">[13:02, 13:50)</span></span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord text"><span class="mord">v2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">GroupAlsoByWindow</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord text"><span class="mord textbf">[v1, v4]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord textbf">[v3]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord text"><span class="mord textbf">[v2]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.9500199999999999em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45398em;"><span style="top:-1.6509900000000002em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>↓</span></span></span><span style="top:-2.24599em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.84199em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-2.85798em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span><span style="top:-3.45398em;"><span class="pstrut" style="height:2.601em;"></span><span class="delimsizinginner delim-size1"><span>⏐</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">ExpandToElements</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">[v1, v4]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textbf">13:50</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">[v3]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textbf">14:27</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">k2</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">[v2]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord textbf">13:44</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><ul><li><code>DropTimestamps</code>：丢弃事件的时间戳，因为这里只涉及窗口计算</li><li><code>GroupByKey</code>：按照键聚合 <code>(value, window)</code> 元组</li><li><code>MergeWindows</code>：合并每个键下 <code>(value, window)</code> 元组中的窗口，具体的合并逻辑由窗口策略决定。在上述的例子中，如果两个 <code>(value, window)</code> 元组中的窗口存在重叠，则每个元组合并后的窗口为两个窗口的并集</li><li><code>GroupAlsoByWindow</code>：对每个键下的 <code>(value, window)</code> 元组按照窗口聚合，在上述例子中，<code>v1</code> 和 <code>v4</code> 因为有相同的窗口，所以被聚合在了一起</li><li><code>ExpandToElements</code>：将每个键下的 <code>(value, window)</code> 元组展开为 <code>(key, value, event_time, window)</code> 的形式，新的 <code>event_time</code> 在上述例子中采用的是窗口的结束时间，不过实际上只要是大于窗口内最早的事件的时间戳都行。</li></ul><h4 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h4><p>现在通过 <code>Cloud Dataflow SDK</code> 的代码示例来展示如何使用窗口。下述代码将数据按照键聚合后，求所有值的加和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PCollection&lt;KV&lt;String, Integer&gt;&gt; input = IO.read(...);</span><br><span class="line">PCollection&lt;KV&lt;String, Integer&gt;&gt; output = input</span><br><span class="line">  .apply(Sum.integersPerKey());</span><br></pre></td></tr></table></figure><p>如果要支持超时时间为30分钟的会话窗口，则在求和前调用 <code>Window.into</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PCollection&lt;KV&lt;String, Integer&gt;&gt; input = IO.read(...);</span><br><span class="line">PCollection&lt;KV&lt;String, Integer&gt;&gt; output = input</span><br><span class="line">  .apply(Window.into(Sessions.withGapDuration(</span><br><span class="line">    Duration.standardMinutes(<span class="number">30</span>))))</span><br><span class="line">  .apply(Sum.integersPerKey());</span><br></pre></td></tr></table></figure><h3 id="触发器和增量处理"><a class="markdownIt-Anchor" href="#触发器和增量处理"></a> 触发器和增量处理</h3><p>目前为止，还遗留两个问题：</p><ul><li>需要支持基于元组和处理时间的窗口，不然会和当前已有的系统不兼容</li><li>需要知道窗口中的数据计算结果何时可以下发到下游</li></ul><p>本文认为借助 <code>watermark</code> 来解决第二个问题是不够的，因为 <code>watermark</code> 不能百分百确保所有数据都已经到达，真实场景中总会有晚到的数据。<code>Lambda</code> 架构则提供了一个思路：流式引擎部分提供低延迟的计算，不过其结果是近似值，而批处理引擎则提供最终一致性正确的结果。不过，如何将两者合并到一个 <code>pipeline</code> 中？</p><p>本文提出了触发器（<code>trigger</code>）的概念，和窗口的关系为：</p><ul><li>窗口：根据事件时间决定如何对事件分组</li><li>触发器：决定何时（处理时间）告知窗口计算的数据结果可以下发到下游</li></ul><p><code>Google</code> 实现的系统内置了几类触发器的实现用于在多种场合触发：</p><ul><li>当所有的数据已被系统接收时（预估，非精确，如 <code>watermark</code>）</li><li>处理时间线上的某个时间点</li><li>响应数据到达（如数量，大小，<code>data punctuations</code>，模式匹配等满足了一定的条件）</li></ul><p>另外，不同的触发器之间还可以进行逻辑组合，例如使用 <code>and</code>，<code>or</code>，循环，序列等等。</p><p>引入触发器后，同一个窗口的计算结果就有可能被多次下发，系统也提供了三种处理模式：</p><ul><li>丢弃（<code>Discarding</code>）：一旦窗口被触发，其内容下发后即被丢弃，后续触发和之前的触发没有任何关系。如果多次窗口触发的结果是幂等的，则可以采用该模式</li><li>累加（<code>Accumulating</code>）：窗口被触发后，其计算结果会持久化，后续触发结果会作为历史结果的修正。适合于数据消费方收到新的窗口数据，直接替换旧数据的场景。例如某个窗口计算是求窗口中所有数据的最大值，第一次触发时下发目前的最大值，后续有数据再次到达时根据持久化的历史值，直接和当前值比较就可以得到最新的最大值</li><li>累加和撤销（<code>Accumulating and Retracting</code>）：在 <code>Accumulating</code> 的基础上，触发的窗口计算结果同样会先持久化，如果后续有新的触发，则会下发两个值，一个是用于告知下游系统撤销上次的值，另一个是最新的窗口计算结果。不过，这也需要下游系统具有响应数据撤销事件的能力</li></ul><h2 id="实现和设计"><a class="markdownIt-Anchor" href="#实现和设计"></a> 实现和设计</h2><h3 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h3><p><code>Dataflow</code> 模型的一些设计原则：</p><ul><li>永远不要依赖任何完整性的概念</li><li>要有足够好的灵活性，既可以适应已知的各种使用场景，又能支持未来可能的扩展</li><li>在预想的执行引擎中要添加有价值的东西，而不仅仅是因为合理</li><li>鼓励清晰的实现</li><li>支持在数据产生的上下文中进行强大的数据分析</li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43864.pdf">The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, Out-of-Order Data Processing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;面对日益增长的大规模无界、无序数据的处理需求，当前的技术手段存在诸多不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 &lt;code&gt;MapRecue&lt;/cod</summary>
      
    
    
    
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>【读】RocksDB: Evolution of Development Priorities in a Key-value Store Serving Large-scale Applications</title>
    <link href="https://frederick-s.github.io/2025/02/17/rocksdb/"/>
    <id>https://frederick-s.github.io/2025/02/17/rocksdb/</id>
    <published>2025-02-16T16:00:00.000Z</published>
    <updated>2025-02-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <code>Facebook</code> 对 <code>RocksDB</code> 8年开发历程的回顾，重点讨论了为支持大规模分布式系统所做的开发优先级取舍与演进，以及在生产环境中运行大规模应用的经验。</p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>RocksDB</code> 是 <code>Facebook</code> 在2012年创建的高性能 <code>KV</code> 持久存储引擎，代码衍生自 <code>Google</code> 的 <code>LevelDB</code>。它针对 <code>SSD</code> 的某些特性进行了优化，目标是服务于大型（分布式）应用，在使用上则以类库的方式和上层应用集成。每个 <code>RocksDB</code> 实例是个单机版程序，本身不提供跨主机间的操作，例如副本管理和负载均衡，同时也不提供高阶 <code>API</code>，例如不支持 <code>checkpoint</code>，这些都留给上层应用自行实现。</p><p><code>RocksDB</code> 及其高度可定制的组件设计使其能够从容应对不同的业务需求和工作负载。除了作为数据库系统的存储引擎外，<code>RocksDB</code> 还被用于以下几种不同类型的服务：</p><ul><li>流式处理：典型代表如 <code>Flink</code> 借助 <code>RocksDB</code> 保存 <code>checkpoint</code> 的状态数据</li><li>日志/队列服务：依托于 <code>RocksDB</code> 可定制化的合并策略，这些服务能够以不亚于追加写单个文件的效率实现高吞吐的写入，同时有着较低的写放大，以及享受内置索引带来的便利</li><li>索引服务：<code>RocksDB</code> 的 <code>bulk loading</code> 特性能够为索引服务提供大规模加载离线数据的能力，同时也有着高效的查询性能</li><li>基于 <code>SSD</code> 的二级缓存：因为 <code>RocksDB</code> 针对 <code>SSD</code> 进行了优化，所以某些内存式的缓存服务会借助 <code>RocksDB</code> 在内存不够时将部分数据置换到 <code>SSD</code>。这些服务往往要求存储引擎有着足够高的写入速度和优秀的点查询性能</li></ul><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p><code>RocksDB</code> 的设计极大的受到了 <code>SSD</code> 特性的影响，<code>SSD</code> 不对称的读写性能和有限的耐用性给 <code>RocksDB</code> 的数据结构设计和系统架构带来了机遇和挑战。</p><h3 id="基于-ssd-的嵌入式存储"><a class="markdownIt-Anchor" href="#基于-ssd-的嵌入式存储"></a> 基于 SSD 的嵌入式存储</h3><p>相比于机械硬盘，<code>SSD</code> 读写的 <code>IOPS</code> 可以达到十万至百万，读写速度可以达到几百至几千 <code>MB/s</code>。一方面，这给如何设计软件从而能充分利用 <code>SSD</code> 的性能带来了挑战；另一方面，受限于 <code>SSD</code> 有限的擦除次数，同时也需要考虑如何设计合理的数据结构，避免提前耗尽 <code>SSD</code> 的寿命。</p><p>正因为 <code>SSD</code> 有着出色的性能，在大多数情况下，应用的性能瓶颈也从设备 <code>I/O</code> 转向了网络；应用架构设计时也更倾向于将数据存储在本地 <code>SSD</code> 而不是远程存储服务，因此，能够内嵌在应用中的本地 <code>KV</code> 存储引擎的需求就日渐上涨。</p><p>在这个背景下，<code>Facebook</code> 实现了 <code>RocksDB</code>，其中 <code>LSM</code> 树扮演了重大的角色。</p><h3 id="rocksdb-的架构和-lsm-树的使用"><a class="markdownIt-Anchor" href="#rocksdb-的架构和-lsm-树的使用"></a> RocksDB 的架构和 LSM 树的使用</h3><p><code>RocksDB</code> 使用 <code>LSM</code> 树作为主要的数据结构来保存数据并支持以下核心的操作。</p><h4 id="写"><a class="markdownIt-Anchor" href="#写"></a> 写</h4><p>写入时会先将数据写入到名为 <code>MemTable</code> 的内存写缓冲中，同时也会在磁盘上记录 <code>Write Aghead Log (WAL)</code>。<code>MemTable</code> 由跳表（<code>skiplist</code>）实现，插入和查询的时间复杂度都是 <code>O(logn)</code>。<code>WAL</code> 可按需开启，用于 <code>RocksDB</code> 从崩溃后恢复数据。当 <code>MemTable</code> 的大小达到所配置的阈值时：</p><ol><li>当前接受写入的 <code>MemTable</code> 和 <code>WAL</code> 变为只读</li><li>后续新的写入转到新创建的 <code>MemTable</code> 和 <code>WAL</code></li><li>系统会将变为只读的 <code>MemTable</code> 和 <code>WAL</code> 的内容落盘到 <code>Sorted String Table (SSTable)</code> 内</li><li>已落盘的 <code>MemTable</code> 和 <code>WAL</code> 则可以丢弃</li></ol><p><code>SSTable</code> 中的数据按序存储，并以等大小的块（<code>block</code>）组织。<code>SSTable</code> 生成后同样只能只读，同时，其内部会维护一个索引块，索引块中会给每个数据块维护一条索引，从而能借助二分查找快速搜索。</p><h4 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h4><p><img src="/images/rocksdb-1.png" alt="alt" /></p><p>如上图所示，一个 <code>LSM</code> 树分为多层。最新的 <code>SSTable</code> 由 <code>MemTable</code> 刷盘生成，并放置在 <code>Level-0</code>。其他层的 <code>SSTable</code> 则统一由合并程序维护。当第 <code>L</code> 层的 <code>SSTable</code> 大小触及了配置值，合并程序会选择该层的部分 <code>SSTable</code>，并将其和第 <code>L + 1</code> 层内键的范围存在重合的 <code>SSTable</code> 进行合并，从而在第 <code>L + 1</code> 层生成一个新的 <code>SSTable</code>。通过这个操作，<code>RocksDB</code> 就可以将已删除和过时的数据清除，同时新生成的 <code>SSTable</code> 也进行了瘦身，节省了磁盘空间，最终写入的数据会逐渐从 <code>Level-0</code> 迁移到最后一层。整个合并过程的 <code>I/O</code> 效率也比较高，一方面不同层的合并可以并行执行，另一方面 <code>I/O</code> 操作只涉及整个 <code>SSTable</code> 文件的批量读和写。</p><p><code>MemTable</code> 和 <code>Level-0</code> 层的 <code>SSTable</code> 键的范围可能会存在重合，而 <code>Level-1</code> 及其之后的每一层内，<code>RocksDB</code> 会确保每个 <code>SSTable</code> 之间键的范围不会重合（但是不同层之间的 <code>SSTable</code> 键的范围是有可能重合的）。</p><p><code>RocksDB</code> 支持不同类型的合并策略：</p><ul><li><code>Leveled Compaction</code>：借鉴自 <code>LevelDB</code> 并加以改进。每一层可容纳的文件大小呈指数级放大。系统会积极的触发合并以确保每层的文件大小不会超过指定阈值</li><li><code>Tiered Compaction</code>：在 <code>RocksDB</code> 中也被称为 <code>Universal Compactioin</code>，与 <code>Apache Cassandra</code> 或 <code>HBase</code> 采取的合并策略类似。当 <code>Level-0</code> 层文件的个数或者非 <code>Level-0</code> 层的个数超过指定的阈值时，又或者整个数据库的大小和最深层文件大小之比超过指定的阈值时，就会触发合并多个 <code>SSTable</code>。有别于 <code>Leveled Compaction</code>，<code>Tiered Compaction</code> 是惰性合并，实际的合并会推迟到读性能或者空间效率发生衰减时进行，从而能够一次性合并更多的数据</li><li><code>FIFO Compaction</code>：当数据库大小触及到指定阈值时，丢弃最老的 <code>SSTable</code>，且只进行轻量级的合并。适合于基于内存的缓存应用</li></ul><p><code>RocksDB</code> 的读写性能在不同的合并策略下有着不同的表现，应用开发者需要结合自身服务的工作负载来选择合适的合并策略。</p><h4 id="读"><a class="markdownIt-Anchor" href="#读"></a> 读</h4><p>读取时，<code>RocksDB</code> 首先在所有的 <code>MemTable</code> 中查找，如果没有找到则继续在位于 <code>Level-0</code> 层的所有 <code>SSTable</code> 中查找，如果还没有找到，则继续向下一层中键的范围包含要查找的键的 <code>SSTable</code> 中查找，所有的查找都借助了二分搜索。另外还有两项辅助查找的优化：</p><ol><li>频繁被访问的 <code>SSTable</code> 块会在内存中缓存从而减少文件 <code>I/O</code>，以及解压缩的开销</li><li>布隆过滤器用于快速排除一定不包含要查找的键的 <code>SSTable</code></li></ol><h4 id="column-family"><a class="markdownIt-Anchor" href="#column-family"></a> Column Family</h4><p><code>RocksDB</code> 在2014年引入了 <code>column family</code> 功能，不同的 <code>column family</code> 下可以包含相同的键，每个 <code>column family</code> 有独立的 <code>MemTable</code> 和 <code>SStable</code>，但是共享 <code>WAL</code>。其优势在于：</p><ol><li>每个 <code>column family</code> 可独立配置，如合并，压缩，<code>merge operators</code> 以及 <code>compaction filters</code></li><li>共享的 <code>WAL</code> 能够原子性的记录多个 <code>column family</code> 的更新</li><li><code>column family</code> 可动态高效的删除和创建</li></ol><h2 id="资源优化目标的演进"><a class="markdownIt-Anchor" href="#资源优化目标的演进"></a> 资源优化目标的演进</h2><h3 id="写放大"><a class="markdownIt-Anchor" href="#写放大"></a> 写放大</h3><p><code>RocksDB</code> 最初的资源优化目标在于减少 <code>SSD</code> 的擦除周期以及写放大，写放大包含两方面：</p><ol><li><code>SSD</code> 本身的写放大：<code>SSD</code> 不能直接覆盖已有的数据，需要先将其擦除，再写入，写入的粒度为 <code>page</code>，但是擦除的粒度是 <code>block</code>，一个 <code>block</code> 包含多个 <code>page</code>；同时 <code>SSD</code> 的垃圾回收也会造成数据移动和擦除；最后 <code>SSD</code> 的 <code>Wear Leveling</code> 特性会保证各个 <code>memory cell</code> 均衡的写入，也引入了数据移动</li><li>数据库软件带来的写放大</li></ol><p>在这两个因素下有时候写放大能达到100倍。</p><p><code>Leveled Compaction</code> 的写放大倍数基本在10到30，在大多数情况能够数倍优于 <code>B</code> 树的实现。更进一步，<code>Tiered Compaction</code> 能将写放大倍数降至4到10，不过缺点是读性能会有一定的下降。一般来说，当应用的写负载较高时，可以配合写放大较低的合并策略，而当写负载不高时，则可以采用更激进的合并策略，从而有更好的空间效率和读性能。</p><h3 id="空间放大"><a class="markdownIt-Anchor" href="#空间放大"></a> 空间放大</h3><p>经过了多年的开发后，<code>RocksDB</code> 团队认为对于大多数应用来说，空间使用率远比写放大重要，因为这些场景下还没有触及 <code>SSD</code> 本身的限制，不恰当的比喻来说就是：</p><blockquote><p>以大多数应用程序的稳定性来说，还远没有到比拼不同的操作系统稳定性的地步。</p></blockquote><p>而实际上，应用本身也没有充分利用 <code>SSD</code> 提供的读写吞吐，因此这一阶段的优化重心就转移到了磁盘空间上。</p><p>由于 <code>LSM</code> 树无碎片的数据组织方式，天然的避免了由于数据碎片带来的磁盘空间浪费。另一方面，<code>RocksDB</code> 也引入了新的合并策略 <code>Dynamic Leveled Compaction</code>，其中 <code>LSM</code> 树每一层的大小上限会动态的根据最深层文件的大小调整，而不是固定值。这么做的原因是为了减少 <code>LSM</code> 树中无效的数据（已删除和已被覆盖），而和最深层文件大小的比值则可作为有多少无效数据的度量指标。最终的结果也表明相比于 <code>Leveled Compaction</code>，<code>Dynamic Leveled Compaction</code> 有着更稳定的空间效率。</p><h3 id="cpu-利用率"><a class="markdownIt-Anchor" href="#cpu-利用率"></a> CPU 利用率</h3><p>随着 <code>SSD</code> 的发展，一种潜在的担忧是应用程序已不能完全充分利用 <code>SSD</code> 的潜能。因此，系统的瓶颈也从设备 <code>I/O</code> 转移到了 <code>CPU</code>。不过，<code>RocksDB</code> 的开发人员不这么看，因为：</p><ol><li>只有少部分的应用受限于 <code>SSD</code> 的 <code>IOPS</code>，大部分应用受限于磁盘空间</li><li>一个高端 <code>CPU</code> 足够服务于一个高端 <code>SSD</code>。在 <code>Facebook</code> 的生产环境中还没有遇到 <code>RocksDB</code> 不能充分利用 <code>SSD</code> 能力的情况。当然，如果一个 <code>CPU</code> 配备多个 <code>SSD</code> 还是有可能会有 <code>CPU</code> 瓶颈的，不过这属于系统配置层面的资源不均衡问题。另一方面，写密集型的应用也有可能存在 <code>CPU</code> 瓶颈的问题，不过这可以通过使用更轻量级的合并策略解决。而在这之外的场景，其工作负载则可能不适合使用 <code>SSD</code>，因为有可能提前让 <code>SSD</code> 的寿命完结</li></ol><p>不过，优化 <code>CPU</code> 利用率也不等于说是无用功，因为空间放大的优化余地已经不多了。优化了 <code>CPU</code> 也等同于省钱，毕竟 <code>CPU</code> 和内存的价格也在节节攀升。一些针对 <code>RocksDB</code> 的 <code>CPU</code> 优化的尝试包括前缀布隆过滤器，在查找索引前先用布隆过滤器判断，以及其他的一些布隆过滤器优化。</p><h3 id="适配新技术"><a class="markdownIt-Anchor" href="#适配新技术"></a> 适配新技术</h3><p>一些 <code>SSD</code> 的新技术例如 <code>open-channel SSDs</code>，<code>multi-stream SSDs</code>，<code>ZNS</code> 能让 <code>SSD</code> 有着更低的查询延迟以及更少的擦除周期损耗。不过，如前面所述，<code>RocksDB</code> 的开发团队认为大部分应用的瓶颈在于磁盘空间，适配这些新技术反而会给 <code>RocksDB</code> 的一致性体验带来挑战，所以这项的优先级不高。</p><p><code>In-storage computing</code> 可能会给应用带来巨大的提升，不过 <code>RocksDB</code> 的开发团队目前还不确定 <code>RocksDB</code> 能从这项技术中受益多少，而且对 <code>API</code> 的改动可能也比较大。</p><p><code>Disaggregated (remote) storage</code> 则更具吸引力，并且也是当前的一个优化重点。前文的优化背景都是应用直接访问本地 <code>SSD</code>，不过，如今更快的网络带宽使得远程访问 <code>SSD</code> 成为了可能，因此，如何优化 <code>RocksDB</code> 使其更好的适配远程 <code>SSD</code> 也变得有意义。在远程存储模式下，<code>CPU</code> 和 <code>SSD</code> 资源可以同时做到充分利用以及独立扩展，相反本地 <code>SSD</code> 的模式则较难实现。目前 <code>RocksDB</code> 的开发团队正在优化远程模式下的 <code>I/O</code> 延迟。</p><p>最后，<code>non-volatile memory (NVM)</code> （它相比于 <code>SSD</code> 有着更高的 <code>IO</code> 读写吞吐）这项技术也在考量中：</p><ol><li>将 <code>NVM</code> 作为 <code>DRAM</code> 的扩展<ol><li>如何实现核心数据结构（<code>block cache</code> 还是 <code>MemTable</code>）从而结合 <code>NVM</code> 和 <code>DRAM</code> 一起使用</li><li>会引入哪些额外的开销</li></ol></li><li>将 <code>NVM</code> 作为数据库的主要存储：不过实践表明 <code>RocksDB</code> 的瓶颈主要在于磁盘空间或者 <code>CPU</code>，而不是 <code>I/O</code></li><li>用 <code>NVM</code> 保存 <code>WAL</code>：其成本是否值得有待考虑，毕竟 <code>WAL</code> 中的数据量不大，并且会刷盘到 <code>SSD</code></li></ol><h3 id="再次审视-rocksdb-使用-lsm-树的合理性"><a class="markdownIt-Anchor" href="#再次审视-rocksdb-使用-lsm-树的合理性"></a> 再次审视 RocksDB 使用 LSM 树的合理性</h3><p><code>LSM</code> 树依然是最适合的，因为 <code>SSD</code> 还没有到白菜价的地步，对于大多数应用来说，其有限的寿命依然是无法忽略的因素。而另一方面，<code>RocksDB</code> 的开发团队也发现某些写密集型的应用会写大量的大对象，如果能分别存储键值对则能减少 <code>SSD</code> 的写入，其功能实现为 <code>BlobDB</code>。</p><h2 id="运行大规模系统的经验总结"><a class="markdownIt-Anchor" href="#运行大规模系统的经验总结"></a> 运行大规模系统的经验总结</h2><h3 id="资源管理"><a class="markdownIt-Anchor" href="#资源管理"></a> 资源管理</h3><p>大规模分布式数据服务往往会将数据以 <code>shard</code> 的粒度分区到多个节点上，一个节点可能会持有几十上百个 <code>shard</code>。不过 <code>shard</code> 的大小有限，因为 <code>shard</code> 是负载均衡和副本的最小单位，需要在各节点之间进行拷贝。在 <code>Facebook</code> 的环境内，一个 <code>shard</code> 由一个 <code>RocksDB</code> 实例提供服务，因此一个节点会运行很多 <code>RocksDB</code> 实例，它们可能会共享一个地址空间，也有可能会独享。</p><p>在上述背景下，就需要考虑如何进行资源管理，包括：</p><ol><li>分配给 <code>write buffer</code>，<code>MemTable</code>，<code>block cache</code> 的内存</li><li>合并程序占用的 <code>I/O</code> 带宽</li><li>合并程序线程数</li><li>磁盘使用量</li><li>文件删除速率</li></ol><p>资源管理包括两个维度，全局（分配给每个节点的资源）和局部（分配给每个 <code>RocksDB</code> 实例的资源）。对后者来说，<code>RocksDB</code> 允许应用程序创建 <code>resource controller</code> （以 <code>C++</code> 对象实现并传递给多个 <code>RocksDB</code> 实例）来对上述提到的资源进行分配。例如，一个实现了对合并程序占用的 <code>I/O</code> 带宽限流的 <code>C++</code> 对象可以传递给多个 <code>RocksDB</code> 实例，从而保证任一时刻所有 <code>RocksDB</code> 实例的合并程序占用的 <code>I/O</code> 带宽之和不会超过指定值。另外，资源管理需要能够支持按优先级分配，使得最迫切需要资源的实例能够优先获取资源。</p><p>另一个在一个进程内运行多个 <code>RocksDB</code> 实例的经验总结是将各实例中执行相似任务的线程统一以一个线程池进行管理，而不是每个实例各自维护线程池。这些线程执行的往往是后台任务，统一了线程池也变相的限制了后台任务执行时占用的 <code>I/O</code>，使得资源使用更具预测性。独立维护线程池的情况下有可能会有瞬时的 <code>CPU</code> 或者 <code>I/O</code> 毛刺，造成服务不稳定。不过，有得则有失，共享线程池的缺点就在于某些实例有可能无法及时的获取线程，从而阻塞后台任务，例如无法及时执行 <code>SSTable</code> 的合并，甚至造成写停顿（<code>write stall</code>）。</p><p>相比而言，当不同的 <code>RocksDB</code> 实例运行在多个进程时，全局的资源管理则更具有挑战性，毕竟各进程之间没有信息交互。文中提出了两种策略：</p><ol><li>为每个 <code>RocksDB</code> 实例配置较为保守的资源额度，缺点就是全局资源利用率不一定最优</li><li>各进程间交换资源使用的情况，从而动态调整资源配比</li></ol><h3 id="支持副本和备份"><a class="markdownIt-Anchor" href="#支持副本和备份"></a> 支持副本和备份</h3><p><code>RocksDB</code> 本身不提供开箱即用的副本和备份的支持，需要应用自行实现，不过 <code>RocksDB</code> 为实现这两个功能提供了必要的支持。</p><h4 id="副本"><a class="markdownIt-Anchor" href="#副本"></a> 副本</h4><p>从一个节点复制出一个全新的副本节点有两种方式：</p><ol><li>逻辑复制（<code>logical copying</code>）：遍历源节点的所有键值对，然后写入到目标节点。在源节点端，借助 <code>RocksDB</code> 的快照功能保证了数据的读一致性。同时，<code>RocksDB</code> 支持 <code>scan</code> 操作从而在数据复制时减少对在线查询的影响。在目标节点端，<code>RocksDB</code> 提供了 <code>bulk loading</code> 的功能来批量加载数据</li><li>物理复制（<code>physical copying</code>）：直接复制 <code>SSTable</code> 和其他辅助文件到目标节点。<code>RocksDB</code> 在复制时会确保没有文件被修改或删除</li></ol><h4 id="备份"><a class="markdownIt-Anchor" href="#备份"></a> 备份</h4><p>备份对于数据库来说至关重要，和副本复制一样，备份的实现同样有逻辑备份和物理备份两种。副本和备份的其中一个区别在于上层应用经常会需要同时管理多个备份。<code>RocksDB</code> 也内置了一个备份引擎针对简易的备份场景。</p><h4 id="更新副本面临的挑战"><a class="markdownIt-Anchor" href="#更新副本面临的挑战"></a> 更新副本面临的挑战</h4><p>在多副本场景下，如何将主节点的更新以一致的顺序同步到各个副本是一个挑战。直白的做法是依次按序向各个副本写入，当然缺点就是性能很差，无法利用多线程。另外，当某个副本停止同步很久之后，需要有相应的机制能让其快速同步至最新的状态。</p><p>而无序写的问题在于读取时有可能数据不一致，一种解决方法是引入快照读，客户端读取时指定序列号，<code>RocksDB</code> 会返回执行快照时对应时间点的数据，而不会受当前正在进行中的写入的影响。</p><h3 id="wal-处理"><a class="markdownIt-Anchor" href="#wal-处理"></a> WAL 处理</h3><p>传统的数据库一般要求每次写入前先写 <code>write-ahead-log (WAL)</code> 来保证数据的持久性。相反，大型分布式存储系统一般使用多副本来提升性能和可用性，例如，如果某个副本的数据损坏或者无法访问，那么系统可以基于其他完好的副本重新构建损坏的副本。对于这些系统来说，<code>WAL</code> 就不是那么重要。另外，分布式系统一般也有自己的一致性协议日志（如 <code>Paxos</code> 协议），这种情况下 <code>WAL</code> 就可以不需要了。</p><p>因此，<code>RocksDB</code> 需要能够针对不同的场景灵活配置 <code>WAL</code>，<code>RocksDB</code> 提供了三种选项：</p><ol><li>同步刷盘写 <code>WAL</code></li><li>先将 <code>WAL</code> 写入到缓冲区，然后定期由后台低优先级线程刷盘</li><li>无 <code>WAL</code></li></ol><h3 id="数据格式兼容性"><a class="markdownIt-Anchor" href="#数据格式兼容性"></a> 数据格式兼容性</h3><p>大型分布式应用往往运行在诸多节点上，并且最好不发生服务中断。因此，软件更新往往是逐台（或者小批量同时）发布，出现问题时再回滚。因此，<code>RocksDB</code> 需要能够保证存储在磁盘上的数据能够后向和前向兼容。另外，出于副本构建或者负载均衡的需要，系统会在各节点之间复制数据，因此整个集群可能运行着多个版本格式的数据。</p><p>对于后向兼容来说，<code>RocksDB</code> 需要能够识别之前的所有数据格式，这无疑增加了实现了维护的复杂度。对于前向兼容来说，<code>RocksDB</code> 需要能识别新的数据格式，并且至少要支持一年的前向兼容，这方面的技术手段借助于 <code>Protocol Buffer</code> 或者 <code>Thrift</code>。对于配置项的兼容性来说，<code>RocksDB</code> 需要能够识别未知的配置，并尽最大可能尝试猜测配置的含义或者忽视。</p><h2 id="错误处理的经验总结"><a class="markdownIt-Anchor" href="#错误处理的经验总结"></a> 错误处理的经验总结</h2><p><code>RocksDB</code> 的开发团队通过产线的实践总结了三条关于错误处理的经验：</p><ol><li>数据损坏越早监测到越好，从而最低程度的避免数据不可用或丢失，同时也能精确定位数据损坏的源头。<code>RocksDB</code> 通过在系统各层级计算数据的校验和并在数据传输时验证校验和来识别数据是否损坏</li><li>完整性保护必须覆盖整个系统，从而避免由于静默的硬件数据损坏传递给 <code>RocksDB</code> 客户端或者其他副本。仅仅在数据未使用或者传输时检测是不够的，因为数据损坏有可能由异常的软件，异常的 <code>CPU</code> 或者其他异常的硬件引入。不过，即使基础设施一直扫描系统中是否有异常的硬件，某些硬件异常也不一定能够被发现</li><li>错误需要能够区别对待。<code>RocksDB</code> 的开发团队最开始将所有非 <code>EINTR</code> （系统调用中断）类型的文件系统错误统一处理。如果错误发生在读取操作，那么 <code>RocksDB</code> 直接将错误传递给客户端。如果错误发生在写操作，那么 <code>RocksDB</code> 认为这是一个不可恢复的错误，然后永久中断所有的写入；<code>RocksDB</code> 需要重启才能恢复写入，并且可能还需要额外的运维操作。为了减少这种粗暴的重启，<code>RocksDB</code> 的开发团队开始对错误按照严重性分门别类，并且只有在遇到确实是不可恢复的错误时才中断操作</li></ol><h3 id="静默损坏的频率"><a class="markdownIt-Anchor" href="#静默损坏的频率"></a> 静默损坏的频率</h3><p>在真实的 <code>RocksDB</code> 使用场景中，多久会发生一次静默的数据损坏？这很难直接给出答案。出于成本的考虑，应用所使用的存储设备一般不提供端到端的数据保护，相反，应用依赖 <code>RocksDB</code> 提供的块校验和来检测数据损坏。另一方面，基于 <code>RocksDB</code> 的应用本身也会运行数据校验程序来对比副本间的数据，不过这个过程识别出的数据损坏既有可能是 <code>RocksDB</code> 引入的，也有可能是应用本身引入的。</p><p>通过比较 <code>MyRocks</code> 中主键和二级索引的使用情况，<code>RocksDB</code> 的开发团队推断出每 <code>100 PB</code> 数据在每三个月内会发生一次由 <code>RocksDB</code> 本身引起的数据损坏。其中40%的情况下，这些数据损坏已经扩散到了其他副本上。</p><p>另一方面，数据损坏也有可能发生在数据传输中，这经常是由于软件 <code>bug</code> 导致。例如，底层存储系统在处理网络异常时的一个 <code>bug</code> 会导致一段时间后，每传输 <code>1 PB</code> 数据大约有17个校验和不匹配。</p><h3 id="多级保护"><a class="markdownIt-Anchor" href="#多级保护"></a> 多级保护</h3><p>数据损坏需要尽早识别，以免扩大影响范围，并尽可能的减少服务中断时间和数据丢失。大多数的 <code>RocksDB</code> 应用会持有一份数据的多个副本，并定期检测副本的校验和来识别损坏的副本，一旦发现损坏的副本，应用就可以丢弃该副本并替换为正确的备份。不过，这种做法的前提是系统中始终持有有效数据的副本。</p><p>如下图所示，<code>RocksDB</code> 启用了多级校验和保护，从而能尽早的发现数据损坏。</p><p><img src="/images/rocksdb-2.png" alt="alt" /></p><h4 id="块完整性"><a class="markdownIt-Anchor" href="#块完整性"></a> 块完整性</h4><p>块校验和继承自 <code>LevelDB</code>，是为了避免文件系统层的数据损坏传递到客户端。这里的块不仅仅指 <code>SSTable</code> 块，也包括了 <code>WAL</code> 段（<code>fragment</code>），在块生成时会同时生成校验和。每当一个块被读取时，<code>RocksDB</code> 都会检验它的校验和。</p><h4 id="sstable-完整性"><a class="markdownIt-Anchor" href="#sstable-完整性"></a> SSTable 完整性</h4><p>每个 <code>SSTable</code> 文件也保存了一个校验和，该功能在2020年引入，是为了避免 <code>SSTable</code> 在传输时造成损坏，校验和会在生成 <code>SSTable</code> 时同时生成，并保存在 <code>SSTable</code> 的元数据中，<code>RocksDB</code> 会在传输 <code>SSTable</code> 时检验校验和。不过，这篇文章发表时，还没有 <code>WAL</code> 文件级别的校验和。</p><h4 id="handoff-完整性"><a class="markdownIt-Anchor" href="#handoff-完整性"></a> Handoff 完整性</h4><p>在往文件系统写入数据前，会同时生成一个 <code>handoff</code> 校验和，然后将数据和校验和一起传递给下一层，由下一层进行数据校验。<code>RocksDB</code> 的开发团队期望用这种方式对 <code>WAL</code> 进行校验，因为 <code>WAL</code> 都是增量的追加写，不过可惜的是，很少有本地文件系统支持这种校验方式。不过，当 <code>RocksDB</code> 结合远程存储使用时，可以修改 <code>write</code> 接口使其接收额外的校验和，然后将其添加到存储服务内部的 <code>ECC</code> （<code>Error Correction Code</code>，用于校验数据完整性）中，最后远程存储服务在收到写请求时就可以进行校验。</p><h4 id="端到端的键值对完整性保护"><a class="markdownIt-Anchor" href="#端到端的键值对完整性保护"></a> 端到端的键值对完整性保护</h4><p>上述的完整性校验依然存在不足，其中一个不足在于文件系统之外的数据没有完整性保护，例如 <code>MemTable</code> 和 <code>block cache</code> 中的数据。因此，在这一层的数据损坏就无法被监测并有可能最终扩散到上层应用。而如果此时发生了 <code>MemTable</code> 的刷盘或者合并操作，则会将损坏的数据永久的持久化到磁盘上。</p><p>因此，<code>RocksDB</code> 的开发团队的解决方案是实现每个键值对级别的校验和，从而在文件系统层之外发现数据损坏。当某个键值对被复制时，其校验和也会随之复制，不过在写入到文件时这部分校验和会忽略，因为在文件系统级别已经有其他校验和机制来保证完整性了，从而减少数据冗余。</p><h4 id="基于严重性的错误处理"><a class="markdownIt-Anchor" href="#基于严重性的错误处理"></a> 基于严重性的错误处理</h4><p>大部分情况下，<code>RocksDB</code> 遇到的故障都是底层存储系统返回的错误。这些错误可能来自于各种各样的问题，从比较严重的问题例如文件系统变成了只读，到短暂的问题例如磁盘空间满了或者访问远程存储时网络异常。在早些时候，如果是读操作时发生的错误，<code>RocksDB</code> 就简单的将错误信息返回给客户端，而如果是写操作时发生的错误，<code>RocksDB</code> 则会永久性的暂停所有写操作。</p><p>而优化后 <code>RocksDB</code> 仅在遇到无法本地恢复的错误时才中断操作，例如暂时的网络错误不应该要求重启 <code>RocksDB</code> 实例。对于暂时性的错误，<code>RocksDB</code> 会周期性的重试。</p><h2 id="配置管理和可定制化的经验总结"><a class="markdownIt-Anchor" href="#配置管理和可定制化的经验总结"></a> 配置管理和可定制化的经验总结</h2><h3 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h3><p>一开始，<code>RocksDB</code> 的配置管理继承自 <code>LevelDB</code>，所有的配置都写死在代码中。这带来两个问题：</p><ol><li>某些配置和保存的数据强相关，因此，由某项配置生成的数据文件可能无法由其他配置的 <code>RocksDB</code> 实例打开</li><li>没有在代码中声明的配置会采用默认值，一旦 <code>RocksDB</code> 版本更新并修改了某些配置的默认值，上层应用可能会遇到不可预知的问题</li></ol><p>为了解决配置的问题，<code>RocksDB</code> 可以在打开某个数据库的同时额外接受某些参数配置，之后 <code>RocksDB</code> 又支持将配置持久化到文件中。<code>RocksDB</code> 也提供了额外的两个辅助工具：</p><ol><li>验证配置参数是否和要打开的数据库兼容</li><li>将数据库按照期望的参数配置进行迁移（不过存在使用限制）</li></ol><p>配置管理的另一个严峻的问题就是配置项太多了，用户很难知道每个配置参数的影响，进而不知道如何根据自身应用找到最优的配置。但是又很难找到一套放之四海皆准的默认配置，因为每个应用的使用场景，工作负载都不同。另一方面，对于集成了 <code>RocksDB</code> 的应用，例如 <code>MySQL</code>，数据库管理员可能对 <code>RocksDB</code> 了解不多也不知道如何优化。</p><p>在这个背景下，<code>RocksDB</code> 的开发团队花费了大量时间去优化默认配置下 <code>RocksDB</code> 的性能以及简化配置。同时，当前的重点在于提供配置的自适应性（<code>automatic adaptivity</code>），另一方面也持续提供 <code>RocksDB</code> 可自定义配置的能力，从而能适配不同类型的应用。同时做到这两方面会显著的增加代码维护的负担，不过一个统一的存储引擎的重要性大于代码的复杂度。</p><h3 id="回调函数的威力"><a class="markdownIt-Anchor" href="#回调函数的威力"></a> 回调函数的威力</h3><p><code>RocksDB</code> 需要周期性的合并底层的 <code>LSM</code> 树来清理已删除和过期的数据，如果能在合并时为应用提供额外的接口则能方便的为应用做功能扩展，而不需要额外的标准读写操作。因此，<code>RocksDB</code> 提供了两个在合并时的回调方法 <code>compaction filter</code> 和 <code>merge operator</code>。</p><h4 id="compaction-filter"><a class="markdownIt-Anchor" href="#compaction-filter"></a> Compaction Filter</h4><p>在合并时，<code>RocksDB</code> 提供了执行合并时针对每个被处理的键值对的回调函数，应用可以自行决定：</p><ol><li>丢弃这个键值对</li><li>修改值</li><li>不做任何修改</li></ol><p>一个典型的应用场景是实现 <code>time-to-live (TTL)</code>，每个键值对在写入时保存了过期时间，然后在合并期间判断是否过期从而删除数据。另一个应用场景是实现 <code>multi-version concurrency control (MVCC)</code> 中的垃圾回收。另外，<code>compaction filter</code> 也可以用于修改数据，例如，从旧数据格式迁移到新的数据格式，或者根据时间来修改数据。最后，<code>compaction filter</code> 有时候也可以用来收集统计信息。</p><p><code>compaction filter</code> 也非常适合需要扫描全部数据的管理任务，虽然也可以遍历整个数据集然后通过 <code>delete()</code> 或 <code>put()</code> 操作，但是使用 <code>compaction filter</code> 更高效且使用更少的 <code>I/O</code> 操作。借助 <code>compaction filter</code>，用户无需额外维护定时任务，也不用担心由自定义实现可能造成的写入毛刺。</p><p>不过，<code>compaction filter</code> 在使用上也有些限制。例如，错误的使用 <code>compaction filter</code> 可能会破坏基本的数据一致性保证，多次快照读也可能返回不一致的结果（如果数据在两次读之间发生了修改）。因此，<code>compaction filter</code> 在不要求一致性的场景下更容易使用。另一个限制是 <code>compaction filter</code> 无法原子的丢弃或者修改一批键值对，例如，无法原子的删除一个键值对并丢弃相应的二级索引中的数据。</p><h4 id="merge-operator"><a class="markdownIt-Anchor" href="#merge-operator"></a> Merge Operator</h4><p><code>RocksDB</code> 原生支持三类操作：<code>put()</code>，<code>delete()</code>，和 <code>merge()</code>。每一个操作都会写入到相应的 <code>MemTable</code>，然后刷盘到 <code>SSTable</code>。<code>merge()</code> 方法使得应用不需要先读取键就能更新键的值，也不需要写入完整的键的内容。在随后的读操作或者合并操作时，如果 <code>RocksDB</code> 遇到了一个 <code>merge record</code> 以及之前调用 <code>put()</code> 写入的记录，或者是多个 <code>merge record</code>，<code>RocksDB</code> 会调用 <code>merge operator</code> 回调函数，应用可以将这些记录合并成一个，既可以是一个 <code>put record</code>，也可以是一个 <code>merge record</code>。</p><p><code>merge operator</code> 的一个显著的应用是实现 <code>read-modify-write</code> 操作，例如实现一个计数器或者更新某个复杂对象中的单个字段。相比于用 <code>get()</code> 和 <code>put()</code> 整个键值对来实现，用 <code>merge operator</code> 来实现则更为轻量。不过，这会影响读的性能，因为找到一个 <code>merge record</code> 不代表查询结束，最坏的情况可能需要遍历 <code>LSM</code> 树的所有层，或者直到找到一个 <code>put record</code> 为止（更频繁的合并能缓解这个影响）。</p><h3 id="优化删除"><a class="markdownIt-Anchor" href="#优化删除"></a> 优化删除</h3><p>删除往往是 <code>LSM</code> 树中被忽略的一个操作。<code>RocksDB</code> 中无法直接删除键值对，删除操作本质上是插入一条标记删除的记录，这使得删除操作很快，但后续对该键的查询有可能变慢。在执行合并操作时，如果遇到标记删除的键值对，并不能直接将其物理删除，因为无法保证该键值对是否还存在于更深层的 <code>SSTable</code> 中。因此，<code>RocksDB</code> 针对删除场景也做了一些优化。</p><blockquote><p>假设应用对同一个键依次执行了三次操作：<code>put()</code>，<code>delete()</code>，<code>put()</code>，前两个操作属于 <code>MemTable1</code>，后一个操作属于 <code>MemTable2</code>，之后刷盘成 <code>SSTable1</code> 和 <code>SSTable2</code>。因为合并操作只是选取一部分 <code>SSTable</code>，所以有可能 <code>SSTable2</code> 先合并到了更深层。</p></blockquote><h4 id="支持对大范围标记删除的数据范围扫描"><a class="markdownIt-Anchor" href="#支持对大范围标记删除的数据范围扫描"></a> 支持对大范围标记删除的数据范围扫描</h4><p>应用经常会大批量删除连续或者临近的键，在这种场景下，调用 <code>scan()</code> 遍历每个键时就会遇到一堆已被标记删除的数据需要被跳过，从而浪费 <code>CPU</code> 和 <code>I/O</code> 资源。例如，某个应用可能用 <code>RocksDB</code> 保存文件系统中每个文件的绝对路径，而如果删除了文件夹则会导致一大批键被删除。再例如，使用 <code>RocksDB</code> 模拟队列时，每个出队的元素都会被删除，那么队首的元素则天然的挨着一批被删除的元素。遍历这些被删除的键一方面加重了资源负担，另一方面对查询结果也没有影响。在极端情况下，<code>RocksDB</code> 的开发团队在实践中遇到扫描了几百万个标记删除的键，最终只为了返回几个键值对。</p><p>一种解决思路是当出现大量连续标记删除的键时，触发合并操作。<code>RocksDB</code> 提供了几个功能：</p><ol><li>当标记删除的键占所有键之比超过50%时，合并会更积极的发生，并且随着标记删除的键占比增加而更频繁。不过，不能很好的处理标记删除的键占比不超过50%的情况</li><li>允许应用自己标记哪些 <code>SSTable</code> 需要执行合并。在执行合并生成新的 <code>SSTable</code> 时，<code>RocksDB</code> 提供了插件机制能够访问每个被处理的键值对，当新的 <code>SSTable</code> 创建后，<code>RocksDB</code> 会调用该插件从而判断是否需要将该 <code>SSTable</code> 放入下次的合并操作中。<code>RocksDB</code> 的统计信息中也包含了一次查询涉及了多少个标记删除的键，从而辅助应用更好的判断是否需要发起合并</li><li>执行 <code>scan()</code> 操作时，如果遇到了指定数量的标记删除的键，则提前中止遍历。当然，这样做的结果就是返回的数据不全，不过应用就能知道遇到了大量被标记删除的键，需要应用自行决定是否需要继续扫描还是放弃</li></ol><p>上述措施一定程度上能缓解前述的问题，不过依然有局限性：</p><ul><li>合并需要时间，在这期间 <code>scan()</code> 的性能依然受限</li><li>更频繁的合并意味着更大的写放大，这对于某些应用来说是不可接受的</li></ul><p>目前，这方面的优化工作仍然在进行中。</p><h4 id="回收磁盘空间"><a class="markdownIt-Anchor" href="#回收磁盘空间"></a> 回收磁盘空间</h4><p>一般来说，如果数据被删除了，那么其所占用的磁盘空间也应当被释放。不过在 <code>RocksDB</code> 中数据不是立即删除，需要等待一段时间，而应用可能会要求在指定的时间内就需要释放磁盘空间。因此，<code>RocksDB</code> 提供了一个功能保证在指定时间内所有被标记删除的键都会移动到 <code>LSM</code> 树的最后一层，那么这些数据在随后的合并中就可以被清理。<code>RocksDB</code> 通过在 <code>SSTable</code> 的元数据中维护每个键首次添加到系统中的时间来实现该功能。</p><h4 id="文件删除限流"><a class="markdownIt-Anchor" href="#文件删除限流"></a> 文件删除限流</h4><p><code>RocksDB</code> 一般构建于能够感知 <code>SSD</code> （<code>flash-SSD-aware</code>）的文件系统之上，当某个文件被删除时，它会发送一个 <code>TRIM</code> 命令给 <code>SSD</code>。<code>TRIM</code> 的性能较好且对于 <code>SSD</code> 的寿命影响较小。不过，它可能会造成其他的性能问题：除了更新地址映射（大多数位于 <code>SSD</code> 的内部内存中）之外，<code>SSD</code> 固件还需要将这些变更作为 <code>FTL</code> 日志写到闪存上，这又会触发 <code>SSD</code> 内部的垃圾回收，从而造成大量的数据迁移，并最终影响上层应用的 <code>I/O</code> 延迟。所以，<code>RocksDB</code> 增加了文件删除的限流来控制同一时刻删除的文件个数。</p><h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3><p><code>RocksDB</code> 对于内存的使用主要在于 <code>SSTable</code> 的 <code>block cache</code> 以及保存 <code>MemTable</code>。相比于其他数据库自己维护缓冲池，<code>RocksDB</code> 则依托于 <code>jemalloc</code> 进行内存分配。</p><p>尽管块的大小是可配置的，<code>RocksDB</code> 的实际实现则是采用变长的块，不过其大小会尽可能的接近所配置的值。例如，如果某个键值对的大小超过了指定的块大小，那么 <code>RocksDB</code> 会为其创建较大的块。类似的，如果某个块中已经存在一部分键值对，而此时再放入一个键值对就会超过块的大小时，则该键值对不会被放入该块中，并且 <code>RocksDB</code> 会选择一个较小的块来存放原来的那批键值对。另外，<code>SSTable</code> 的索引块和布隆过滤器的块大小也没有采用固定大小。出于这么做的原因是因为 <code>RocksDB</code> 采用的数据结构不支持就地更新，采用固定大小的块收益不大。</p><p>不过，在实践中，借助 <code>jemalloc</code> 来管理内存在分配和回收时都存在不可忽视的开销，其外部的内存碎片和元数据带来的额外内存开销也值得应用注意。这种情况下应用开发者可以选择换一个内存分配器，或者对 <code>jemalloc</code> 进行调优。</p><p>另外，<code>RocksDB</code> 的用户也经常对如何高效的调优内存参数感到迷茫。<code>RocksDB</code> 能够精确限制 <code>block cache</code> 和 <code>MemTable</code> 的内存参数，但是对 <code>jemalloc</code> 的外部内存碎片和元数据无法掌控，所以用户需要自行判断应该给这部分预留多少内存。因此，实验是检验真理的唯一标准。</p><p>尽管如此，<code>RocksDB</code> 的开发团队认为使用 <code>jemalloc</code> 仍然是一个合理的决定，因为可以将精力放到其他更重要的方面上。不过未来可能也会将这个内存管理问题提上日程。</p><h2 id="key-value-接口设计的经验教训"><a class="markdownIt-Anchor" href="#key-value-接口设计的经验教训"></a> Key-Value 接口设计的经验教训</h2><p><code>RocksDB</code> 的核心接口就四个：</p><ul><li><code>put()</code></li><li><code>delete()</code></li><li><code>get()</code></li><li><code>iterators (scans)</code></li></ul><p>很少有应用无法基于这四个接口实现需要的功能，<code>KV</code> 接口的键和值都是变长的字节数组，因此应用程序可以很自由的存储想要的数据，只需要做好序列化和反序列化。另外一个好处是可移植性，应用可以轻易的从一个 <code>KV</code> 系统迁移到另一个。</p><p>不过，天下没有完美的事物，部分应用的性能反而会受限于这精简的接口。例如，在 <code>RocksDB</code> 之外处理并发控制就很难做的高效，尤其是两阶段提交场景下需要在事务提交前先持久化一部分数据的场景。因此，<code>RocksDB</code> 增加了事务的功能，并持续添加新的功能，例如对某个范围内的数据加锁，以及支持大事务。</p><p>在其他场景下，应用则受限于过于精简的接口，为此 <code>RocksDB</code> 增加了两项扩展：</p><ul><li>由应用定义的时间戳</li><li>列支持</li></ul><h3 id="版本和时间戳"><a class="markdownIt-Anchor" href="#版本和时间戳"></a> 版本和时间戳</h3><p>为了支持诸如 <code>multi-version concurrency control (MVCC)</code> 和从历史某个时间点读取（<code>point-in-time reads</code>）的功能，<code>RocksDB</code> 需要能够支持数据的版本管理，并能高效的访问各个版本。</p><p>目前，<code>RocksDB</code> 内部使用一个56位长度的序列号来标识键值对的每个版本。客户端的每一次写请求都会对版本号加1，不过客户端无法直接修改这个版本号。<code>RocksDB</code> 允许应用对其执行快照，<code>RocksDB</code> 保证只要这个快照没有被应用释放，那么在这个快照执行的时间点时的数据就都能始终被访问。</p><p>不过，对很多应用来说这依然不够，为了读取历史上的数据，前提是应用必须先曾经做过快照，<code>RocksDB</code> 不支持在当前时间对历史的某个时间点执行快照，因为根本没有这样的接口。另外，<code>RocksDB</code> 的版本号是每个实例各自维护，快照也是各实例粒度。因此，对于多 <code>shard</code> 的应用来说，很难对所有节点同时做一致的快照。</p><p>虽然应用可以将时间戳写入到键或者值中，不过这会影响应用的性能。如果将时间戳写入到键中，则点查询的性能会很差，因为实际保存的键和用户查询的键已经不同，需要做前缀扫描遍历；如果将时间戳写入到值中，则会影响对同一个键乱序写入的性能，因为乱序写入时如果不考虑相互间的时间戳顺序则有可能发生数据覆盖，并且读取旧版本的数据也变得复杂。因此，<code>RocksDB</code> 需要提供在键值之外由应用自行指定时间戳的能力。</p><p>经过实验，由应用指定时间戳的情况下，<code>RocksDB</code> 相比于将时间戳写入到键的方案有1.2倍的吞吐提升。提升的原因在于：</p><ul><li>时间戳是键值对元数据的一部分，因此点查询依然高效</li><li>布隆过滤器可以继续发挥作用</li><li>每个 <code>SSTable</code> 在元数据中同时也维护了所有键所覆盖的时间戳范围，因此在搜索时有可能直接忽略整个 <code>SSTable</code></li></ul><p>当然缺点就是磁盘使用空间会变大以及移植性变差。</p><h3 id="列支持"><a class="markdownIt-Anchor" href="#列支持"></a> 列支持</h3><p>一些基于 <code>SQL</code> 的数据库实现会以列的形式组织 <code>RocksDB</code> 的数据，虽然应用可以将数据库中一整行的数据以单条 <code>KV</code> 的形式保存在 <code>RocksDB</code>，但是如果能直接在 <code>RocksDB</code> 层面支持列则对应用的性能提升有很大帮助。</p><p>假设有些大对象的某些列更新非常频繁，那么在整行数据保存的方案下更新就非常不高效。如果支持列，则只需要更新部分列。另外，如果数据库的某个查询也只涉及部分列，那么也不必读取完整的一行数据。</p><p>某些应用已经尝试对上述的问题进行优化。例如 <code>Rocksandra</code> 借助 <code>merge operator</code> 来进行部分列的更新，不过代价就是读性能较差，因为需要读完所有的 <code>merge record</code> 或者遇到一个 <code>put record</code> 才能知道最终的结果。另一种方案是将一行数据的每一列保存为一个键值对，缺点在于：</p><ol><li>读取一行数据需要进行范围扫描（比如所有的列数据的键都以主键为前缀）</li><li>删除和更新一整行数据变得困难</li></ol><p>因此，如果能在 <code>RocksDB</code> 层面直接支持列，则能大大提高应用的性能：</p><ol><li>更新和读取单列的数据变得高效</li><li>当应用发起针对某些列的过滤查询时，某些过滤条件可以下推到 <code>SSTable</code></li><li>某些列可以用不同配置的 <code>column family</code> 保存</li><li>可以像列数据库一样高效压缩保存列数据</li></ol><p>另外，支持列也能够让 <code>RocksDB</code> 在主键索引和二级索引间校验数据完整性。</p><h2 id="来自失败的提案的经验总结"><a class="markdownIt-Anchor" href="#来自失败的提案的经验总结"></a> 来自失败的提案的经验总结</h2><p>一路走来，<code>RocksDB</code> 实现了很多的功能，其中也有些失败的案例。</p><h3 id="支持基于-dram-的存储设备"><a class="markdownIt-Anchor" href="#支持基于-dram-的存储设备"></a> 支持基于 DRAM 的存储设备</h3><p>在2014年，<code>RocksDB</code> 的开发团队决定将 <code>RocksDB</code> 适配到 <code>Ramfs</code> （<code>RAM File System</code>）上，从而有比 <code>SSD</code> 更低的访问延迟。为此，<code>RocksDB</code> 将 <code>SSTable</code> 和 <code>MemTable</code> 的格式改为插件式，从而针对 <code>Ramfs</code> 进行了特定的优化。</p><p>这个结果本身是成功的并且也应用到了某些服务上。不过，在战略上来说这个功能提的太早了。对于大型纯内存式的持久化存储系统来说，<code>RocksDB</code> 的这套方案并未像预期的那样获得关注。而对于内存式的应用来说，一般也不会考虑集成 <code>RocksDB</code>，因为完全直接自己操作内存来的更快和便捷。</p><h3 id="支持混合式存储设备"><a class="markdownIt-Anchor" href="#支持混合式存储设备"></a> 支持混合式存储设备</h3><p><code>SSD</code> 比 <code>HDD</code> 更快，不过也更贵而且寿命也有限。因此，如果能结合 <code>SSD</code> 和 <code>HDD</code> 一起使用，那么对于大多数的应用来说可以在性能和成本之间做到更好的平衡。同样是在2014年，<code>RocksDB</code> 支持能将 <code>LSM</code> 树的不同层保存到不同的存储设备上。</p><p>不过，在该功能推出的时候用户并没有买账。另一方面，在实践中将 <code>SSD</code> 和 <code>HDD</code> 同时配置到一个节点上的情况也比较罕见，<code>RocksDB</code> 的开发团队认为混合存储方案的潮流应该对远程存储服务更有吸引力，而这要到2018年才开始着手。不过，最近<code>RocksDB</code> 的开发团队又重拾了混合式存储项目，因为要支持混合式的本地/远程存储服务，不过依然还有额外的工作要做。</p><h3 id="更丰富高层次的接口"><a class="markdownIt-Anchor" href="#更丰富高层次的接口"></a> 更丰富，高层次的接口</h3><p><code>RocksDB</code> 最开始支持的是传统的 <code>KV</code> 接口，不过，在过去的几年中也尝试过扩展支持更为丰富的接口，从而更方便某些应用使用。例如，在2013年 <code>RocksDB</code> 添加了类似于 <code>Redis</code> 的 <code>lists</code> 的接口；在2014年添加了2个与空间相关的接口；在2015年支持了文档类型的数据。所有这些接口都基于核心的 <code>KV</code> 接口实现。</p><p>但是，这些接口同样没有被广泛采纳，并最终废弃和移除。因此，对于 <code>RocksDB</code> 的开发团队来说，将精力放在核心功能上更有价值。大部分 <code>RocksDB</code> 的用户都能借助简单的 <code>KV</code> 接口构建更为丰富的上层接口，而不需要由 <code>RocksDB</code> 来提供。用户的首要痛点在于效率和易管理性。总结来说，扩展核心接口的前提在于能够显著提升性能。</p><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><h3 id="经验总结"><a class="markdownIt-Anchor" href="#经验总结"></a> 经验总结</h3><ol><li>对于存储引擎来说，能够调优适配不同的工作场景至关重要</li><li>大多数使用 <code>SSD</code> 的应用的瓶颈在于空间效率</li><li>降低 <code>CPU</code> 开销对系统的高效运行越来越重要</li><li>如果一台机器上运行了多个 <code>RocksDB</code> 的实例，那么全局的资源管理就是必须的</li><li><code>WAL</code> 的可配置性（同步刷盘写 <code>WAL</code>；先将 <code>WAL</code> 写入到缓冲区，然后定期刷盘；无 <code>WAL</code>）能够给上层应用带来性能提升</li><li>需要正确的支持数据副本和备份</li><li><code>RocksDB</code> 需要对数据和配置文件提供后向和前向兼容</li><li>越早识别数据损坏越好，而不是在最后检测</li><li>完整性保护必须能够覆盖整个系统来避免数据损坏（例如，由 <code>CPU</code> 或内存引起的 <code>bitflip</code>）扩散给客户端或者其他副本；只在数据空闲时或者传输时进行损坏检测是不够的</li><li>错误处理需要能够根据类别和严重性分别处理</li><li>即使概率很低，<code>CPU</code> 和内存造成数据损坏也有可能发生，因此数据副本并不一定总是能解决这种情况</li><li>自适应的配置对简化配置管理大有益处</li><li>可以通过用户自定的回调函数来提升性能，不过当前的技术方案仍有进步的空间</li><li>在 <code>LSM</code> 树中删除连续的键会带来性能问题</li><li><code>SSD</code> 的 <code>TRIM</code> 对性能大有帮助，不过需要对文件删除作限流来避免偶发的性能问题</li><li>借助第三方内存分配器来管理内存使得开发团队能将精力放在其他重要的功能上，不过缺点是带来了可管理性问题</li><li>目前的 <code>KV</code> 接口已足够有用，不过对于某些应用场景来说可能会有性能问题；在键值之外添加时间戳能够在性能和简洁性上达到较好的平衡</li><li>应用可以在 <code>RocksDB</code> 提供的 <code>KV</code> 接口之上实现列数据并且有着较好的性能，不过如果存储引擎本身支持列则会有更好的性能</li></ol><h3 id="设计抉择回顾"><a class="markdownIt-Anchor" href="#设计抉择回顾"></a> 设计抉择回顾</h3><ol><li>可定制化对用户始终有用：结果就是用户迷失在大量的配置里，而且很难找到最优的配置</li><li><code>RocksDB</code> 无法感知 <code>CPU</code> 的 <code>bitflip</code>：完整性保护需要端到端覆盖</li><li>遇到任何 <code>I/O</code> 错误时可以直接中断操作：过于粗暴，所以需要根据错误的类别和严重性做不同的处理</li></ol><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://research.facebook.com/publications/rocksdb-evolution-of-development-priorities-in-a-key-value-store-serving-large-scale-applications/">RocksDB: Evolution of Development Priorities in a Key-value Store Serving Large-scale Applications</a></li><li><a href="https://en.wikipedia.org/wiki/Write_amplification">Write amplification</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是 &lt;code&gt;Facebook&lt;/code&gt; 对 &lt;code&gt;RocksDB&lt;/code&gt; 8年开发历程的回顾，重点讨论了为支持大规模分布式系统所做的开发优先级取舍与演进，以及在生产环境中运行大规模应用的经验。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;ma</summary>
      
    
    
    
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
    <category term="RocksDB" scheme="https://frederick-s.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>【读】How to Read a Paper</title>
    <link href="https://frederick-s.github.io/2025/01/28/how-to-read-a-paper/"/>
    <id>https://frederick-s.github.io/2025/01/28/how-to-read-a-paper/</id>
    <published>2025-01-27T16:00:00.000Z</published>
    <updated>2025-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>本文提出了一种高效阅读文献的方式，相比于一上来就从头读到尾，作者将其拆解为三趟式阅读：</p><ol><li>第一遍了解论文讲什么，解决了什么问题，提出了什么方法</li><li>第二遍理解论文的内容，但忽略细节</li><li>第三遍深入理解论文</li></ol><h2 id="第一遍阅读"><a class="markdownIt-Anchor" href="#第一遍阅读"></a> 第一遍阅读</h2><p>第一遍阅读建议控制在5到10分钟内，阅读内容包括：</p><ol><li>仔细阅读标题，摘要和简介部分</li><li>阅读每一节和每小节的标题，但忽略内容</li><li>阅读结论部分</li><li>扫一遍论文引用，并标记哪些已经读过</li></ol><p>第一遍读完后，你应该能够回答5个问题：</p><ol><li>Category：这是一篇什么类型的论文？</li><li>Context：有哪些其他相关的论文？</li><li>Correctness：论文中的假设对吗？</li><li>Contributions：这篇论文的主要贡献是什么？</li><li>Clarity：这篇论文写的清晰易懂吗？</li></ol><p>当回答了这5个问题后，你就可以决定是否要继续读下去，不继续读的原因可能是因为这篇论文对你价值不大，也可能是因为你还没有足够的知识储备来理解，甚至是论文中描述的假设都是错的。</p><h2 id="第二遍阅读"><a class="markdownIt-Anchor" href="#第二遍阅读"></a> 第二遍阅读</h2><p>第二遍开始仔细阅读论文，但忽略细节比如证明环节：</p><ol><li>仔细阅读论文中的图表，尤其是图片。一些图表中的常见错误可以提前让你甄别出不严谨甚至是粗制滥造的论文</li><li>标记还没有读过的相关论文引用以便之后阅读，这有助于更好理解该篇论文的背景</li></ol><p>第二遍阅读应该控制在1小时以内，通过第二遍阅读，你应该能够理解论文的内容，并能够自我总结论文的要旨给第三者。这个层次的掌握程度对于阅读感兴趣的论文已经足够，但用于科研工作还不够。</p><p>如果第二遍读完还不能理解怎么办？这有可能是因为论文的主题对你来说是一个新事物，也可能是因为论文的作者采用的证明让你摸不着头脑，或者这篇论文就是写的晦涩难懂，甚至是因为夜深了。你可以选择：</p><ul><li>把论文放一边，即使不理解这篇论文也不影响你事业的成功</li><li>之后再看，先补充点背景材料</li><li>硬着头皮开始第三遍阅读</li></ul><h2 id="第三遍阅读"><a class="markdownIt-Anchor" href="#第三遍阅读"></a> 第三遍阅读</h2><p>第三遍阅读能让你真正的理解这篇论文。这次阅读的关键是假设自己是论文的作者，并且基于原作者的假设，重新构建论文。通过你所构建的论文和原论文对比，你就能轻易的发现原论文的创新点，以及潜在隐藏的缺点和假设。</p><p>第三遍阅读需要高度关注细节，并时刻本着以怀疑的态度看待论文中的每一个假设。通过这次阅读，也能够为你之后的科研工作提供一些想法。</p><p>对于新手来说第三遍阅读大概要花4到5个小时，而对于有经验的读者来说只需要1小时。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf">How to Read a Paper</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;本文提出了一种高效阅读文献的方式，相比于一上来就从头读到尾，作者将其拆解为三趟式阅读：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一遍了解论文讲什么，解决了什</summary>
      
    
    
    
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>【读】Bitcask - A Log-Structured Hash Table for Fast Key/Value Data</title>
    <link href="https://frederick-s.github.io/2025/01/05/bitcask/"/>
    <id>https://frederick-s.github.io/2025/01/05/bitcask/</id>
    <published>2025-01-04T16:00:00.000Z</published>
    <updated>2025-01-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>Bitcask</code> 是一个单机 <code>KV</code> 存储引擎，项目起因于 <code>Riak</code> 分布式 <code>KV</code> 数据库需要一个能满足以下条件的单机 <code>KV</code> 存储引擎：</p><ul><li>低延迟的单条读写</li><li>高吞吐，尤其是面对流式随机 <code>KV</code> 写入</li><li>能支持远比内存大的数据量</li><li>能从崩溃中快速恢复以及不丢失数据</li><li>能轻松的备份和还原数据</li><li>相对简单，易理解的代码结构和数据格式</li><li>在高负载和大数据场景下系统的行为是可预期的</li><li>软件的许可证要能轻易的适配 <code>Riak</code> 使用</li></ul><p>作者看了一圈发现市面上还没有一款 <code>KV</code> 存储能全部满足这些条件，因此 <code>Bitcask</code> 就应运而生。</p><h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2><p><code>Bitcask</code> 的接口非常精简：</p><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>bitcask:open(DirectoryName, Opts) -&gt; BitCaskHandle | {error, any()}</td><td>在指定目录下以指定选项打开或新建一个 <code>Bitcask</code> 实例。支持的选项包括 <code>read_write</code> 或者 <code>sync_on_put</code>：<ul><li><code>read_write</code>：可读可写</li><li><code>sync_on_put</code>：每次写操作后刷盘</li></ul> 连接的进程需要有 <code>DirectoryName</code> 对应目录的读写权限，同时一个时刻只能有一个进程以 <code>read_write</code> 的方式打开 <code>Bitcask</code> 实例。</td></tr><tr><td>bitcask:open(DirectoryName) -&gt; BitCaskHandle | {error, any()}</td><td>在指定目录下以只读模式打开或新建一个 <code>Bitcask</code> 实例。连接的进程需要有 <code>DirectoryName</code> 对应目录及其内部所有文件的读权限。</td></tr><tr><td>bitcask:get(BitCaskHandle, Key) -&gt; not_found | {ok, Value}</td><td>获取指定键对应的值。</td></tr><tr><td>bitcask:put(BitCaskHandle, Key, Value) -&gt; ok | {error, any()}</td><td>插入一个键值对。</td></tr><tr><td>bitcask:delete(BitCaskHandle, Key) -&gt; ok | {error, any()}</td><td>删除指定键。</td></tr><tr><td>bitcask:list_keys(BitCaskHandle) -&gt; [Key] | {error, any()}</td><td>返回所有的键。</td></tr><tr><td>bitcask:fold(BitCaskHandle, Fun, Acc0) -&gt; Acc</td><td>对每一个键值对应用 <code>Fun</code> 函数，<code>Fun</code> 的函数签名为 <code>F(K, V, Acc0) -&gt; Acc</code>。类似于 <code>JavaScript</code> 的 <code>reduce</code>。</td></tr><tr><td>bitcask:merge(DirectoryName) -&gt; ok | {error, any()}</td><td>合并目录下的数据文件以减少重复的键值对。同时生成 <code>hintfile</code> 辅助加速程序启动时间。</td></tr><tr><td>bitcask:sync(BitCaskHandle) -&gt; ok</td><td>强制刷盘。</td></tr><tr><td>bitcask:close(BitCaskHandle) -&gt; ok</td><td>关闭 <code>Bitcask</code> 实例的连接并刷盘。</td></tr></tbody></table><h2 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h2><h3 id="文件组织"><a class="markdownIt-Anchor" href="#文件组织"></a> 文件组织</h3><p><code>Bitcask</code> 的文件组织非常简单，任意时刻目录下最多只有一个 <code>active data file</code> 接收写操作，其余都是不可修改的历史数据文件。任意时刻 <code>Bitcask</code> 只允许一个进程以写模式建立连接，写入进程只会向 <code>active data file</code> 写入，当其大小超过指定阈值后就会关闭当前文件，然后新建一个 <code>active data file</code>。</p><p><img src="/images/bitcask-1.png" alt="alt" /></p><h3 id="数据格式"><a class="markdownIt-Anchor" href="#数据格式"></a> 数据格式</h3><p>写入进程以追加写的方式写入 <code>active data file</code>，从而避免了随机写的磁盘寻址，其写入数据格式如下：</p><p><img src="/images/bitcask-2.png" alt="alt" /></p><ul><li><code>crc</code>：循环冗余校验码，验证数据完整性</li><li><code>tstamp</code>：32位整型本地时间戳，仅内部使用，不对外暴露</li><li><code>ksz</code>：键的长度</li><li><code>value_sz</code>：值的长度</li><li><code>key</code>：键的内容</li><li><code>value</code>：值的内容</li></ul><p>对于每一条记录，前面四个部分都是定长，以此为基址 <code>base</code>，则 <code>base</code> 到 <code>base + ksz</code> 就是键的内容，<code>base + ksz</code> 到 <code>base + ksz + value_sz</code> 就是值的内容。</p><p>如果要删除指定的键，<code>Bitcask</code> 会再次追加写入一个键值对，只不过写入的值是一个特殊值，程序后续读到这条记录时比较值的内容就可以判断该条记录是否已被删除。所以，<code>Bitcask</code> 每个文件内容就是一行行的记录：</p><p><img src="/images/bitcask-3.png" alt="alt" /></p><h2 id="读写"><a class="markdownIt-Anchor" href="#读写"></a> 读写</h2><h3 id="写"><a class="markdownIt-Anchor" href="#写"></a> 写</h3><p><code>Bitcask</code> 写入的同时会在内存中维护写入的键到数据文件的映射（<code>keydir</code>）：<br /><img src="/images/bitcask-4.png" alt="alt" /></p><p>其中 <code>file_id</code> 能够定位具体的数据文件，<code>value_pos</code> 是该条记录的值在文件中的起始偏移位置，那么 <code>value_pos</code> 到 <code>value_pos + value_sz</code> 就是值的内容。因为 <code>Bitcask</code> 每次写数据的长度是可知的，值在每条记录中的偏移量可知，写之前 <code>active data file</code> 文件总长也可知，所以 <code>value_pos</code> 也能够推算出来。</p><p>对于重复写入的键值对，磁盘上会存在同一个键的多条记录，但是 <code>keydir</code> 中始终只保留最新的映射。</p><h3 id="读"><a class="markdownIt-Anchor" href="#读"></a> 读</h3><p>读取时先根据键查询 <code>keydir</code> 得到数据文件的映射，然后根据 <code>file_id</code> 定位数据文件，最后根据 <code>value_pos</code> 和 <code>value_sz</code> 返回值的内容，整个读取只涉及一次磁盘寻址。另一方面，文件系统的 <code>read-ahead</code> 缓存会进一步减少磁盘的交互：</p><p><img src="/images/bitcask-5.png" alt="alt" /></p><h2 id="数据合并"><a class="markdownIt-Anchor" href="#数据合并"></a> 数据合并</h2><p>由于 <code>Bitcask</code> 追加写的特性，有两种类型的数据是冗余的：</p><ul><li>被标记删除的数据</li><li>同一个键的旧版本的数据</li></ul><p>所以，为了避免磁盘空间的浪费，需要额外的数据合并操作对磁盘上的数据瘦身。数据合并只处理只读的数据文件，遍历剔除掉已删除和旧版本的数据。另外，每一个合并后的数据文件同时额外有一个对应的 <code>hint file</code>：</p><p><img src="/images/bitcask-6.png" alt="alt" /></p><p><code>hint file</code> 也是行记录的文件，每一行存储了：</p><ul><li><code>tstamp</code>：时间戳</li><li><code>ksz</code>：键的长度</li><li><code>value_sz</code>：值的长度</li><li><code>value_pos</code>：值在数据文件中的起始地址偏移量</li><li><code>key</code>：键</li></ul><p>当程序启动时，如果 <code>hint file</code> 存在，那么就可以直接扫描 <code>hint file</code> 构建 <code>keydir</code> 从而加速程序启动；反之，则要扫描数据文件。</p><h2 id="性能数据"><a class="markdownIt-Anchor" href="#性能数据"></a> 性能数据</h2><p>原文并没有给出非常正规的测试报告，仅列出了一些早期未优化的测试数据：</p><ul><li>读写延迟：毫秒内</li><li>写吞吐：5000~6000次/秒</li><li>内存占用：几百万的键在 <code>1GB</code> 内（<code>keydir</code> 需要）</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><code>Bitcask</code> 的整体设计思路非常简单，其设计目的也不是为了成为最快的 <code>KV</code> 存储，而是最适合 <code>Riak</code> 的存储引擎，在足够快的同时有着高质量、简洁的代码，设计和数据格式。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://riak.com/assets/bitcask-intro.pdf">Bitcask - A Log-Structured Hash Table for Fast Key/Value Data</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Bitcask&lt;/code&gt; 是一个单机 &lt;code&gt;KV&lt;/code&gt; 存储引擎，项目起因于 &lt;code&gt;Riak&lt;/code&gt; </summary>
      
    
    
    
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
    <category term="Bitcask" scheme="https://frederick-s.github.io/tags/Bitcask/"/>
    
  </entry>
  
  <entry>
    <title>GNU - 什么是自由的软件</title>
    <link href="https://frederick-s.github.io/2025/01/04/gnu-what-is-free-software/"/>
    <id>https://frederick-s.github.io/2025/01/04/gnu-what-is-free-software/</id>
    <published>2025-01-03T16:00:00.000Z</published>
    <updated>2025-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>自由的软件的定义四要素：</p><ul><li>以任何意愿，目的运行软件的自由</li><li>学习软件运行原理的自由，并且能按自主意愿修改（前提还需要能自由访问源代码）</li><li>将软件的副本再次分发给其他人的自由</li><li>将修改后的软件的副本分发给其他人的自由</li></ul><p>一个软件只有具备了上述四点才是自由的软件。</p><p>不过，自由的软件不表示不能商用，相反，GNU 鼓励并且认为商用是自由软件社区成功的重要途径。自由的软件必须能够在商业上使用，开发，以及分发。</p><h2 id="自由与非自由的边界"><a class="markdownIt-Anchor" href="#自由与非自由的边界"></a> 自由与非自由的边界</h2><h3 id="以任何意愿运行软件的自由"><a class="markdownIt-Anchor" href="#以任何意愿运行软件的自由"></a> 以任何意愿运行软件的自由</h3><p>任何个人或组织可以在任意计算机系统上，出于任意目的运行软件，而不需要事先和开发者或者其他组织联系。同时，你也可以将软件再分发给其他用户，其他用户也能自由的以他们自己的意愿去运行软件而不受你的约束。</p><h3 id="学习软件源代码并修改的自由"><a class="markdownIt-Anchor" href="#学习软件源代码并修改的自由"></a> 学习软件源代码并修改的自由</h3><p>自由的获取软件的源代码是能够自由修改软件和再分发的前提，不过，经过代码混淆工具处理过的代码不算是源代码。</p><p>同时，如果对修改软件有限制，那么该软件也不算是自由的软件，例如：</p><ul><li>某软件引用了修改后的软件 A，但不允许将其替换为你自己修改的版本</li><li>要求你成为所修改的代码的版权拥有者</li><li>只能做出其他人认为是改进的修改</li></ul><h3 id="软件再分发的自由"><a class="markdownIt-Anchor" href="#软件再分发的自由"></a> 软件再分发的自由</h3><p>你可以自由的再分发未修改或修改后的软件副本给任何人，即使是收费。同时，你也可以自由的修改软件然后私用，而不需要让其他任何人知道；如果你将修改后的软件再分发，也不需要以任何形式知会任何人。</p><p>自由再分发的软件副本必须包含可执行文件，以及修改和未修改的源代码。不过有些软件可能（暂时）无法生成可执行的文件，但是依然要保留能够再分发可执行文件的自由。</p><h3 id="copyleft"><a class="markdownIt-Anchor" href="#copyleft"></a> Copyleft</h3><p>版权的单词是 <code>copyright</code>，<code>copyleft</code> 与之对应。它要求所修改和扩展的软件都必须依然保留自由软件的四要素（而不仅仅是免费），<code>GNU</code> 自己的项目就使用符合 <code>copyleft</code> 的许可证来保证软件的自由。不过，这里并不是说所有自由的软件都必须用 <code>copyleft</code> 许可证，不然也违背了自由一词。</p><h3 id="软件分发的约束"><a class="markdownIt-Anchor" href="#软件分发的约束"></a> 软件分发的约束</h3><p>只要不限制分发修改后的软件的自由，不限制私用修改后的软件，对软件分发做一定程度的约束是可接受的。例如，要求给修改后的软件换个名字，删除原有软件的 <code>logo</code>，或者声明修改为你所有。</p><h3 id="出口规定"><a class="markdownIt-Anchor" href="#出口规定"></a> 出口规定</h3><p>有时候政府的出口管制会限制你在国际上分发软件的自由。虽然身为开发人员无法对抗这些规定，但是你可以做也必须做的是，不添加这些法律条文作为软件的使用条件。</p><h3 id="合规考虑"><a class="markdownIt-Anchor" href="#合规考虑"></a> 合规考虑</h3><p>如果软件的用户没有做任何不合规的事，那么软件的开发人员不能随意的撤销软件的许可证，或添加使用限制，否则这就不是自由的软件。</p><h3 id="基于合约的许可证"><a class="markdownIt-Anchor" href="#基于合约的许可证"></a> 基于合约的许可证</h3><p>有些基于合约的许可证会引入较多的使用限制，从而可能违背自由软件的四要素，因此这类许可证不被认为是自由的许可证。例如某些免费的软件许可证会规定允许被安装的设备的数量，以及限制分享给他人使用。</p><h2 id="软件之外"><a class="markdownIt-Anchor" href="#软件之外"></a> 软件之外</h2><p>软件的使用手册也必须是自由的，因为手册也是软件的一部分。再扩展一步，自由不仅仅是用在软件上，任何能够以数字形式呈现的产物都可以是自由的。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://www.gnu.org/philosophy/free-sw.html">What is Free Software?</a></li><li><a href="https://www.gnu.org/licenses/copyleft.html">What is Copyleft?</a></li><li><a href="https://freedomdefined.org/Definition">Free Cultural Works</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;自由的软件的定义四要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以任何意愿，目的运行软件的自由&lt;/li&gt;
&lt;li&gt;学习软件运行原理的自由，并且能按自主意愿修</summary>
      
    
    
    
    
    <category term="GNU" scheme="https://frederick-s.github.io/tags/GNU/"/>
    
  </entry>
  
  <entry>
    <title>个人向最喜欢的十款单机游戏</title>
    <link href="https://frederick-s.github.io/2025/01/01/top-10-games/"/>
    <id>https://frederick-s.github.io/2025/01/01/top-10-games/</id>
    <published>2024-12-31T16:00:00.000Z</published>
    <updated>2024-12-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>豆瓣个人评分标准：</p><ul><li>五星：一见钟情，简直停不下来，必然多周目起步</li><li>四星：依然优秀，但是相比五星存在无法忽略的缺点，可能会多周目</li><li>三星：没什么吸引人的地方，大部分能坚持到一周目结束，基本不会多周目</li><li>二星：肉眼可见的烂，中途就弃</li><li>一星：还没遇到过</li></ul><p>以下是个人向五星里最喜欢的十款单机游戏，重剧情、代入感，轻玩法、动作，按接触时间倒序。</p><h2 id="赛博朋克2077"><a class="markdownIt-Anchor" href="#赛博朋克2077"></a> 赛博朋克2077</h2><p>一开始被蠢驴泼天的 bug 劝退了，一直没有上手。不过，看到 DLC 往日之影发售之后大受好评，而且据说2.0版本相比初版已改进不少，遂抱着试试看的心理购入，最终真香，依然吃蠢驴这套。遗憾的是支线的量不够多，意犹未尽。</p><h2 id="上古卷轴5"><a class="markdownIt-Anchor" href="#上古卷轴5"></a> 上古卷轴5</h2><p>2024年才接触老滚5，而且还没装 Mod，玩了200小时之后依然觉得还有200小时的内容在等待发掘。个人认为老滚5和荒野之息体现了做开放世界的两个赛道，在老滚5里我能停下来和每个人对话，探索世界的动力在于我会遇到什么样的人，会发生什么事。</p><h2 id="荒野大镖客2"><a class="markdownIt-Anchor" href="#荒野大镖客2"></a> 荒野大镖客2</h2><p>R 星的另一个代表作道德与法治5由于缺少对三个主角的代入感，加上整体枪车戏份过多，玩了一遍后就没有重拾的动力。反而比较适合大表哥2慢悠悠的世界，最终随着结尾曲响起，代入感达到顶峰，仿佛失去了一位朋友。</p><h2 id="女神异闻录5"><a class="markdownIt-Anchor" href="#女神异闻录5"></a> 女神异闻录5</h2><p>中二的剧情，新奇的 UI，魔性的音乐，不知不觉就过了100小时，并且回合制战斗也不显得枯燥。</p><h2 id="巫师3"><a class="markdownIt-Anchor" href="#巫师3"></a> 巫师3</h2><p>蠢驴入坑之作，虽然相比老滚5显得并不开放，但丰富的支线加上优秀的音乐让人流连忘返。</p><h2 id="最后生还者"><a class="markdownIt-Anchor" href="#最后生还者"></a> 最后生还者</h2><p>线性叙事的巅峰，没有一丝冗余，剧情和动作完美结合，无时无刻不在关注下一秒的走向。</p><h2 id="空之轨迹"><a class="markdownIt-Anchor" href="#空之轨迹"></a> 空之轨迹</h2><p>一首星之所在伴随至今，相比于现在注水冗余的轨迹系列，剧情优秀，人物感情细腻。</p><h2 id="三国志11"><a class="markdownIt-Anchor" href="#三国志11"></a> 三国志11</h2><p>独特的水墨画风，恰到好处的音乐，相比于即时制更喜欢回合制的操控，能够一直待在电脑里，历史感十足。</p><h2 id="太阁立志传5"><a class="markdownIt-Anchor" href="#太阁立志传5"></a> 太阁立志传5</h2><p>自由度满分，做一个躺平散养的人，喝茶交友，四处乱逛，没有 KPI。</p><h2 id="最终幻想10"><a class="markdownIt-Anchor" href="#最终幻想10"></a> 最终幻想10</h2><p>很难想象当初顶着看不懂的日文玩到了最后，惊艳的 CG 和音乐，共情最深的 FF。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;豆瓣个人评分标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;五星：一见钟情，简直停不下来，必然多周目起步&lt;/li&gt;
&lt;li&gt;四星：依然优秀，但是相比五星存在无法忽略的缺点，可能会多周目&lt;/li&gt;
&lt;li&gt;三星：没什么吸引人的地方，大部分能坚持到一周目结束，基本不会多周目&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Game" scheme="https://frederick-s.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>为什么 Python 的负整数除法结果和 C 不同</title>
    <link href="https://frederick-s.github.io/2024/12/29/why-python&#39;s-integer-division-floors/"/>
    <id>https://frederick-s.github.io/2024/12/29/why-python&#39;s-integer-division-floors/</id>
    <published>2024-12-28T16:00:00.000Z</published>
    <updated>2024-12-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于整数-5除以2，在 <code>Python</code> 中的结果是-3，但是在 <code>C</code> 中是-2。如果扩展到其他几种常见的语言，可以看到和 <code>C</code> 一致的比较多：</p><table><thead><tr><th>语言</th><th>结果</th></tr></thead><tbody><tr><td>C</td><td>-2</td></tr><tr><td>C++</td><td>-2</td></tr><tr><td>Java</td><td>-2</td></tr><tr><td>C#</td><td>-2</td></tr><tr><td>Rust</td><td>-2</td></tr><tr><td>Go</td><td>-2</td></tr><tr><td>Python</td><td>-3</td></tr><tr><td>Ruby</td><td>-3</td></tr></tbody></table><p>区别在于对于结果-2.5是选择向0取整还是向负无穷取整，<code>Python</code> 和 <code>Ruby</code> 选择了后者。</p><p>对于整数 <code>a</code> 和 <code>n</code>，记 <code>a</code> 除以 <code>n</code> 的结果是 <code>q</code>，余数是 <code>r</code>，则有：<code>a = n * q + r</code>，其中 <code>|r| &lt; |n|</code>。在数论中，<code>r</code> 始终是正数，但是不同的编程语言各自有不同的实现。</p><blockquote><p>In number theory, the positive remainder is always chosen, but in computing, programming languages choose depending on the language and the signs of a or n.</p></blockquote><h2 id="编程语言实现"><a class="markdownIt-Anchor" href="#编程语言实现"></a> 编程语言实现</h2><h3 id="truncated-division"><a class="markdownIt-Anchor" href="#truncated-division"></a> Truncated division</h3><p>很多语言采用这种实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>n</mi><mi>c</mi><mo stretchy="false">(</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = trunc(\frac{a}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，其中 <code>trunc</code> 表示向0取整，代表语言如 <code>Java</code>。</p><h3 id="floored-division"><a class="markdownIt-Anchor" href="#floored-division"></a> Floored division</h3><p><code>Donald Knuth</code> 提倡这种实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">q = \lfloor \frac{a}{n} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>，即向下取整，代表语言如 <code>Python</code>。</p><h3 id="euclidean-division"><a class="markdownIt-Anchor" href="#euclidean-division"></a> Euclidean division</h3><p><code>Raymond T. Boute</code> 则提倡这种实现，约定：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo>=</mo><mi>s</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mrow><mi mathvariant="normal">∣</mi><mi>n</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌋</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>if n &gt; 0</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">⌈</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌉</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>if n &lt; 0</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">q = sgn(n)\lfloor \frac{a}{|n|} \rfloor =         \begin{cases}      \lfloor \frac{a}{n} \rfloor &amp; \text{if n &gt; 0}\\      \lceil \frac{a}{n} \rceil &amp; \text{if n &lt; 0}    \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0435600000000003em;vertical-align:-0.936em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal">n</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if n &gt; 0</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if n &lt; 0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>即根据 <code>n</code> 的正负号来判断是向下取整还是向上取整，代表语言如 <code>ABAP</code>。</p><h3 id="rounded-division"><a class="markdownIt-Anchor" href="#rounded-division"></a> Rounded division</h3><p>这是 <code>Common Lisp</code> 和 <code>IEEE 754</code> 采用的实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = round(\frac{a}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，其中 <code>round</code> 使用 <code>rounding half to even</code>，即在常规的取整之外，对于1.5，2.5，x.5这样的数字取整到最近的偶数，例如6.5取整到6，7.5取整到8。</p><h3 id="ceiling-division"><a class="markdownIt-Anchor" href="#ceiling-division"></a> Ceiling division</h3><p>这是 <code>Common Lisp</code> 提供的另一种实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">⌈</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">q = \lceil \frac{a}{n} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>，即向上取整。</p><h2 id="python-实现"><a class="markdownIt-Anchor" href="#python-实现"></a> Python 实现</h2><p>回到 <code>Python</code>，很难说上述哪种实现一定最优，<code>Python</code> 的作者提到采用 <code>floored division</code> 是因为对于某些应用来说，如果取模运算返回负数没有意义。例如，给定一个 <code>POSIX timestamp</code>，如何返回该天的时间部分，即时分秒？因为一天有86400秒，假设时间戳是 <code>t</code>，那么 <code>t % 86400</code> 就表示该天过了多少秒，就可以进一步转化为时分秒。而对于在 <code>1970-01-01T00:00:00Z</code> 之前的日期，<code>t</code> 则是负数，采用 <code>floored division</code> 的情况下 <code>t % 86400</code> 依然返回正数，并且结果也是正确的，而 <code>truncated division</code> 则返回负数，需要应用程序进一步处理。</p><p>不过，一种编程语言中不一定只提供一种实现，其他实现可以借助函数库。例如，<code>Python</code> 中 <code>-5 % 2</code> 结果是1，实现方式为 <code>floored division</code>，但是 <code>math.fmod(-5, 2)</code> 结果是-1，实现方式为 <code>truncated division</code>。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html">Why Python’s Integer Division Floors</a></li><li><a href="https://en.wikipedia.org/wiki/Modulo">Modulo</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于整数-5除以2，在 &lt;code&gt;Python&lt;/code&gt; 中的结果是-3，但是在 &lt;code&gt;C&lt;/code&gt; 中是-2。如果扩展到其他几种常见的语言，可以看到和 &lt;code&gt;C&lt;/code&gt; 一致的比较多：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://frederick-s.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Snowflake 配置 S3 Storage Integration</title>
    <link href="https://frederick-s.github.io/2024/03/31/snowflake-storage-integration-with-s3/"/>
    <id>https://frederick-s.github.io/2024/03/31/snowflake-storage-integration-with-s3/</id>
    <published>2024-03-30T16:00:00.000Z</published>
    <updated>2024-03-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>Snowflake</code> 的 <code>Data Loading</code> 和 <code>Data Unloading</code> 可以通过 <code>S3</code> 导入和导出数据。用户可以使用 <code>AWS_KEY_ID</code> 和 <code>AWS_SECRET_KEY</code> 来授权 <code>Snowflake</code> 访问 <code>S3</code>，不过出于安全和权限控制的考虑，一般不会这么做。</p><p><code>Snowflake</code> 建议通过 <code>Storage Integration</code> 来管理权限。</p><h2 id="获取-vpc-id"><a class="markdownIt-Anchor" href="#获取-vpc-id"></a> 获取 VPC ID</h2><p>在配置 <code>Storage Integration</code> 前，需要设置 <code>S3</code> 策略。首先获取 <code>Snowflake</code> 的 <code>VPC ID</code>，后续的 <code>S3</code> 策略配置中将只允许该 <code>VPC</code> 访问。</p><blockquote><p>允许特定 VPC 访问的功能要求 Snowflake 实例和对应的 S3 Bucket 运行在相同的 AWS 区域内。</p></blockquote><p>切换到 <code>ACCOUNTADMIN</code> 角色在 <code>Snowflake</code> 中执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE ROLE ACCOUNTADMIN;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SYSTEM</span>$GET_SNOWFLAKE_PLATFORM_INFO();</span><br></pre></td></tr></table></figure><p>记录下返回的 <code>VPC ID</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;snowflake-vpc-id&quot;:[&quot;vpc-abc&quot;]&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-iam-策略"><a class="markdownIt-Anchor" href="#创建-iam-策略"></a> 创建 IAM 策略</h2><p>然后，需要创建一个 <code>S3</code> 策略来定义 <code>Snowflake</code> 访问 <code>S3 Bucket</code> 的权限。</p><p>从 <code>AWS</code> 控制台进入 <code>IAM</code>，在左侧导航栏 <code>Access management</code> 下选择 <code>Account settings</code>：</p><p><img src="/images/snowflake-1.png" alt="alt" /></p><p>在 <code>Security Token Service (STS)</code> 下查看所在区域的 <code>STS</code> 状态是否是 <code>Active</code>：</p><p><img src="/images/snowflake-2.png" alt="alt" /></p><p>接着，在左侧导航栏 <code>Access management</code> 下选择 <code>Policies</code>，之后点击 <code>Create policy</code>：</p><p><img src="/images/snowflake-3.png" alt="alt" /></p><p>切换到 <code>JSON</code> 后输入 <code>S3</code> 策略：</p><p><img src="/images/snowflake-4.png" alt="alt" /></p><p>下面的策略中 <code>vpc-abc</code> 是 <code>Snowflake</code> 实例的 <code>VPC</code>，<code>snowflake-storage-integration-example</code> 是示例 <code>Bucket</code> 的名字，<code>unloading</code> 和 <code>loading</code> 是该 <code>Bucket</code> 下的两个文件夹，分别用于 <code>Data Unloading</code> 和 <code>Data Loading</code> 使用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Statement1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;s3:PutObject&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;s3:GetObject&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;s3:GetObjectVersion&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;s3:DeleteObject&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;s3:DeleteObjectVersion&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;arn:aws:s3:::snowflake-storage-integration-example/unloading/*&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;arn:aws:s3:::snowflake-storage-integration-example/loading/*&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;StringEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;aws:SourceVpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vpc-abc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Statement2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;s3:ListBucket&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;s3:GetBucketLocation&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;arn:aws:s3:::snowflake-storage-integration-example&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;StringLike&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;s3:prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;unloading/*&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;loading/*&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;StringEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;aws:SourceVpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vpc-abc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="创建-iam-角色"><a class="markdownIt-Anchor" href="#创建-iam-角色"></a> 创建 IAM 角色</h2><p>接着，创建一个 <code>IAM</code> 角色并绑定前一步创建的 <code>S3</code> 策略。在 <code>IAM</code> 左侧导航栏 <code>Access management</code> 下选择 <code>Roles</code>，之后点击 <code>Create role</code>：</p><p><img src="/images/snowflake-5.png" alt="alt" /></p><p><code>Trusted entity type</code> 选择 <code>AWS account</code>，然后在 <code>An AWS account</code> 下选择 <code>Another AWS account</code>，<code>Account ID</code> 暂时先填当前账号的 <code>ID</code>，之后会修改：</p><p><img src="/images/snowflake-6.png" alt="alt" /></p><p>同时，选择 <code>Require external ID (Best practice when a third party will assume this role)</code>，<code>External ID</code> 暂时用一个假的例如 <code>0000</code> 替代，之后同样会修改：</p><p><img src="/images/snowflake-7.png" alt="alt" /></p><p>最后绑定先前创建的 <code>S3</code> 策略：</p><p><img src="/images/snowflake-8.png" alt="alt" /></p><p>创建角色之后，记录下角色的 <code>ARN</code>，接下来会用到：</p><p><img src="/images/snowflake-9.png" alt="alt" /></p><h2 id="创建-storage-integration"><a class="markdownIt-Anchor" href="#创建-storage-integration"></a> 创建 Storage Integration</h2><p>这时就可以在 <code>Snowflake</code> 中创建 <code>Storage Integration</code> 了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> STORAGE INTEGRATION snowflake_storage_integration_example</span><br><span class="line">  TYPE <span class="operator">=</span> EXTERNAL_STAGE</span><br><span class="line">  STORAGE_PROVIDER <span class="operator">=</span> <span class="string">&#x27;S3&#x27;</span></span><br><span class="line">  ENABLED <span class="operator">=</span> <span class="literal">TRUE</span></span><br><span class="line">  STORAGE_AWS_ROLE_ARN <span class="operator">=</span> <span class="string">&#x27;arn:aws:iam::123:role/snowflake-integration-role&#x27;</span></span><br><span class="line">  STORAGE_ALLOWED_LOCATIONS <span class="operator">=</span> (<span class="string">&#x27;s3://snowflake-storage-integration-example/loading/&#x27;</span>, <span class="string">&#x27;s3://snowflake-storage-integration-example/unloading/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>STORAGE_AWS_ROLE_ARN</code> 是之前所创建的 <code>IAM</code> 角色的 <code>ARN</code>，<code>STORAGE_ALLOWED_LOCATIONS</code> 是示例 <code>Bucket</code> 下的两个文件夹的地址。</p><blockquote><p>只有授权了 <code>CREATE INTEGRATION</code> 权限的角色才能创建 <code>STORAGE INTEGRATION</code>，默认只有 <code>ACCOUNTADMIN</code> 才有这个权限。</p></blockquote><h2 id="获取-snowflake-的用户-arn-和-external-id"><a class="markdownIt-Anchor" href="#获取-snowflake-的用户-arn-和-external-id"></a> 获取 Snowflake 的用户 ARN 和 External ID</h2><p>接着需要获取所创建的 <code>Storage Integration</code> 对应的 <code>Snowflake</code> <code>IAM</code> 用户的 <code>ARN</code> 和 <code>External ID</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> integration snowflake_storage_integration_example;</span><br></pre></td></tr></table></figure><p><img src="/images/snowflake-10.png" alt="alt" /></p><p>记录下 <code>STORAGE_AWS_IAM_USER_ARN</code> 和 <code>STORAGE_AWS_EXTERNAL_ID</code>。</p><h2 id="授权-snowflake-用户"><a class="markdownIt-Anchor" href="#授权-snowflake-用户"></a> 授权 Snowflake 用户</h2><p>回到之前创建的 <code>IAM</code> 角色，在 <code>Trust relationships</code> 下替换掉之前填写的临时 <code>Account ID</code> 和 <code>External ID</code>：</p><p><img src="/images/snowflake-11.png" alt="alt" /></p><p><img src="/images/snowflake-12.png" alt="alt" /></p><p>完成后，我们就可以执行一条 <code>Data Unloading</code> 命令来验证配置是否成功：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> <span class="keyword">into</span> <span class="string">&#x27;s3://snowflake-storage-integration-example/unloading/&#x27;</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> OBJECT_CONSTRUCT_KEEP_NULL(<span class="operator">*</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> MY_DATABASE.MY_SCHEMA.MY_TABLE limit <span class="number">10</span>))</span><br><span class="line">FILE_FORMAT <span class="operator">=</span> (type <span class="operator">=</span> json, COMPRESSION <span class="operator">=</span> <span class="keyword">NONE</span>)</span><br><span class="line">STORAGE_INTEGRATION <span class="operator">=</span> snowflake_storage_integration_example</span><br></pre></td></tr></table></figure><p>如果配置成功，那么 <code>Snowflake</code> 会将表 <code>MY_DATABASE.MY_SCHEMA.MY_TABLE</code> 的数据导出到 <code>s3://snowflake-storage-integration-example/unloading/</code> 文件夹下。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://docs.snowflake.com/en/user-guide/data-load-s3-allow">Allowing the Virtual Private Cloud IDs</a></li><li><a href="https://docs.snowflake.com/en/user-guide/data-load-s3-config-storage-integration">Option 1: Configuring a Snowflake storage integration to access Amazon S3</a></li><li><a href="https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration">CREATE STORAGE INTEGRATION</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Snowflake&lt;/code&gt; 的 &lt;code&gt;Data Loading&lt;/code&gt; 和 &lt;code&gt;Data Unloadin</summary>
      
    
    
    
    
    <category term="Snowflake" scheme="https://frederick-s.github.io/tags/Snowflake/"/>
    
  </entry>
  
  <entry>
    <title>【读】Newton 科学世界 - 就诊指南</title>
    <link href="https://frederick-s.github.io/2024/03/03/hospital/"/>
    <id>https://frederick-s.github.io/2024/03/03/hospital/</id>
    <published>2024-03-02T16:00:00.000Z</published>
    <updated>2024-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻到了一本压箱底的 <code>Newton 科学世界</code>，本期主题为 <code>就诊指南</code>，大概整理了一下，<a href="https://1drv.ms/u/s!AgP1jNp0kP4-1kMaeBvVo1xntEtm?e=yYWOFm">源文件</a>。</p><p><img src="/images/%E5%B0%B1%E8%AF%8A%E6%8C%87%E5%8D%97.png" alt="alt" /></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li>Newton 科学世界（2022.5）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻到了一本压箱底的 &lt;code&gt;Newton 科学世界&lt;/code&gt;，本期主题为 &lt;code&gt;就诊指南&lt;/code&gt;，大概整理了一下，&lt;a href=&quot;https://1drv.ms/u/s!AgP1jNp0kP4-1kMaeBvVo1xntEtm?e=yYWOFm&quot;&gt;源文</summary>
      
    
    
    
    
    <category term="Reading" scheme="https://frederick-s.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>【读】17 REASONS NOT TO BE A MANAGER</title>
    <link href="https://frederick-s.github.io/2023/08/12/17-reasons-not-to-be-a-manager/"/>
    <id>https://frederick-s.github.io/2023/08/12/17-reasons-not-to-be-a-manager/</id>
    <published>2023-08-11T16:00:00.000Z</published>
    <updated>2023-08-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>这是一篇出现在 <code>Hacker News</code> 上的文章，作者阐述了关于不当管理者的17个理由。</p><h2 id="17个理由"><a class="markdownIt-Anchor" href="#17个理由"></a> 17个理由</h2><h3 id="1-你热爱你所做的事"><a class="markdownIt-Anchor" href="#1-你热爱你所做的事"></a> 1. 你热爱你所做的事</h3><ul><li>你会为能亲自实现某个功能而兴奋不已吗？</li><li>你会时而在敲完一天代码后开心的哼着小曲下班吗？</li><li>你会为过去所实现的功能、达成的成就感到自豪吗？</li></ul><p>如果是的话，那么你是一个幸运的打工人。永远不要低估一颗热爱工作的心，同时也不要想当然的认为无论何时都能重拾这份热爱。</p><h3 id="2-找到一份工程师的工作很简单"><a class="markdownIt-Anchor" href="#2-找到一份工程师的工作很简单"></a> 2. 找到一份工程师的工作很简单</h3><p>在裁员时代，这点已经不再简单。不过在同等条件下，工程师岗位相对于管理者岗位来说：</p><ul><li>技能更能够量化，仅从通过面试来说，一部分技能甚至可以在面试过程中不断学习强化</li><li>除了特定行业外，工程师的技能一般不和公司深度绑定。在上一家公司培养的技能并不会因为换了家公司就基本没用；而管理者在上一家公司与各团队构建的信任关系则一般无法带到下一家公司，或者换了一家公司后，需要应对未曾遇到的人员关系</li></ul><h3 id="3-管理者岗位僧多粥少"><a class="markdownIt-Anchor" href="#3-管理者岗位僧多粥少"></a> 3. 管理者岗位僧多粥少</h3><p>管理者岗位一个萝卜一个坑，其招聘数量远少于工程师岗位。</p><h3 id="4-管理者最先被炒鱿鱼"><a class="markdownIt-Anchor" href="#4-管理者最先被炒鱿鱼"></a> 4. 管理者最先被炒鱿鱼</h3><p>如果真要裁员，光裁管理者是不够的，工程师反而有天然的【人数优势】。</p><p>除非是一锅端，否则各部门按比例的裁员场景下，应该不会有管理者自告奋勇的说自己产生不了直接价值，底下的人离开我也能转，裁我吧。</p><h3 id="5-管理者不易跳槽"><a class="markdownIt-Anchor" href="#5-管理者不易跳槽"></a> 5. 管理者不易跳槽</h3><p>除开管理者岗位本身的原因，年龄也有一定的影响，但这不仅仅针对管理者。管理者的年龄一般比下属的工程师大，即使一个工程师在年轻的时候可以一年两跳，到了管理者同样的年纪也可能会变得不容易跳槽。</p><h3 id="6-工程师会看轻管理者"><a class="markdownIt-Anchor" href="#6-工程师会看轻管理者"></a> 6. 工程师会看轻管理者</h3><p>大家都是打工的，没有必要谁看不起谁。当然也会有唯技术论的工程师，无视技术之外的一切；但同样的，也有始终认为自己是主子的管理者，这种，自然是没有必要迎合的。</p><p>那么，管理者需不需要懂技术？如果是放权型管理者，能安心将技术决策委托给核心工程师，是可以不用懂技术的，从而专注发挥好自己的管理长处。不过，这属于可遇不可求的情况，现实中没有那么多的刘备和孔明。虽然作者和他的同事们讨论后都认为所遇到的优秀的管理者都不懂技术，但是优秀的管理者本身是比优秀的工程师更为稀缺的存在。所以，对于一般的管理者，至少在技术上要能认识到十个女人一个月真的生不出孩子。</p><h3 id="7-管理者有时候要当坏人"><a class="markdownIt-Anchor" href="#7-管理者有时候要当坏人"></a> 7. 管理者有时候要当坏人</h3><p>身为管理者，难免会遇到以下的情况：</p><ul><li>绩效有人要背 C</li><li>裁员指标</li><li>传达上头不合理的要求</li></ul><p>而并不是所有人都愿意和能合理的处理好这些场景。</p><h3 id="8-管理者的技能树比你想象中的要少"><a class="markdownIt-Anchor" href="#8-管理者的技能树比你想象中的要少"></a> 8. 管理者的技能树比你想象中的要少</h3><p>如果从工程师切到了管理者，可能会觉得自己一直在飘着，不再是实际的执行者，这对于某些工程师来说可能会比较难受。而另一方面，立志往管理线发展的人可能会更乐于去做引导一个产品或项目落地的过程，对实际执行并不太关心，并在这期间逐步提高自己的影响力。</p><p>我认为这里能体现管理者水平的地方包含但不限于如何处理：</p><ul><li>你的目标对你很重要，但对其他人不重要</li><li>你有雄心壮志，但其他人只想安分守己</li></ul><h3 id="9-做得好是你的本分做不好是你的锅"><a class="markdownIt-Anchor" href="#9-做得好是你的本分做不好是你的锅"></a> 9. 做得好是你的本分，做不好是你的锅</h3><p>大和田老师在半泽直树1里说过：</p><blockquote><p>下属的功劳是上司的功绩，上司的过错是下属的责任</p></blockquote><p>做不好又能把锅甩出去也是管理的一种能力。</p><h3 id="10-你需要以-ic-的身份和管理者分庭抗礼"><a class="markdownIt-Anchor" href="#10-你需要以-ic-的身份和管理者分庭抗礼"></a> 10. 你需要以 IC 的身份和管理者分庭抗礼</h3><p><code>IC</code> 全称 <code>Individual Contributor</code>，常见翻译为独立贡献者或个人贡献者。<code>IC</code> 最明显的特点是没有管理职责，注意不等同于没有管理工作，他们利用自己的专业水平协同或者独立完成任务，最终可能成为某一方面的专家。</p><p><code>IC</code> 也分等级，例如 <code>Dropbox</code> 的软件工程师职位就划分为了 <code>IC1</code> 到 <code>IC7</code>，而管理者岗位则是 <code>M</code> 线。高级的 <code>IC</code> 也会有管理工作，例如项目管理（高级 <code>IC</code> 负责的项目很可能已经不是自己能独立完成的了）或者人员管理（什么地方用什么样的人）。</p><p>这里作者认为需要有能够发声的高级 <code>IC</code>，因为他们毕竟还是 <code>IC</code> 线，他们所代表的利益有时也符合普通工程师的利益。如果高级 <code>IC</code> 最终都转到了管理岗，那么本来就人微言轻的普通工程师的利益也更难传达到上层。不过，这也要求公司有能够让高级 <code>IC</code> 开花结果的土壤。</p><h3 id="11-管理只是一系列技能你同样能以-ic-的身份去尝试所有有趣的管理工作"><a class="markdownIt-Anchor" href="#11-管理只是一系列技能你同样能以-ic-的身份去尝试所有有趣的管理工作"></a> 11. 管理只是一系列技能，你同样能以 <code>IC</code> 的身份去尝试所有有趣的管理工作</h3><p>随着在 <code>IC</code> 路线上的成长，你会逐渐涉及一些技术之外的管理工作。有人可能就会乐于去尝试这些管理工作，例如担任导师，面试，参与决策，制定职业规划等。作者认为一个健康的公司应当鼓励并允许高级 <code>IC</code> 去参与这些工作。这样就避免了参与管理者职责中的一些不讨喜的活，例如绩效考核，裁人等。</p><h3 id="12-更难从工作中感到愉悦"><a class="markdownIt-Anchor" href="#12-更难从工作中感到愉悦"></a> 12. 更难从工作中感到愉悦</h3><p>修复一个问题或者学习新知识所带来的愉悦可能就此一去不复返，同时，工作中的正反馈周期也可能变长。</p><p>不过，这也因人而异，那些享受改完一个高深 <code>Bug</code> 的工程师可能根本不会想着做管理，而有些做管理的人也可能根本不认为改完一个高深的 <code>Bug</code> 是种享受，他们的愉悦点可能在于来自底下的服从。</p><h3 id="13-情绪影响会衍生甚至占据你的个人生活"><a class="markdownIt-Anchor" href="#13-情绪影响会衍生甚至占据你的个人生活"></a> 13. 情绪影响会衍生甚至占据你的个人生活</h3><p>身为管理者后，会与更多的人打交道，而人不是一个确定的个体，每个人有各自的行为处世，你可能会觉得更心累。</p><h3 id="14-你的时间不再属于你"><a class="markdownIt-Anchor" href="#14-你的时间不再属于你"></a> 14. 你的时间不再属于你</h3><p>普通工程师的时间都不能够一定保证，管理者可能更甚。</p><h3 id="15-会议"><a class="markdownIt-Anchor" href="#15-会议"></a> 15. 会议</h3><p>更恐怖的是无尽的低效会议。</p><h3 id="16-如果你的心之所向是技术引领"><a class="markdownIt-Anchor" href="#16-如果你的心之所向是技术引领"></a> 16. 如果你的心之所向是技术引领</h3><p>成为管理者后，你的做事方式就转变为了影响团队，提高团队。你的技术水平也会因此停滞不前，然后逐渐衰退。如果你认为这是一种折磨，那么你就不适合成为管理者。</p><h3 id="17-管理者岗位始终会等着你"><a class="markdownIt-Anchor" href="#17-管理者岗位始终会等着你"></a> 17. 管理者岗位始终会等着你</h3><p>即使是技术路线越往上走也越会要涉及管理工作，如果你不在乎一个头衔，又何必急于一时。</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>理想的情况下自然是合适的人在合适的位置上，不过现实中也会有赶鸭子上架而做了管理者的人，或者为了延长自己的职业寿命而无奈转了管理者。但无论如何，管理并不是一个想当然的工作，并不是因为工程师干不下去了所以到时候就转管理，这既不尊重管理岗位本身，也不尊重团队中的其他人，只会多一个不靠谱的管理者，而不靠谱的管理者比不靠谱的工程师更糟糕。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://charity.wtf/2019/09/08/reasons-not-to-be-a-manager/">17 REASONS NOT TO BE A MANAGER</a></li><li><a href="https://dropbox.github.io/dbx-career-framework/overview.html">Dropbox Engineering Career Framework</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;这是一篇出现在 &lt;code&gt;Hacker News&lt;/code&gt; 上的文章，作者阐述了关于不当管理者的17个理由。&lt;/p&gt;
&lt;h2 id=&quot;17</summary>
      
    
    
    
    
    <category term="Opinions" scheme="https://frederick-s.github.io/tags/Opinions/"/>
    
  </entry>
  
  <entry>
    <title>通过 Grafana Agent 上传 Prometheus 指标数据到 Grafana Cloud</title>
    <link href="https://frederick-s.github.io/2023/03/12/grafana-agent-remote-write-/"/>
    <id>https://frederick-s.github.io/2023/03/12/grafana-agent-remote-write-/</id>
    <published>2023-03-11T16:00:00.000Z</published>
    <updated>2023-03-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>Grafana Cloud</code> 为免费账户提供了一万条指标的存储额度，对于业余项目来说可以考虑将指标上传到由 <code>Grafana Cloud</code> 托管的 <code>Prometheus</code> 中。</p><h2 id="安装-grafana-agent"><a class="markdownIt-Anchor" href="#安装-grafana-agent"></a> 安装 Grafana Agent</h2><p><code>Prometheus</code> 指标数据的上传需要通过 <code>Grafana Agent</code> 来完成，以下安装步骤以 <code>Ubuntu</code> 为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/apt/keyrings/</span><br><span class="line">wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo <span class="built_in">tee</span> /etc/apt/keyrings/grafana.gpg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/grafana.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grafana-agent</span><br></pre></td></tr></table></figure><p>安装完成之后通过 <code>sudo systemctl start grafana-agent</code> 将其启动，并可通过 <code>sudo systemctl status grafana-agent</code> 显示 <code>grafana-agent</code> 的当前状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● grafana-agent.service - Monitoring system and forwarder</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/grafana-agent.service; disabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sun 2023-03-12 05:08:43 UTC; 13s ago</span><br><span class="line">       Docs: https://grafana.com/docs/agent/latest/</span><br><span class="line">   Main PID: 1049084 (grafana-agent)</span><br><span class="line">      Tasks: 7 (limit: 1041)</span><br><span class="line">     Memory: 125.6M</span><br><span class="line">     CGroup: /system.slice/grafana-agent.service</span><br><span class="line">             └─1049084 /usr/bin/grafana-agent --config.file /etc/grafana-agent.yaml -server.http.address=127.0.0.1:9090 -server.grpc.address=127.0.0.1:9091</span><br><span class="line"></span><br><span class="line">Mar 12 05:08:43 example-name systemd[1]: Started Monitoring system and forwarder.</span><br></pre></td></tr></table></figure><p>同时，如果希望系统重启后自动启动 <code>grafana-agent</code> 服务，可以执行如下的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> grafana-agent.service</span><br></pre></td></tr></table></figure><p>另外，可以通过 <code>sudo journalctl -u grafana-agent</code> 查看 <code>grafana-agent</code> 的运行日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Logs begin at Sun 2021-12-26 04:48:21 UTC, end at Sun 2023-03-12 06:34:53 UTC. --</span><br><span class="line">Mar 12 05:08:43 example-name systemd[1]: Started Monitoring system and forwarder.</span><br><span class="line">Mar 12 05:38:45 example-name grafana-agent[1049084]: ts=2023-03-12T05:38:45.6366501Z caller=cleaner.go:203 level=warn agent=prometheus component=cleaner msg=&quot;unable to fi&gt;</span><br><span class="line">Mar 12 06:08:45 example-name grafana-agent[1049084]: ts=2023-03-12T06:08:45.63549564Z caller=cleaner.go:203 level=warn agent=prometheus component=cleaner msg=&quot;unable to f&gt;</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: Stopping Monitoring system and forwarder...</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: grafana-agent.service: Succeeded.</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: Stopped Monitoring system and forwarder.</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: Started Monitoring system and forwarder.</span><br></pre></td></tr></table></figure><h2 id="上报监控数据"><a class="markdownIt-Anchor" href="#上报监控数据"></a> 上报监控数据</h2><p><code>grafana-agent</code> 上报的监控数据分两种，一种是 <code>grafana-agent</code> 自身及其所在主机的监控数据，另一种是自定义服务的监控数据，我们需要修改 <code>grafana-agent</code> 的配置文件来指定如何收集监控数据。</p><p><code>grafana-agent</code> 的默认配置文件为 <code>/etc/grafana-agent.yaml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Sample config for Grafana Agent</span><br><span class="line"># For a full configuration reference, see: https://grafana.com/docs/agent/latest/configuration/.</span><br><span class="line">server:</span><br><span class="line">  log_level: warn</span><br><span class="line"></span><br><span class="line">metrics:</span><br><span class="line">  global:</span><br><span class="line">    scrape_interval: 1m</span><br><span class="line">  wal_directory: &#x27;/var/lib/grafana-agent&#x27;</span><br><span class="line">  configs:</span><br><span class="line">    # Example Prometheus scrape configuration to scrape the agent itself for metrics.</span><br><span class="line">    # This is not needed if the agent integration is enabled.</span><br><span class="line">    # - name: agent</span><br><span class="line">    #   host_filter: false</span><br><span class="line">    #   scrape_configs:</span><br><span class="line">    #     - job_name: agent</span><br><span class="line">    #       static_configs:</span><br><span class="line">    #         - targets: [&#x27;127.0.0.1:9090&#x27;]</span><br><span class="line"></span><br><span class="line">integrations:</span><br><span class="line">  agent:</span><br><span class="line">    enabled: true</span><br><span class="line">  node_exporter:</span><br><span class="line">    enabled: true</span><br><span class="line">    include_exporter_metrics: true</span><br><span class="line">    disable_collectors:</span><br><span class="line">      - &quot;mdadm&quot;</span><br></pre></td></tr></table></figure><p>自定义服务的监控数据收集需要定义在 <code>metrics.configs</code> 下，<code>grafana-agent</code> 自身及其所在主机的监控数据收集默认已经是开启的。</p><p>假设需要收集由 <code>Spring Boot</code> 的 <code>actuator</code> 模块所暴露的 <code>Prometheus</code> 监控数据，则需要在 <code>metrics.configs</code> 下新增如下类似配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">  scrape_configs:</span><br><span class="line">    - job_name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">      metrics_path: &#x27;/actuator/prometheus&#x27;</span><br><span class="line">      scrape_interval: 1m</span><br><span class="line">      static_configs:</span><br><span class="line">        - targets: [&#x27;127.0.0.1:8080&#x27;]</span><br><span class="line">          labels:</span><br><span class="line">            application: &#x27;My Spring Boot App&#x27;</span><br></pre></td></tr></table></figure><p>最后，再通过 <code>remote_write</code> 设置将监控数据推送到 <code>Grafana Cloud</code> 下的 <code>Prometheus</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remote_write:</span><br><span class="line">  - url: https://prometheus-xxx.grafana.net/api/prom/push</span><br><span class="line">    basic_auth:</span><br><span class="line">      username: username</span><br><span class="line">      password: password</span><br></pre></td></tr></table></figure><p>其中 <code>url</code>，<code>username</code> 和 <code>password</code> 这三个信息都可以在所创建的 <code>Grafana Cloud Stack</code> 下的 <code>Prometheus</code> 的详情页中找到。<code>password</code> 对应 <code>Grafana Cloud API Key</code>，如果之前没有创建过的话需要新生成一个，角色选择 <code>MetricsPublisher</code> 即可：</p><p><img src="/images/grafana-cloud-1.png" alt="alt" /></p><p>完整的配置文件示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  log_level: warn</span><br><span class="line"></span><br><span class="line">metrics:</span><br><span class="line">  global:</span><br><span class="line">    scrape_interval: 1m</span><br><span class="line">  wal_directory: &#x27;/var/lib/grafana-agent&#x27;</span><br><span class="line">  configs:</span><br><span class="line">    - name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">      scrape_configs:</span><br><span class="line">        - job_name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">          metrics_path: &#x27;/actuator/prometheus&#x27;</span><br><span class="line">          scrape_interval: 1m</span><br><span class="line">          static_configs:</span><br><span class="line">            - targets: [&#x27;127.0.0.1:8080&#x27;]</span><br><span class="line">              labels:</span><br><span class="line">                application: &#x27;My Spring Boot App&#x27;</span><br><span class="line">      remote_write:</span><br><span class="line">        - url: https://prometheus-xxx.grafana.net/api/prom/push</span><br><span class="line">          basic_auth:</span><br><span class="line">            username: username</span><br><span class="line">            password: password</span><br><span class="line"></span><br><span class="line">integrations:</span><br><span class="line">  agent:</span><br><span class="line">    enabled: true</span><br><span class="line">  node_exporter:</span><br><span class="line">    enabled: true</span><br><span class="line">    include_exporter_metrics: true</span><br><span class="line">    disable_collectors:</span><br><span class="line">      - &quot;mdadm&quot;</span><br><span class="line">  prometheus_remote_write:</span><br><span class="line">    - url: https://prometheus-xxx.grafana.net/api/prom/push</span><br><span class="line">      basic_auth:</span><br><span class="line">        username: username</span><br><span class="line">        password: password</span><br></pre></td></tr></table></figure><p>配置文件修改完成之后，通过 <code>sudo systemctl restart grafana-agent</code> 来重启 <code>grafana-agent</code> 服务。</p><h2 id="grafana-展示"><a class="markdownIt-Anchor" href="#grafana-展示"></a> Grafana 展示</h2><p>对于自定义服务的监控展示使用自己熟悉的方式即可，例如 <code>Java</code> 应用可以配合使用 <a href="https://grafana.com/grafana/dashboards/4701-jvm-micrometer/">JVM (Micrometer)</a>。</p><p>对于 <code>grafana-agent</code> 自身的监控展示可以结合 <a href="https://github.com/grafana/agent/blob/main/example/docker-compose/grafana/dashboards/agent-remote-write.json">agent-remote-write.json</a>：</p><p><img src="/images/grafana-cloud-2.png" alt="alt" /></p><p>最后，<code>grafana-agent</code> 对于所在主机的监控展示可以借助 <a href="https://grafana.com/grafana/dashboards/1860-node-exporter-full/">Node Exporter Full</a>：</p><p><img src="/images/grafana-cloud-3.png" alt="alt" /></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://grafana.com/docs/agent/latest/set-up/install-agent-linux/">Install Grafana Agent on Linux</a></li><li><a href="https://grafana.com/blog/2020/07/02/getting-started-with-the-grafana-cloud-agent-a-remote_write-focused-prometheus-agent/">Getting started with the Grafana Cloud Agent, a remote_write-focused Prometheus agent</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Grafana Cloud&lt;/code&gt; 为免费账户提供了一万条指标的存储额度，对于业余项目来说可以考虑将指标上传到由 &lt;code&gt;</summary>
      
    
    
    
    
    <category term="Grafana" scheme="https://frederick-s.github.io/tags/Grafana/"/>
    
    <category term="Prometheus" scheme="https://frederick-s.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>【读】Google API Design Guide</title>
    <link href="https://frederick-s.github.io/2022/12/26/google-api-design-guide/"/>
    <id>https://frederick-s.github.io/2022/12/26/google-api-design-guide/</id>
    <published>2022-12-25T16:00:00.000Z</published>
    <updated>2022-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><a href="https://cloud.google.com/apis/design">Google API Design Guide</a> 是 <code>Google</code> 设计 <a href="https://cloud.google.com/apis/docs/overview">Cloud APIs</a> 和其他 <a href="https://github.com/googleapis/googleapis">Google APIs</a> 的设计指南。</p><p>该指南面向的不仅仅是 <code>REST APIs</code>，同时也适用于 <code>RPC APIs</code>，其中 <code>RPC APIs</code> 主要面向的是 <code>gRPC APIs</code>。</p><h2 id="面向资源的设计"><a class="markdownIt-Anchor" href="#面向资源的设计"></a> 面向资源的设计</h2><p>传统的 <code>RPC</code> 接口设计面向的是操作，各个接口之间是孤立的，没有明确的关联；不同系统的接口也有着不同的设计风格，存在着一定的学习和使用成本。</p><p>而面向资源的设计则将系统抽象为一系列资源，开发者则通过有限的几个标准方法来操作资源，从而实现对系统的修改。对于 <code>RESTful</code> 接口来说，有限的几个标准方法对应的就是 <code>HTTP</code> 请求方法中的 <code>POST</code>，<code>GET</code>，<code>PUT</code>，<code>PATCH</code> 和 <code>DELETE</code>。另一方面，由于遵循了统一的设计，当开发者调用不同系统的接口时，能够自然的假定各个系统都支持相同的标准方法，从而降低了开发者学习的成本。</p><blockquote><p>不管是面向资源的设计还是其他的设计标准，统一的标准胜过百花齐放，开发者应当将更多的精力放在自身系统的业务实现上，而不是耗费时间学习和调试其他系统的接口。</p></blockquote><p>该指南建议按照如下的步骤设计面向资源的接口：</p><ul><li>确定接口所提供的资源类型</li><li>确定资源间的关系</li><li>根据资源类型和资源间的关系确定资源命名模式</li><li>确定资源体系</li><li>为每个资源设计最小限度的操作方法</li></ul><p>在面向资源的设计体系下，各接口一般会按照资源的层级结构进行组织，层级结构中的每个节点可能是单一的资源，也可能是一个资源集合：</p><ul><li>一个资源集合包含了一系列相同类型的资源，例如，一个用户拥有一个联系人资源集合</li><li>一个资源包含了若干的状态，同时也包含了0个或者多个子资源。每个子资源可以是一个单一资源或者是资源集合</li></ul><p>以创建邮件接口为例，传统的接口设计可能是如下的方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /createMail</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;userId&quot;: 123,</span><br><span class="line">    &quot;title:&quot; &quot;Title&quot;,</span><br><span class="line">    &quot;from&quot;: &quot;from@example.com&quot;</span><br><span class="line">    &quot;to&quot;: &quot;to@example.com&quot;,</span><br><span class="line">    &quot;body&quot;: &quot;Body&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而面向资源的接口设计则可能为：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /users/&#123;userId&#125;/mails</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;title:&quot; &quot;Title&quot;,</span><br><span class="line">    &quot;from&quot;: &quot;from@example.com&quot;</span><br><span class="line">    &quot;to&quot;: &quot;to@example.com&quot;,</span><br><span class="line">    &quot;body&quot;: &quot;Body&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，面向资源的接口设计体现了资源间的层级关系。一般而言，对于 <code>RESTful</code> 接口来说，请求 <code>URL</code> 中只会包含资源的名称（名词），而不会包含对资源的操作（动词），<code>HTTP</code> 的请求方法就对应了资源的标准操作方法。而该指南讨论的是通用的面向资源的设计，其对应的资源标准操作方法为：<code>List</code>，<code>Get</code>，<code>Create</code>，<code>Update</code> 和 <code>Delete</code>。</p><h2 id="资源名称"><a class="markdownIt-Anchor" href="#资源名称"></a> 资源名称</h2><p>在面向资源的设计下，资源是一个命名实体，每个资源都有一个唯一的名称作为其标识符。一个资源的名称由三部分组成：</p><ol><li>资源的 <code>ID</code></li><li>所有父资源的 <code>ID</code></li><li><code>API</code> 服务名，如 <code>gmail.googleapis.com</code></li></ol><p>资源集合被视为一种特殊的资源，它包含了一组相同类型的子资源，例如一个目录可以被视为一个资源集合，它包含了一组文件资源。同时，资源集合也有相应的 <code>ID</code>。</p><p>资源名称由资源 <code>ID</code> 和资源集合 <code>ID</code> 组成，其定义也体现了资源的层级结构关系，各层级之间使用 <code>/</code> 进行分隔。例如，对于某个对象存储服务中的对象来说，其资源名称可能为 <code>//storage.googleapis.com/buckets/bucket-123/objects/object-123</code>，其中最顶层为服务名，即 <code>//storage.googleapis.com</code>，然后是一个资源集合，即 <code>buckets</code>，对象存储服务一般以 <code>bucket</code> 为维度来管理对象；接下来为了要定位到某个对象，需要先定位到具体的 <code>bucket</code>，<code>bucket-123</code> 就是某个 <code>bucket</code> 的资源 <code>ID</code>，而每个 <code>bucket</code> 下包含了多个对象，进而产生了一个资源集合 <code>objects</code>，最后的 <code>object-123</code> 就是实际对象的资源 <code>ID</code>。</p><p>一般来说，一个资源在实现上很可能对应一张数据库的表，所以可以用表的主键来作为资源的 <code>ID</code>。而由于使用了 <code>/</code> 来分隔资源的层级，因此只有最底层的资源才允许资源 <code>ID</code> 中包含 <code>/</code>，从而避免层级歧义。</p><blockquote><p>如果资源 <code>ID</code> 中包含了 <code>/</code>，则必须在 <code>API</code> 文档中明确声明。</p></blockquote><p>资源集合更多的是一种层级上的逻辑概念，所以其 <code>ID</code> 命名需要有意义，以及符合以下的规范：</p><ol><li>必须是以小驼峰形式命名的英文单词复数，如果对应单词没有复数，则应当使用单词的单数形式</li><li>必须使用简洁明了的英文单词</li><li>避免使用过于宽泛的英文单词，例如，<code>rowValues</code> 优于 <code>values</code>。同时应当避免无条件的使用如下的英文单词：<ul><li>elements</li><li>entries</li><li>instances</li><li>items</li><li>objects</li><li>resources</li><li>types</li><li>values</li></ul></li></ol><blockquote><p>对于 <code>Google</code> 的服务来说，资源集合 <code>ID</code> 还会经常出现在自动生成的客户端类库代码中，所以它们的命名也必须是合法的 <code>C/C++</code> 标识符。</p></blockquote><p>完整的资源名称是协议无关的，虽然它看起来像 <code>RESTful</code> 服务的 <code>HTTP</code> 接口请求路径，但本质上这是两个东西。实际的资源请求还需要附带版本号，协议等信息，例如对于资源名称 <code>//calendar.googleapis.com/users/john smith/events/123</code> 来说，实际的 <code>RESTful</code> 请求路径可能是 <code>https://calendar.googleapis.com/v3/users/john%20smith/events/123</code>，和原本的资源名称相比有三点不同：</p><ol><li>指明了具体的协议，<code>HTTPS</code></li><li>指明了版本号，<code>v3</code></li><li>对资源名称进行了 <code>URL</code> 转义</li></ol><p><code>Google</code> 的 <code>API</code> 服务要求资源名称必须是字符串，除非有后向兼容的问题，资源名称在跨模块间传递时必须确保没有任何数据丢失。对于资源定义来说，第一个字段应该命名为 <code>name</code>，类型为字符串，用于表示资源的名称，以下是 <code>gRPC</code> 服务的定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 图书馆服务</span><br><span class="line">service LibraryService &#123;</span><br><span class="line">  // 获取一本书</span><br><span class="line">  rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 创建一本书</span><br><span class="line">  rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">      body: &quot;book&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源定义</span><br><span class="line">message Book &#123;</span><br><span class="line">  // 资源名称，必须以 &quot;shelves/*/books/*&quot; 的形式。</span><br><span class="line">  // 例如，&quot;shelves/shelf1/books/book2&quot;。</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // ... 其他属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取书籍请求</span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // 资源名称，例如 &quot;shelves/shelf1/books/book2&quot;。</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建书籍请求</span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // 父资源的名称，例如 &quot;shelves/shelf1&quot;。</span><br><span class="line">  string parent = 1;</span><br><span class="line">  // 需要创建的资源实体，客户端不允许设置 `Book.name` 属性。</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么这里资源的名称字段要定义为 <code>name</code> 而不是 <code>id</code>？首先从命名上来说 <code>name</code> 本身要比 <code>id</code> 更适合作为 <code>名称</code> 一词的命名。其次，<code>name</code> 也是一个较为宽泛的词语，例如文件资源的 <code>name</code> 代表的是文件的名称还是完整的路径？通过将 <code>name</code> 作为标准字段，使得开发人员必须要选择更适合的命名，例如 <code>display_name</code>，<code>title</code> 或者 <code>full_name</code>。</p></blockquote><p>为什么不直接使用资源 <code>ID</code> 来定位资源？一个系统中往往有多个资源，单纯的资源 <code>ID</code> 不具有辨识度以及缺少上下文信息。例如，如果使用数据库表的自增主键作为资源 <code>ID</code>，则无法简单的通过数字来定位资源。如果想要通过资源 <code>ID</code> 来定位资源，则势必要扩展资源 <code>ID</code> 的定义，例如使用元组来表示资源 <code>ID</code>，如 <code>(bucket, object)</code> 用于定位某个对象存储服务的对象。不过，这也带来了几个问题：</p><ol><li>对开发人员不友好，需要额外理解和记忆（例如不同资源 <code>ID</code> 的元组元素个数不同，每个元组元素代表的含义是什么）</li><li>解析元组比解析字符串更为困难</li><li>对基础设施组件不友好，例如日志和访问控制系统无法直接理解元组</li><li>限制了 <code>API</code> 设计的灵活性，如提供可复用的 <code>API</code> 接口</li></ol><h2 id="标准方法"><a class="markdownIt-Anchor" href="#标准方法"></a> 标准方法</h2><p>标准方法的作用在于为大多数的服务场景提供统一、易用的接口，超过 70% 的 <code>Google APIs</code> 都是标准方法。<code>Google APIs</code> 设计了5种标准方法：</p><ol><li><code>List</code></li><li><code>Get</code></li><li><code>Create</code></li><li><code>Update</code></li><li><code>Delete</code></li></ol><p>下表是标准方法和 <code>HTTP</code> 请求方法的映射：</p><table><thead><tr><th>标准方法</th><th><code>HTTP</code> 请求方法映射</th><th><code>HTTP</code> 请求体</th><th><code>HTTP</code> 响应体</th></tr></thead><tbody><tr><td>List</td><td>Get &lt;资源集合 <code>URL</code>&gt;</td><td>无</td><td>资源集合</td></tr><tr><td>Get</td><td>GET &lt;资源 <code>URL</code>&gt;</td><td>无</td><td>资源</td></tr><tr><td>Create</td><td>POST &lt;资源集合 <code>URL</code>&gt;</td><td>资源</td><td>资源</td></tr><tr><td>Update</td><td>PUT 或者 PATCH &lt;资源 <code>URL</code>&gt;</td><td>资源</td><td>资源</td></tr><tr><td>Delete</td><td>DELETE &lt;资源 <code>URL</code>&gt;</td><td>无</td><td>空</td></tr></tbody></table><blockquote><p><code>HTTP</code> 响应体返回的资源可能不会包含资源的全部字段，例如客户端请求时可以指定只返回需要的字段。<br />如果 <code>Delete</code> 操作不是立即删除资源，例如只是更新资源的某个字段标记删除或者是创建一个 <a href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto">长时间运行任务</a> 来删除资源，则 <code>HTTP</code> 响应体应该包含修改后的资源或者任务信息。</p></blockquote><h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3><p><code>List</code> 方法用于返回一系列同类的资源，同时该接口支持额外的参数从而允许只返回匹配的资源。它适合用于获取有限大小、未缓存的单一资源集合，对于更复杂的场景则可以考虑使用自定义方法中的 <code>Search</code> 接口。</p><p>如果想要批量获取资源，例如入参一组资源 <code>ID</code> 来返回每个资源 <code>ID</code> 所对应的资源，则应该考虑实现 <code>BatchGet</code> 的自定义方法，而不是在 <code>List</code> 方法上扩展。</p><p><code>List</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p><ul><li><code>List</code> 方法必须对应 <code>HTTP</code> 的 <code>GET</code> 请求</li><li><code>List</code> 方法的 <code>RPC</code> 请求消息体的 <code>name</code> 字段（也就是资源集合名称）应该和 <code>HTTP</code> 的请求路径匹配，如果相匹配，则 <code>HTTP</code> 请求路径的最后一个段必须是字面量（即资源集合 <code>ID</code>）</li><li><code>List</code> 方法的 <code>RPC</code> 请求消息体的其他字段应该和 <code>HTTP</code> 请求路径的查询参数相匹配</li><li>对应的 <code>HTTP</code> 请求无请求体；<code>List</code> 方法的 <code>API</code> 定义中不允许声明 <code>body</code> 语句</li><li><code>HTTP</code> 响应体应该包含一组资源及可选的元数据信息</li></ul><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 获取书架上的书</span><br><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">  // List 方法映射为 HTTP GET 请求</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // parent 对应父资源的名称，如 shelves/shelf1</span><br><span class="line">    get: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取书籍集合请求</span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // 父资源的名称，如shelves/shelf1</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // 返回资源的最大个数</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line"></span><br><span class="line">  // 返回第几页的资源集合，其值为前一个 List 请求返回的 next_page_token 字段</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取书籍集合响应</span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  // 返回的书籍资源集合，该字段名应该和方法名中的 Books 相匹配。其数量上限由 ListBooksRequest 中的 page_size 决定</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line"></span><br><span class="line">  // 下一页资源集合的页码信息，用于获取下一页的资源集合；没有下一页时为空</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> Get</h3><p><code>Get</code> 方法接收一个资源名称及其他参数来返回某个指定的资源。</p><p><code>Get</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p><ul><li><code>Get</code> 方法必须对应 <code>HTTP</code> 的 <code>GET</code> 请求</li><li><code>Get</code> 方法的 <code>RPC</code> 请求消息体的 <code>name</code> 字段（也就是资源名称）应该和 <code>HTTP</code> 的请求路径匹配</li><li><code>Get</code> 方法的 <code>RPC</code> 请求消息体的其他字段应该和 <code>HTTP</code> 请求路径的查询参数相匹配</li><li>对应的 <code>HTTP</code> 请求无请求体；<code>Get</code> 方法的 <code>API</code> 定义中不允许声明 <code>body</code> 语句</li><li><code>Get</code> 方法返回的资源实体应该和 <code>HTTP</code> 的整个响应体相匹配</li></ul><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取一本书</span><br><span class="line">rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">  // Get 方法映射为 HTTP GET 请求，资源名称映射到请求路径，无请求体</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // 所请求的资源名称，如 shelves/shelf1/books/book2</span><br><span class="line">    get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取单个书籍请求</span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // 所请求的资源名称，如 shelves/shelf1/books/book2</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="create"><a class="markdownIt-Anchor" href="#create"></a> Create</h3><p><code>Create</code> 方法接收一个父资源名称，一个资源实体，以及其他的参数来在指定的父资源下创建一个新的资源，并返回创建的资源。</p><p>如果某个 <code>API</code> 服务支持创建资源，则应当为每一类的资源创建对应的 <code>Create</code> 方法。</p><p><code>Create</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p><ul><li><code>Create</code> 方法必须对应 <code>HTTP</code> 的 <code>POST</code> 请求</li><li><code>Create</code> 方法的 <code>RPC</code> 请求消息体应当包含一个 <code>parent</code> 字段用于表示所创建的资源的父资源的名称</li><li><code>Create</code> 方法的 <code>RPC</code> 请求消息体中表示资源实体的各字段应当和 <code>HTTP</code> 请求体中的字段相对应。如果 <code>Create</code> 方法定义中标注了 <code>google.api.http</code>，则必须声明 <code>body: &quot;&lt;resource_field&gt;&quot;</code> 语句</li><li><code>Create</code> 方法的 <code>RPC</code> 请求消息体可能包含一个 <code>&lt;resource&gt;_id</code> 字段来允许调用方指定所创建的资源的 <code>id</code>。这个字段可能会包含在资源字段实体内</li><li><code>Create</code> 方法的其余参数应当和 <code>URL</code> 的查询参数相匹配</li><li><code>Create</code> 方法返回的资源实体应该和 <code>HTTP</code> 的整个响应体相匹配</li></ul><p>如果 <code>Create</code> 方法允许由调用方指定所创建的资源的名称，并且该资源已经存在，则该请求应当作失败处理并返回错误码 <code>ALREADY_EXISTS</code>；或者由服务端重新生成一个资源名称，并返回创建的资源，同时接口文档应当清晰的标注最终创建的资源的名称有可能和调用方传入的资源名称不同。</p><p><code>Create</code> 方法的 <code>RPC</code> 请求消息体中必须包含资源实体，这样当资源实体的定义发生变更时，就无需同时变更请求消息体的定义。如果资源实体中的某些字段无法由客户端设置，则必须将其标注为 <code>Output only</code> 字段。</p><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 在书架上创建一本书</span><br><span class="line">rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Create 方法对应 HTTP 的 POST 请求，URL 请求路径为资源集合名称</span><br><span class="line">  // HTTP 请求体中包含需要创建的资源</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // parent 对应父资源的名称，如 shelves/1</span><br><span class="line">    post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建书籍请求</span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // 父资源名称</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // 资源 id</span><br><span class="line">  string book_id = 3;</span><br><span class="line"></span><br><span class="line">  // 需要创建的资源</span><br><span class="line">  // 字段名称需要和 RPC 方法中的名词对应，即 book -&gt; Book</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个书架</span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1/shelves&quot;</span><br><span class="line">    body: &quot;shelf&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建书架请求</span><br><span class="line">message CreateShelfRequest &#123;</span><br><span class="line">  Shelf shelf = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update"><a class="markdownIt-Anchor" href="#update"></a> Update</h3><p><code>Update</code> 方法接收一个资源实体，以及其他的参数来更新指定的资源及其属性，并返回更新后的资源。</p><p>资源的可变属性应当能够通过 <code>Update</code> 方法修改，除非该属性包含资源的名称或父资源的名称。资源重命名或者将资源移动到另一个父资源下都不允许在 <code>Update</code> 方法中实现，而应当由自定义方法来实现。</p><p><code>Update</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p><ul><li>标准的 <code>Update</code> 方法应该能够支持更新资源的部分属性，并通过 <code>update_mask</code> 字段来指明需要更新的属性，对应的 <code>HTTP</code> 请求方法为 <code>PATCH</code>。资源实体中标注为 <code>Output only</code> 的属性应该在资源更新时忽略</li><li>如果要求 <code>Update</code> 方法实现更为高级的局部更新语义则应当将其作为自定义方法来实现，例如追加新值到资源的某个列表类型的属性上</li><li>如果 <code>Update</code> 方法不支持局部属性更新，则对应的 <code>HTTP</code> 请求方法必须是 <code>PUT</code>。不过不建议 <code>Update</code> 方法仅支持全局更新，因为后续如果为资源添加新的属性则可能会有后向兼容问题</li><li><code>Update</code> 方法的 <code>RPC</code> 请求消息体中表示资源名称的字段值必须和 <code>URL</code> 中的请求路径相匹配。这个资源名称字段可能包含在资源实体内</li><li><code>Update</code> 方法的 <code>RPC</code> 请求消息体中表示资源实体的各字段必须和 <code>HTTP</code> 请求体中的字段相对应</li><li><code>Update</code> 方法的其余参数必须和 <code>URL</code> 的查询参数相匹配</li><li><code>Update</code> 方法的返回结果必须是更新后的资源实体</li></ul><blockquote><p>既然 URL 中已经有了资源名称，为什么请求体里面还要再传一遍资源名称？关于这一点不同的服务有不同的实现，例如 <code>DigitalOcean</code> 的更新接口就不要求请求体中再传一遍 <code>id</code>：<a href="https://docs.digitalocean.com/reference/api/api-reference/#operation/apps_update">Update an App</a>。</p></blockquote><blockquote><p><code>Update</code> 方法的返回结果必须是更新后的资源实体看起来是多此一举，但是某些资源的属性必须由服务端来更新，例如资源的更新时间，或者对于 <code>Git</code> 服务来说文件更新后的版本号等等，这些属性更新后也需要返回给客户端。</p></blockquote><p>如果后端服务允许客户端指定资源名称则 <code>Update</code> 方法允许客户端调用时发送一个不存在的资源名称，然后服务端会自动创建一个新的资源。否则，<code>Update</code> 方法应当作失败处理并返回 <code>NOT_FOUND</code> 的错误码（如果这是唯一的错误的话）。</p><p>即使 <code>Update</code> 方法本身支持新建资源也应当提供额外的 <code>Create</code> 方法，否则服务的使用者可能会感到迷惑。</p><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 更新一本书</span><br><span class="line">rpc UpdateBook(UpdateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Update 方法对应 HTTP 的 PATCH 请求，资源名称映射到请求路径</span><br><span class="line">  // 资源实体包含在 HTTP 请求体中</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // 请求路径包含了需要更新的资源名称</span><br><span class="line">    patch: &quot;/v1/&#123;book.name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新书籍请求</span><br><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // 需要更新的书籍</span><br><span class="line">  Book book = 1;</span><br><span class="line"></span><br><span class="line">  // 指定需要更新的书籍属性，具体定义见 https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> Delete</h3><p><code>Delete</code> 方法接受一个资源名称和其他参数来删除或者计划删除某个指定的资源。<code>Delete</code> 方法返回的消息体类型应当为 <code>google.protobuf.Empty</code>。</p><p>服务调用方不应该依赖 <code>Delete</code> 方法返回的任何信息，因为 <code>Delete</code> 方法被重复调用时不一定每次都返回相同的信息。</p><p><code>Delete</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p><ul><li><code>Delete</code> 方法必须对应 <code>HTTP</code> 的 <code>DELETE</code> 请求</li><li><code>Delete</code> 方法的 <code>RPC</code> 请求消息体中表示资源名称的字段值应当和 <code>URL</code> 中的请求路径相匹配</li><li><code>Delete</code> 方法的其余参数应当和 <code>URL</code> 的查询参数相匹配</li><li>对应的 <code>HTTP</code> 请求无请求体；<code>Delete</code> 方法的 <code>API</code> 定义中不允许声明 <code>body</code> 语句</li><li>如果 <code>Delete</code> 方法在实现时是立即删除资源则该方法返回的消息体为空</li><li>如果 <code>Delete</code> 方法在实现时是创建一个 <a href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto">长时间运行任务</a> 来删除资源，则该方法返回的消息体应当为对应的任务信息</li><li>如果 <code>Delete</code> 方法在实现时仅将资源标记为删除而不是物理删除，则该方法应当返回更新后的资源</li></ul><p><code>Delete</code> 方法应当是幂等的，但并不要求每次都返回相同的信息。对同一个资源的多个 <code>Delete</code> 请求应当使得该资源（最终）被删除，不过只有第一个成功删除资源的请求应当返回相应的成功信息，其余的请求应当返回 <code>google.rpc.Code.NOT_FOUND</code> 错误码。</p><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 删除一本书</span><br><span class="line">rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) &#123;</span><br><span class="line">  // Delete 方法对应 HTTP 的 DELETE 请求，资源名称映射到请求路径，无 HTTP 请求体</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // 请求路径包含了需要删除的资源名称，例如 shelves/shelf1/books/book2</span><br><span class="line">    delete: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除书籍请求</span><br><span class="line">message DeleteBookRequest &#123;</span><br><span class="line">  // 需要被删除的资源名称，如 shelves/shelf1/books/book2</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义方法"><a class="markdownIt-Anchor" href="#自定义方法"></a> 自定义方法</h2><p>标准方法提供了对资源的基础操作功能，它们的职责都较为单一，基本上对应了基础的 <code>CRUD</code> 操作。不过，并不是所有对资源的操作都能或者适合抽象为 <code>CRUD</code> 操作，这也是对于 <code>RESTful</code> 风格的服务经常争论的地方。因此，自定义方法就应运而生。</p><p>不过，对于 <code>API</code> 的设计者而言应当尽可能的首选使用标准方法，因为标准方法有着更为统一的语义，对开发者而言更为简单易懂。</p><p>自定义方法可以应用于资源，资源集合或者服务。它可能会接收任意类型的输入和返回任意类型的输出，并且支持流式的请求和响应。</p><h3 id="http-请求映射"><a class="markdownIt-Anchor" href="#http-请求映射"></a> HTTP 请求映射</h3><p>对于自定义方法来说，应当使用如下的 <code>HTTP</code> 请求映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://service.name/v1/some/resource/name:customVerb</span><br></pre></td></tr></table></figure><p>这里之所以选择 <code>:</code> 而不是 <code>/</code> 将 <code>name</code> 和 <code>customVerb</code> 分开是为了支持 <code>name</code> 中包含 <code>/</code> 的情况，例如将文件路径作为资源名称时则获取资源的请求可能为 <code>GET /files/a/long/file/name</code>，则撤销对该文件的删除操作所对应的自定义方法可能为 <code>POST /files/a/long/file/name:undelete</code>，如果 <code>undelete</code> 前用 <code>/</code> 分割则无法识别完整的资源名称。</p><p>自定义方法和 <code>HTTP</code> 请求的映射关系应当遵循如下规则：</p><ul><li>自定义方法应当使用 <code>HTTP</code> 请求的 <code>POST</code> 方法，除非该自定义方法是作为标准方法中的 <code>List</code> 或者 <code>Get</code> 方法的扩展，此时可以使用 <code>HTTP</code> 请求的 <code>GET</code> 方法</li><li>自定义方法不应该使用 <code>HTTP</code> 请求的 <code>PATCH</code> 方法，但是可以使用其他 <code>HTTP</code> 请求方法</li><li>对于使用 <code>HTTP</code> 请求的 <code>GET</code> 方法的自定义方法来说必须保证接口的幂等性</li><li>自定义方法的 <code>RPC</code> 请求消息体中表示资源或者资源集合名称的字段值应当和 <code>URL</code> 中的请求路径相匹配</li><li><code>HTTP</code> 请求的路径必须以 <code>:customVerb</code> 的形式结尾</li><li>如果自定义方法对应的 <code>HTTP</code> 请求方法允许 <code>HTTP</code> 请求体（如 <code>POST</code>，<code>PUT</code>，<code>PATCH</code> 或者自定义的 <code>HTTP</code> 方法），则该自定义方法的 <code>HTTP</code> 配置中必须声明 <code>body: &quot;*&quot;</code> 语句，并且 <code>RPC</code> 消息体中的剩余字段应当和 <code>HTTP</code> 请求体中的字段相匹配</li><li>如果自定义方法对应的 <code>HTTP</code> 请求方法不接受 <code>HTTP</code> 请求体（如 <code>GET</code>，<code>DELETE</code>），则该自定义方法的 <code>HTTP</code> 配置中不允许声明 <code>body</code> 语句，并且 <code>RPC</code> 消息体中的剩余字段应当和 <code>URL</code> 的查询参数相匹配</li></ul><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 服务级别的自定义方法</span><br><span class="line">rpc Watch(WatchRequest) returns (WatchResponse) &#123;</span><br><span class="line">  // 对应 HTTP 的 POST 请求，所有请求参数都来自于 HTTP 的请求体</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1:watch&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源集合级别的自定义方法</span><br><span class="line">rpc ClearEvents(ClearEventsRequest) returns (ClearEventsResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/events:clear&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源级别的自定义方法</span><br><span class="line">rpc CancelEvent(CancelEventRequest) returns (CancelEventResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/&#123;name=events/*&#125;:cancel&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个批量获取资源的自定义方法</span><br><span class="line">rpc BatchGetEvents(BatchGetEventsRequest) returns (BatchGetEventsResponse) &#123;</span><br><span class="line">  // 对应 HTTP 的 GET 请求</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v3/events:batchGet&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><p>以下是一些自定义方法比标准方法更适合的场景：</p><ul><li>重启一台虚拟机：其中一种反直觉的设计是在重启资源集合下创建一个重启资源，这属于生搬硬套；或者为虚拟机增加一个状态字段，重启操作就等价于资源的局部更新操作，即将虚拟机的状态由 <code>RUNNING</code> 改为 <code>RESTARTING</code>，虽然看似合理但是增加了使用人员的心智负担，例如除了这两种状态之外还有其他什么状态？另一方面也增加了接口实现的复杂度，标准方法的 <code>Update</code> 接口需要额外针对状态字段进行逻辑处理，违背了单一职责原则</li><li>批处理：对于性能敏感的场景而言，提供批处理的自定义方法比一系列独立的标准方法可能有着更好的性能</li></ul><blockquote><p>对于 <code>RESTful</code> 服务的争论中最常提到的例子就是如何使用 <code>RESTful</code> 接口表示注册/登陆？注册/登陆并不适合作为标准方法来实现，使用自定义方法会更好。一般而言，标准方法的实现应当尽量简单直白，一旦需要对标准方法扩展处理额外的逻辑，就需要考虑是否使用自定义方法更合适。</p></blockquote><h2 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h2><p>错误处理是 <code>RESTful</code> 又一个争论的点，即业务错误可能有很多，<code>HTTP</code> 的状态码根本不够，以及业务的状态码不应该和协议层的状态码相混淆。</p><h3 id="错误模型"><a class="markdownIt-Anchor" href="#错误模型"></a> 错误模型</h3><p><code>Google API</code> 将错误统一封装为 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto">google.rpc.Status</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package google.rpc;</span><br><span class="line"></span><br><span class="line">// 适用于不同编程环境的统一错误模型，包括 REST 接口和 RPC 接口</span><br><span class="line">message Status &#123;</span><br><span class="line">  // 错误码，具体错误码的定义见 google.rpc.Code</span><br><span class="line">  int32 code = 1;</span><br><span class="line"></span><br><span class="line">  // 错误信息，对错误原因的描述以及可能的修复方式</span><br><span class="line">  string message = 2;</span><br><span class="line"></span><br><span class="line">  // 错误的详细信息，开发人员可以通过详细信息找到一些有用的信息</span><br><span class="line">  repeated google.protobuf.Any details = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于大部分的 <code>Google APIs</code> 都是面向资源的设计，错误处理同样遵循了这样的设计，即使用一系列的标准错误来应对大多数的资源错误场景。例如使用标准的 <code>google.rpc.Code.NOT_FOUND</code> 错误来统一表示某个资源不存在，而不是为每一个资源定义一个 <code>SOME_RESOURCE_NOT_FOUND</code> 错误。</p><h4 id="错误码"><a class="markdownIt-Anchor" href="#错误码"></a> 错误码</h4><p><code>Google APIs</code> 必须使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto">google.rpc.Code</a> 中定义的错误码，不允许独自额外定义错误码。</p><h4 id="错误信息"><a class="markdownIt-Anchor" href="#错误信息"></a> 错误信息</h4><p>错误信息应当能够帮助用户简单快速的理解和解决 <code>API</code> 错误。一般而言，描述错误信息可以遵循如下的规则：</p><ul><li>不要假设用户是你所开发的服务的专家，他们可能是客户端开发者，运维人员，<code>IT</code> 人员以及应用的终端用户</li><li>不要假设用户知晓你所开发的服务任何的实现细节，或者熟悉错误的上下文</li><li>尽可能的使得错误信息有助于技术用户（不一定是服务的开发人员）响应错误并修正</li><li>保持错误信息简洁。如果可能的话在错误信息中提供一个帮助链接，以便于用户能够提问，反馈或者查找一些有用的信息</li></ul><blockquote><p>错误信息可能会随时变动，应用开发人员不应该强依赖错误信息。</p></blockquote><h4 id="错误详情"><a class="markdownIt-Anchor" href="#错误详情"></a> 错误详情</h4><p><code>Google APIs</code> 定义了一些列标准的 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto">错误详情</a>，这些错误详情覆盖了大部分的错误场景，例如配额分配失败以及无效的参数等等。和错误码一样，开发人员应当尽可能的优先使用标准的错误详情。</p><p>只有当错误详情有助于应用代码处理错误的情况下才应该考虑引入新的错误详情。如果当前错误只能由人工处理，则应依据错误信息由开发人员处理，而不是引入额外的错误详情。</p><p>以下是一些错误详情类型的例子：</p><ul><li><code>ErrorInfo</code>：提供稳定又可扩展的结构化错误信息</li><li><code>RetryInfo</code>：告诉客户端什么时候可以对一个失败的请求进行重试，可能随错误码 <code>Code.UNAVAILABLE</code> 或者 <code>Code.ABORTED</code> 返回</li><li><code>QuotaFailure</code>：描述为什么配额分配失败了，可能随错误码 <code>Code.RESOURCE_EXHAUSTED</code> 返回</li><li><code>BadRequest</code>：客户端请求参数非法，可能随错误码 <code>Code.INVALID_ARGUMENT</code> 返回</li></ul><h3 id="错误映射"><a class="markdownIt-Anchor" href="#错误映射"></a> 错误映射</h3><p><code>Google APIs</code> 会被不同的编程环境访问，每个环境有自己的错误处理方式，所以需要将前面描述的错误模型对各个编程环境进行适配和映射。</p><h4 id="http-映射"><a class="markdownIt-Anchor" href="#http-映射"></a> HTTP 映射</h4><p>对于 <code>HTTP</code> 接口来说，出于后向兼容性的考虑，<code>Google APIs</code> 定义了如下的错误模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 适用于 JSON HTTP 接口的错误模型</span><br><span class="line">message Error &#123;</span><br><span class="line">  // 废弃字段，仅用于 v1 格式的错误</span><br><span class="line">  message ErrorProto &#123;&#125;</span><br><span class="line">  // 和 `google.rpc.Status 有着相同的语义，出于和 Google API Client</span><br><span class="line">  // Libraries 后向兼容的考虑多了额外的 status 和 errors 字段</span><br><span class="line">  message Status &#123;</span><br><span class="line">    // 错误码，同时也是 HTTP 状态码，对应 google.rpc.Status.code</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    // 错误信息，对应 google.rpc.Status.message</span><br><span class="line">    string message = 2;</span><br><span class="line">    // 废弃字段，仅用于 v1 格式的错误</span><br><span class="line">    repeated ErrorProto errors = 3;</span><br><span class="line">    // 错误码的枚举值，对应 google.rpc.Status.code</span><br><span class="line">    google.rpc.Code status = 4;</span><br><span class="line">    // 错误详情，对应 google.rpc.Status.details</span><br><span class="line">    repeated google.protobuf.Any details = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  // 实际的错误消息体，之所以要额外包一层也是出于和 Google API Client</span><br><span class="line">  // Libraries 后向兼容的考虑，同时对于开发人员来说错误信息的可读性更高</span><br><span class="line">  Status error = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: 400,</span><br><span class="line">    &quot;message&quot;: &quot;API key not valid. Please pass a valid API key.&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;INVALID_ARGUMENT&quot;,</span><br><span class="line">    &quot;details&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;type.googleapis.com/google.rpc.ErrorInfo&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;API_KEY_INVALID&quot;,</span><br><span class="line">        &quot;domain&quot;: &quot;googleapis.com&quot;,</span><br><span class="line">        &quot;metadata&quot;: &#123;</span><br><span class="line">          &quot;service&quot;: &quot;translate.googleapis.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grpc-映射"><a class="markdownIt-Anchor" href="#grpc-映射"></a> gRPC 映射</h4><p>不同的 <code>RPC</code> 协议有着不同的错误处理模式，对于 <code>gRPC</code> 来说，上述的错误模型在各语言自动生成的代码中已经天然支持。</p><h4 id="客户端类库映射"><a class="markdownIt-Anchor" href="#客户端类库映射"></a> 客户端类库映射</h4><p>不同的编程语言对于错误处理有着不同的准则，客户端类库会尽量去适配这些准则，例如 <code>google-cloud-go</code> 遇到错误时会返回和 <code>google.rpc.Status</code> 实现了同样接口的错误，而 <code>google-cloud-java</code> 则会直接抛出错误。</p><h3 id="错误处理-2"><a class="markdownIt-Anchor" href="#错误处理-2"></a> 错误处理</h3><p>下表列出了 <code>google.rpc.Code</code> 定义的所有错误码：</p><table><thead><tr><th>HTTP</th><th>gRPC</th></tr></thead><tbody><tr><td>200</td><td>OK</td></tr><tr><td>400</td><td>INVALID_ARGUMENT</td></tr><tr><td>400</td><td>FAILED_PRECONDITION</td></tr><tr><td>400</td><td>OUT_OF_RANGE</td></tr><tr><td>401</td><td>UNAUTHENTICATED</td></tr><tr><td>403</td><td>PERMISSION_DENIED</td></tr><tr><td>404</td><td>NOT_FOUND</td></tr><tr><td>409</td><td>ABORTED</td></tr><tr><td>409</td><td>ALREADY_EXISTS</td></tr><tr><td>429</td><td>RESOURCE_EXHAUSTED</td></tr><tr><td>499</td><td>CANCELLED</td></tr><tr><td>500</td><td>DATA_LOSS</td></tr><tr><td>500</td><td>UNKNOWN</td></tr><tr><td>500</td><td>INTERNAL</td></tr><tr><td>501</td><td>NOT_IMPLEMENTED</td></tr><tr><td>502</td><td>N/A</td></tr><tr><td>503</td><td>UNAVAILABLE</td></tr><tr><td>504</td><td>DEADLINE_EXCEEDED</td></tr></tbody></table><blockquote><p>Google APIs 可能会并发的检查 API 请求是否满足条件，返回某个错误码不代表其他条件都符合要求，应用代码不应该依赖条件检查的顺序。</p></blockquote><p>可以看到，即使是相同的 <code>HTTP</code> 状态码其代表的含义也是不同的，此时就需要 <code>status</code> 字段来进一步区分，类似于将所有错误划分几个大类，然后在每个大类中再细分小类，相比于单纯用 <code>HTTP</code> 状态码来表示不同的错误来说更加灵活，扩展性也更好。</p><p>与之相对的非 <code>RESTful</code> 做法则是 <code>HTTP</code> 状态码永远返回200，在返回的消息体中定义错误码和错误信息，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &quot;some data&quot;,</span><br><span class="line">  &quot;code&quot;: 123,</span><br><span class="line">  &quot;message&quot;: &quot;something is wrong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重试错误"><a class="markdownIt-Anchor" href="#重试错误"></a> 重试错误</h4><p>对于 <code>503 UNAVAILABLE</code> 错误客户端可以采用 <code>exponential backoff</code> 的方式进行重试，最短重试等待时间应该是1秒，以及默认重试次数应当是1次，除非文档有特别说明。</p><p>对于 <code>429 RESOURCE_EXHAUSTED</code> 错误客户端可以等待更长的时间进行重试，不过最短的等待时间应当是30秒。这种重试仅对于长时间运行任务有效。</p><p>对于其他的错误，重试可能就不太适合。</p><h4 id="错误传播"><a class="markdownIt-Anchor" href="#错误传播"></a> 错误传播</h4><p>如果当前服务依赖于其他服务，则不应该直接将其他服务的错误返回给客户端。在进行错误转换时建议：</p><ul><li>隐藏实现的细节及机密的信息</li><li>调整负责该错误的一方，例如当前服务从其他服务收到 <code>INVALID_ARGUMENT</code> 错误时则返回 <code>INTERNAL</code> 错误给客户端</li></ul><h4 id="错误重现"><a class="markdownIt-Anchor" href="#错误重现"></a> 错误重现</h4><p>如果通过日志分析和监控无法解决错误，则应该尝试通过简单、可重复的测试来重现错误。</p><h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2><h3 id="空响应"><a class="markdownIt-Anchor" href="#空响应"></a> 空响应</h3><p>标准方法中的 <code>Delete</code> 方法应当返回 <code>google.protobuf.Empty</code>，除非 <code>Delete</code> 执行的是软删除，此时应当返回更新后的资源实体。</p><p>对于自定义方法来说，应当返回各自的 <code>XxxResponse</code> 消息体，因为即使该方法现在没有数据返回随着时间的推移有很大的可能会增加额外的字段。</p><h3 id="范围表示"><a class="markdownIt-Anchor" href="#范围表示"></a> 范围表示</h3><p>表示范围的字段应当使用左闭右开的区间，并以 <code>[start_xxx, end_xxx)</code> 的形式命名，例如 <code>[start_key, end_key)</code> 或者 <code>[start_time, end_time)</code>。<code>API</code> 应当避免其他形式的范围表示，如 <code>(index, count)</code> 或者 <code>[first, last]</code>。</p><h3 id="资源标签"><a class="markdownIt-Anchor" href="#资源标签"></a> 资源标签</h3><p>在面向资源的 <code>API</code> 设计下，资源的模式由 <code>API</code> 决定。为了让客户端能够给资源添加自定义的元数据（例如标记某台虚拟机为数据库服务器），资源定义中应当添加一个 <code>map&lt;string, string&gt; labels</code> 字段，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  map&lt;string, string&gt; labels = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长时间运行操作"><a class="markdownIt-Anchor" href="#长时间运行操作"></a> 长时间运行操作</h3><p>如果某个 <code>API</code> 方法需要很长时间才能完成，则该方法应该设计成返回一个长时间运行操作资源给客户端，客户端可以通过这个资源来跟踪方法的执行进展及获取执行结果。<a href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto">Operation</a> 定义了标准的接口来处理长时间运行操作，各 <code>API</code> 不允许自行定义额外的长时间运行操作接口以避免不一致。</p><p>长时间运行操作资源必须以响应消息体的方式返回给客户端，并且该操作的任何直接结果都应该反应到其他 <code>API</code> 中。例如，如果有一个长时间运行操作用于创建资源，即使该资源未创建完成，<code>LIST</code> 和 <code>GET</code> 标准方法也应该返回该资源，只是该资源会被标记为暂未就绪。当长时间操作完成时，<code>Operation.response</code> 字段应当包含该操作的执行结果。</p><p>长时间运行操作可以通过 <code>Operation.metadata</code> 字段来反馈其运行进展。<code>API</code> 在实现时应当为 <code>Operation.metadata</code> 定义消息类型，即使在一开始的实现中不会填充 <code>metadata</code> 字段。</p><h3 id="list-方法分页"><a class="markdownIt-Anchor" href="#list-方法分页"></a> List 方法分页</h3><p>支持 <code>List</code> 方法的资源集合应当支持分页功能，即使该方法返回的结果集很小。</p><p>因为如果一开始 <code>List</code> 方法不支持分页，后续增加分页功能就会使得和原有 <code>API</code> 的行为不一致。客户端在不知道 <code>List</code> 方法使用分页的情况下依然会认为该方法返回的是完整的资源集合，而实际上有可能只是返回了第一页的资源。</p><blockquote><p>为了兼容旧的逻辑，只能将分页信息设为非必要字段。</p></blockquote><p>为了支持 <code>List</code> 方法的分页功能，<code>API</code> 应当：</p><ul><li>在 <code>List</code> 方法的请求消息中定义 <code>string</code> 类型的 <code>page_token</code> 字段。客户端通过该字段来获取指定某页的资源</li><li>在 <code>List</code> 方法的请求消息中定义 <code>int32</code> 类型的 <code>page_size</code> 字段。客户端通过该字段来指定每页返回的最大数据量。对于服务端来说，可能会为客户端传入的 <code>page_size</code> 大小设置一个上限。如果 <code>page_size</code> 的值为0，则由服务端来决定需要返回多少数据</li><li>在 <code>List</code> 方法的响应消息中定义 <code>string</code> 类型的 <code>next_page_token</code> 字段。客户端通过该字段来获取下一页的资源，如果 <code>next_page_token</code> 的值为 <code>&quot;&quot;</code>，则表示没有下一页的资源</li></ul><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string parent = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有分页的实现可能会在响应消息中增加一个 <code>int32</code> 类型的 <code>total_size</code> 字段来表示资源的总个数。</p><h3 id="查询子资源集合"><a class="markdownIt-Anchor" href="#查询子资源集合"></a> 查询子资源集合</h3><p>有时候客户端可能会希望有一个 <code>API</code> 能够在多个子资源集合间查询资源。例如，某个图书馆 <code>API</code> 有一个书架的资源集合，每个书架包含一个书籍资源集合，客户端可能会希望在多个书架之间搜索某本书。这种情况建议对子资源使用标准的 <code>List</code> 方法，并使用通配符 <code>-</code> 来表示父资源集合，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books?filter=xxx</span><br></pre></td></tr></table></figure><h3 id="从子资源集合获取唯一资源"><a class="markdownIt-Anchor" href="#从子资源集合获取唯一资源"></a> 从子资源集合获取唯一资源</h3><p>有时候某个子资源集合下的资源在全局父资源下有着唯一的标识符。常规的做法是需要先知道该资源的父资源的名称然后才能获取该资源，这种情况建议对该资源使用标准的 <code>Get</code> 方法，并使用通配符 <code>-</code> 来表示父资源集合。例如，如果某本书在所有的书架上有着唯一的标识符，那么可以使用如下的请求来获取该本书籍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>另外，该接口返回的资源名称必须是完整的，其父资源名称必须返回实际的值，而不是 <code>-</code>，例如上述的请求应该返回资源名称 <code>shelves/shelf713/books/book8141</code>，而不是 <code>shelves/-/books/book8141</code>。</p><h3 id="排序顺序"><a class="markdownIt-Anchor" href="#排序顺序"></a> 排序顺序</h3><p>如果某个 <code>API</code> 允许客户端指定资源的排序顺序，则请求消息体中应该包含一个 <code>order_by</code> 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string order_by = ...;</span><br></pre></td></tr></table></figure><p><code>order_by</code> 应当遵循 <code>SQL</code> 语法：即使用逗号分割多个字段，例如 <code>&quot;foo,bar&quot;</code>。默认的排序规则是升序，如果需要降序排序，则应当在字段名后增加 <code>&quot; desc&quot;</code> 后缀，例如 <code>&quot;foo desc,bar&quot;</code>。</p><p>同时，字段间额外的空格是无关紧要的，例如 <code>&quot;foo,bar desc&quot;</code> 和 <code>&quot;  foo ,  bar  desc  &quot;</code> 是等价的。</p><h3 id="请求验证"><a class="markdownIt-Anchor" href="#请求验证"></a> 请求验证</h3><p>如果某个 <code>API</code> 有副作用并且需要在执行前验证请求是否有效，则请求消息体中应该包含一个 <code>validate_only</code> 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool validate_only = ...;</span><br></pre></td></tr></table></figure><p>如果设置为 <code>true</code>，则该 <code>API</code> 收到请求时仅进行验证而不会实际执行。</p><p>如果验证通过，则必须返回 <code>google.rpc.Code.OK</code> 给客户端，并且对于任何有着相同参数的请求都不应该返回 <code>google.rpc.Code.INVALID_ARGUMENT</code> 错误。不过该 <code>API</code> 依然有可能返回其他错误例如 <code>google.rpc.Code.ALREADY_EXISTS</code>。</p><h3 id="请求去重"><a class="markdownIt-Anchor" href="#请求去重"></a> 请求去重</h3><p>对于网络 <code>API</code> 来说首选幂等的 <code>API</code>，因为当发生网络异常时可以安全的重试。不过某些 <code>API</code> 无法轻易的实现幂等，例如创建一个资源，但是又需要避免重复的请求。这种情况下请求消息体应该包含一个唯一的 <code>ID</code>，例如 <code>UUID</code> 使得服务端能够通过这个唯一的 <code>ID</code> 进行去重：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 服务端根据此唯一的 ID 进行去重</span><br><span class="line">// 该字段应当命名为 request_id</span><br><span class="line">string request_id = ...;</span><br></pre></td></tr></table></figure><p>当服务端监测到重复的请求时，服务端应当返回之前成功的相同请求的结果给客户端，因为客户端大概率没有收到之前的返回结果。</p><h3 id="枚举默认值"><a class="markdownIt-Anchor" href="#枚举默认值"></a> 枚举默认值</h3><p>每一个枚举的定义都必须以0作为起始值，当枚举值未明确时应当使用该0值，同时 <code>API</code> 文档必须标注如何处理0值。</p><p>枚举0值应当命名为 <code>ENUM_TYPE_UNSPECIFIED</code>。如果 <code>API</code> 有着通用的默认行为，则枚举值未定义时应当使用0值，否则0值应当被拒绝并返回 <code>INVALID_ARGUMENT</code> 错误。</p><p>枚举值示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Isolation &#123;</span><br><span class="line">  // 未定义</span><br><span class="line">  ISOLATION_UNSPECIFIED = 0;</span><br><span class="line">  // 从快照读取数据，如果当前所有的读写操作与并发执行中的事务无法做到逻辑串行执行则发生冲突</span><br><span class="line">  SERIALIZABLE = 1;</span><br><span class="line">  // 从快照读取数据，如果当前有并发执行中的事务写入到相同的行则发生冲突</span><br><span class="line">  SNAPSHOT = 2;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当隔离级别未定义时，服务端可能会采用 SNAPSHOT 或者更优的隔离级别</span><br><span class="line">Isolation level = 1;</span><br></pre></td></tr></table></figure><p>在某些情况下可能使用某个惯用名表示枚举0值，例如 <code>google.rpc.Code.OK</code> 是错误码不存在时的默认值，它在语义上等价于 <code>UNSPECIFIED</code>。</p><h3 id="语法规则"><a class="markdownIt-Anchor" href="#语法规则"></a> 语法规则</h3><p>在某些场景下，需要为特定的数据格式定义简单的语法，例如允许接受的文本输入。为了在各 <code>API</code> 间提供一致的开发体验，<code>API</code> 设计者必须使用如下的 <code>Extended Backus-Naur Form (EBNF)</code> 的变种来定义语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Production  = name &quot;=&quot; [ Expression ] &quot;;&quot; ;</span><br><span class="line">Expression  = Alternative &#123; &quot;|&quot; Alternative &#125; ;</span><br><span class="line">Alternative = Term &#123; Term &#125; ;</span><br><span class="line">Term        = name | TOKEN | Group | Option | Repetition ;</span><br><span class="line">Group       = &quot;(&quot; Expression &quot;)&quot; ;</span><br><span class="line">Option      = &quot;[&quot; Expression &quot;]&quot; ;</span><br><span class="line">Repetition  = &quot;&#123;&quot; Expression &quot;&#125;&quot; ;</span><br></pre></td></tr></table></figure><h3 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h3><p>设计 <code>API</code> 时应当避免使用无符号整型例如 <code>uint32</code> 和 <code>fixed32</code>，因为某些重要的编程语言或者系统不能很好的支持无符号整型，例如 <code>Java</code>，<code>JavaScript</code> 和 <code>OpenAPI</code>，并且它们很大可能会造成整型溢出错误。另一个问题是不同的 <code>API</code> 可能将同一个值各自解析为不同的无符号整型或者带符号整型。</p><p>在某些场景下类型为带符号整型的字段值如果是负数则没有意义，例如大小，超时时间等等；<code>API</code> 设计者可能会用-1（并且只有-1）来表示特殊的含义，例如文件结束符（<code>EOF</code>），无限的超时时间，无限的配额或者未知的年龄等等。这种用法必须明确的在接口文档中标注以避免迷惑。同时 <code>API</code> 设计者也应当标注当整型数值为0时的系统行为，如果它不是非常直白明了的话。</p><h3 id="局部响应"><a class="markdownIt-Anchor" href="#局部响应"></a> 局部响应</h3><p>在某些情况下，客户端可能只希望获取资源的部分属性。<code>Google API</code> 通过 <code>FieldMask</code> 来支持这一场景。</p><p>对于任意 <code>Google API</code> 的 <code>REST</code> 接口，客户端都可以传入额外的 <code>$fields</code> 参数来表明需要获取哪些字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves?$fields=shelves.name</span><br><span class="line">GET https://library.googleapis.com/v1/shelves/123?$fields=name</span><br></pre></td></tr></table></figure><h3 id="资源视图"><a class="markdownIt-Anchor" href="#资源视图"></a> 资源视图</h3><p>为了减少网络传输，可以允许客户端指定需要返回资源的某个视图而不是完整的资源数据，这需要在请求消息体中增加一个额外的参数，该参数要求：</p><ul><li>应该是 <code>enum</code> 类型</li><li>必须命名为 <code>view</code></li></ul><p>枚举类型的每一个值都定义了应当返回资源的哪部分数据。具体返回哪部分数据由实现决定并且应当在文档中标注。</p><p>接口定义示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*&#125;/books&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum BookView &#123;</span><br><span class="line">  // 未定义，等同于 BASIC</span><br><span class="line">  BOOK_VIEW_UNSPECIFIED = 0;</span><br><span class="line"></span><br><span class="line">  // 默认视图，仅返回作者，标题，ISBN 和书籍 ID</span><br><span class="line">  BASIC = 1;</span><br><span class="line"></span><br><span class="line">  // 完整视图，返回书籍的全部数据，包括书籍的内容</span><br><span class="line">  FULL = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // 指定需要返回书籍的哪个视图</span><br><span class="line">  BookView view = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端就可以通过如下的方式调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/shelf1/books?view=BASIC</span><br></pre></td></tr></table></figure><h3 id="etags"><a class="markdownIt-Anchor" href="#etags"></a> ETags</h3><p><code>ETag</code> 用于客户端进行条件请求，例如客户端获取了某个资源后将其缓存，下次再请求相同的资源时附带上之前服务端返回的 <code>ETag</code>，如果服务端判断 <code>ETag</code> 没有发生变化则无需返回完整的资源实体。为了支持 <code>ETag</code>，应当在资源定义时添加 <code>etag</code> 字段，同时其语义应当同 <code>ETag</code> 的常见用法保持一致。</p><p><code>ETag</code> 支持强校验和弱校验，弱校验时 <code>ETag</code> 的值需要添加前缀 <code>W/</code>。强校验模式下，如果两个资源有着相同的 <code>ETag</code> 则说明这两个资源的每个字节都是相同的，而且有着相同的额外字段（例如 <code>Content-Type</code>）。这表示强校验模式下获取的多个资源局部响应数据可以组合成为一个完整的资源数据。</p><p>相反的，弱校验模式下两个资源有着相同的 <code>ETag</code> 并不能说明两个资源的每一个字节都相同，因此不适合用于缓存字节范围的请求响应。</p><p>强弱 <code>ETag</code> 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 强 ETag，包括引号</span><br><span class="line">&quot;1a2f3e4d5b6c7c&quot;</span><br><span class="line">// 弱 ETag，包括前缀和引号</span><br><span class="line">W/&quot;1a2b3c4d5ef&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是，引号也是 <code>ETag</code> 的一部分，所以如果 <code>ETag</code> 在 <code>JSON</code> 中表示需要对引号进行转义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 强</span><br><span class="line">&#123; &quot;etag&quot;: &quot;\&quot;1a2f3e4d5b6c7c\&quot;&quot;, &quot;name&quot;: &quot;...&quot;, ... &#125;</span><br><span class="line">// 弱</span><br><span class="line">&#123; &quot;etag&quot;: &quot;W/\&quot;1a2b3c4d5ef\&quot;&quot;, &quot;name&quot;: &quot;...&quot;, ... &#125;</span><br></pre></td></tr></table></figure><h3 id="输出字段"><a class="markdownIt-Anchor" href="#输出字段"></a> 输出字段</h3><p>一个资源的某些字段可能不允许客户端设置而只能由服务端返回，这些字段应当需要额外标注。</p><p>需要注意的是如果仅作为输出的字段在请求消息体中设置了，或者包含在了 <code>google.protobuf.FieldMask</code> 中，服务端也必须接受该请求而不是返回错误，只不过服务端在处理时需要忽略这些输出字段。之所以要这么做是因为客户端经常会复用某个接口返回的资源，将其作为另一个接口的输入，例如客户端可能会先请求获取一个 <code>Book</code> 资源，将其修改后再调用 <code>UPDATE</code> 方法。如果服务端对输出字段进行校验，则要求客户端进行额外的处理来删除这些输出字段。</p><p>接口示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/api/field_behavior.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  Timestamp create_time = 2 [(google.api.field_behavior) = OUTPUT_ONLY];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例资源"><a class="markdownIt-Anchor" href="#单例资源"></a> 单例资源</h3><p>当只有一个资源存在于某个父资源下（或服务，如果没有父资源的话）时，则可以使用单例资源。</p><p>标准方法的 <code>Create</code> 和 <code>Delete</code> 方法对单例资源无效，单例资源一般随着父资源的创建而创建，<br />随着父资源的删除而删除。单例资源必须通过标准方法的 <code>Get</code> 和 <code>Update</code> 方法来访问，以及其他适合的自定义方法。</p><p>例如，每一个 <code>User</code> 资源可以有一个单例的 <code>Settings</code> 资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">rpc GetSettings(GetSettingsRequest) returns (Settings) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v1/&#123;name=users/*/settings&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc UpdateSettings(UpdateSettingsRequest) returns (Settings) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    patch: &quot;/v1/&#123;settings.name=users/*/settings&#125;&quot;</span><br><span class="line">    body: &quot;settings&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">message Settings &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  // 省略其他字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetSettingsRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateSettingsRequest &#123;</span><br><span class="line">  Settings settings = 1;</span><br><span class="line">  // 支持局部更新</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流式半关闭"><a class="markdownIt-Anchor" href="#流式半关闭"></a> 流式半关闭</h3><p>对于任何的双向或者客户端流式 <code>API</code>，服务端应该依赖由 <code>RPC</code> 系统提供、客户端发起的半关闭来完成客户端流。没有必要额外的定义一个完成的消息。</p><p>任何在客户端发起半关闭前想要发送的消息都必须定义为请求消息体的一部分。</p><h3 id="domain-scoped-名称"><a class="markdownIt-Anchor" href="#domain-scoped-名称"></a> Domain-scoped 名称</h3><p><code>domain-scoped</code> 名称指的是添加了域名前缀的实体名称，用于避免不同服务的命名冲突。<code>Google APIs</code> 和 <code>Kubernetes APIs</code> 大量使用了 <code>domain-scoped</code> 名称：</p><ul><li><code>Protobuf</code> 的 <code>Any</code> 类型：<code>type.googleapis.com/google.protobuf.Any</code></li><li><code>Stackdriver</code> 的指标类型：<code>compute.googleapis.com/instance/cpu/utilization</code></li><li>标签的键：<code>cloud.googleapis.com/location</code></li><li><code>Kubernetes</code> 的 <code>API</code> 版本号：<code>networking.k8s.io/v1</code></li><li><code>x-kubernetes-group-version-kind</code> 的 <code>OpenAPI</code> 扩展中的 <code>kind</code> 字段</li></ul><h3 id="布尔值-vs-枚举-vs-字符串"><a class="markdownIt-Anchor" href="#布尔值-vs-枚举-vs-字符串"></a> 布尔值 vs. 枚举 vs. 字符串</h3><p>设计 <code>API</code> 时有时候会遇到需要能够启用或者禁用某个功能的场景，从实现上说可以增加一个 <code>bool</code>，<code>enum</code> 或者 <code>string</code> 类型的字段来控制，具体选择哪种类型可以遵循如下规则：</p><ul><li>如果确定只有两种状态且不希望在未来扩展时使用 <code>bool</code>，例如 <code>enable_tracing</code> 或者 <code>enable_pretty_print</code></li><li>如果希望设计更为灵活但是又不希望改动太频繁时使用 <code>enum</code>，一个评估的准则是一旦 <code>enum</code> 的值确定了，那么一年内只会改动一次或者更低频，例如 <code>enum TlsVersion</code> 或者 <code>enum HttpVersion</code></li><li><code>string</code> 有着最大的灵活性，适用于可能会频繁修改的场景，其对应的值必须清晰的在文档中标注，例如：<ul><li><a href="https://www.unicode.org/reports/tr35/#unicode_region_subtag">Unicode regions</a> 对应的 <code>string region_code</code></li><li><a href="https://www.unicode.org/reports/tr35/#Unicode_locale_identifier">Unicode locales</a> 对应的 <code>string language_code</code></li></ul></li></ul><h3 id="数据保留"><a class="markdownIt-Anchor" href="#数据保留"></a> 数据保留</h3><p>对于某些服务而言，用户数据非常重要，如果用户数据不小心被软件 <code>bug</code> 或者人为错误删除，在缺少数据保留策略和撤销删除功能的情况下，可能对业务造成灾难性的影响。</p><p>一般而言，建议为 <code>API</code> 服务设置如下的数据保留策略：</p><ul><li>对于用户的元数据，用户设置等其他重要的数据，设置30天的数据保留期。例如监控指标，项目的元数据和服务定义</li><li>对于大容量的用户数据，应该设置7天的数据保留期。例如对象存储和数据库表</li><li>对于临时的状态数据或者昂贵的存储数据，如果可行的话应该设置1天的数据保留期。例如 <code>memcache</code> 和 <code>Redis</code> 内存中的数据</li></ul><p>在数据保留期内，可以执行撤销删除的操作从而不会造成数据丢失。</p><h3 id="大型传输载荷"><a class="markdownIt-Anchor" href="#大型传输载荷"></a> 大型传输载荷</h3><p>网络 <code>API</code> 依赖分层的网络架构来传输数据，大多数的网络协议层对输入和输出的数据量设置了上限，一般而言，<code>32 MB</code> 是大多数系统中常用的大小上限。</p><p>如果某个 <code>API</code> 涉及的传输载荷超过 <code>10 MB</code>，则需要选择合适的策略以确保易用性和未来的扩展的需求。对于 <code>Google APIs</code> 来说，建议使用流式传输或者媒体上传/下载的方式来处理大型载荷，在流式传输下，服务端能够以增量同步的方式处理大量数据，例如 <code>Cloud Spanner API</code>。在媒体传输下，大量的数据流先流入到大型的存储系统中，例如 <code>Google Cloud Storage</code>，然后服务端可以异步的从存储系统中读取数据并处理，例如 <code>Google Drive API</code>。</p><h3 id="可选的基本类型字段"><a class="markdownIt-Anchor" href="#可选的基本类型字段"></a> 可选的基本类型字段</h3><p><code>Protocol Buffers v3</code> 支持 <code>optional</code> 基本类型字段，在语义上等同于众多编程语言中的 <code>nullable</code> 类型，它可以用于区分空值和未设置的值。</p><p>在实践中开发人员难以正确的处理可选字段，大多数的 <code>JSON HTTP</code> 客户端类库，包括 <code>Google API Client Libraries</code>，无法正确区分 <code>proto3</code> 的 <code>int32</code>，<code>google.protobuf.Int32Value</code> 以及 <code>optional int32</code>。如果存在一个方案更清晰而且也不需要可选的基本类型字段，则优先选择该方案。如果不使用可选的基本类型字段会造成复杂度上升或者含义不清晰，则选择可选的基本类型字段。但是不允许可选字段搭配包装类型使用。一般而言，从简洁和一致性考虑，<code>API</code> 设计者应当尽量选择基本类型字段，例如 <code>int32</code>。</p><h2 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h2><p><code>Google APIs</code> 借助版本控制来解决后向兼容问题。</p><p>所有的 <code>Google API</code> 接口都必须包含一个主版本号，这个主版本号会附加在 <code>protobuf</code> 包的最后，以及包含在 <code>REST APIs</code> 的 <code>URI</code> 的第一个部分中。如果 <code>API</code> 要引入一个与当前版本不兼容的变更，例如删除或者重命名某个字段，则必须增加主版本号，从而避免引用了当前版本的用户代码受到影响。</p><p>所有 <code>API</code> 的新主版本不允许依赖同 <code>API</code> 的前一个主版本。一个 <code>API</code> 本身可能会依赖其他 <code>API</code>，这要求调用方知晓被依赖的 <code>API</code> 的版本稳定性风险。在这种情况下，一个稳定版本的 <code>API</code> 必须只依赖同样是稳定版本的其他 <code>API</code>。</p><p>同一个 <code>API</code> 的不同版本在同一个客户端应用内必须能在一段合理的过渡时期内同时生效。这个过渡时期保障了客户端应用升级到新的 <code>API</code> 版本的平滑过渡。同样的，老版本的 <code>API</code> 也必须在废弃并最终停用之前留有足够的过渡时间。</p><p>对于会发布 <code>alpha</code> 或者 <code>beta</code> 版本的 <code>API</code> 来说，必须将 <code>alpha</code> 或者 <code>beta</code> 附加在主版本号之后，并且使用如下其一的策略：</p><ul><li>基于渠道的版本控制（推荐）</li><li>基于发布的版本控制</li><li>基于可见性的版本控制</li></ul><h3 id="基于渠道的版本控制"><a class="markdownIt-Anchor" href="#基于渠道的版本控制"></a> 基于渠道的版本控制</h3><p><code>stability channel</code> 是在某个稳定性级别下长期进行更新的版本。每个主版本号下的每个稳定性级别最多只有一个版本。因此，在这个策略下，每个主版本最多只有三个可用的版本：<code>alpha</code>，<code>beta</code>，以及 <code>stable</code>。</p><p><code>alpha</code> 和 <code>beta</code> 版本必须将稳定性级别附加到主版本号后，而 <code>stable</code> 则不需要也不允许。例如，<code>v1</code> 可用作为 <code>stable</code> 版本的版本号，但是 <code>v1beta</code> 和 <code>v1alpha</code> 不是。类似的，<code>v1beta</code> 或者 <code>v1alpha</code> 可用作为对应的 <code>beta</code> 和 <code>alpha</code> 版本，但是 <code>v1</code> 不行。每个版本下会对新功能进行就地更新而不会修改版本号。</p><p><code>beta</code> 版本的功能必须是 <code>stable</code> 版本的功能的超集，同时 <code>alpha</code> 版本的功能必须是 <code>beta</code> 版本的功能的超集。</p><p>对于任何版本的 <code>API</code> 来说，其中的元素（字段，消息体，RPC 方法等）都有可能被标记为废弃：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Represents a scroll. Books are preferred over scrolls.</span><br><span class="line">message Scroll &#123;</span><br><span class="line">  option deprecated = true;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>废弃的 <code>API</code> 功能不允许从 <code>alpha</code> 版本继续保留到 <code>beta</code> 版本，也不允许从 <code>beta</code> 版本保留到 <code>stable</code> 版本。也就是说某个功能不能在任何版本中预先废弃。</p><p><code>beta</code> 版本的功能可以在废弃后经过合理的时间后删除，建议是180天。对于只存在于 <code>alpha</code> 版本的功能，不一定会标记为废弃，并且删除时也不会通知。</p><h3 id="基于发布的版本控制"><a class="markdownIt-Anchor" href="#基于发布的版本控制"></a> 基于发布的版本控制</h3><p>在该策略下，<code>alpha</code> 或者 <code>beta</code> 版本的功能在合并到 <code>stable</code> 版本之前只会在有限的时间内可用。因此，一个 <code>API</code> 在每个稳定性级别下可能有任意数量的版本发布。</p><blockquote><p>基于渠道的版本控制和基于发布的版本控制都会就地更新 <code>stable</code> 版本。</p></blockquote><p><code>alpha</code> 和 <code>beta</code> 版本发布时需要在 <code>alpha</code> 或者 <code>beta</code> 之后附加一个递增版本号，例如 <code>v1beta1</code> 或者 <code>v1alpha5</code>。<code>API</code> 应当在文档中记录这些版本的时间顺序。</p><p>每个 <code>alpha</code> 或者 <code>beta</code> 版本都有可能就地进行后向兼容的更新。对于 <code>beta</code> 版本来说，如果发布了后向不兼容的版本则应当修改 <code>beta</code> 后的版本号，然后发布新的版本。例如，如果当前版本是 <code>v1beta1</code>，则新版本为 <code>v1beta2</code>。</p><p>当 <code>alpha</code> 和 <code>beta</code> 版本中的功能合并到 <code>stable</code> 版本之后就可以终止 <code>alpha</code> 或者 <code>beta</code> 版本。<code>alpha</code> 版本可能会在任一时刻终止，但是 <code>beta</code> 版本在终止前应当给用户留有足够的过渡期，建议是180天。</p><h3 id="基于可见性的版本控制"><a class="markdownIt-Anchor" href="#基于可见性的版本控制"></a> 基于可见性的版本控制</h3><p><a href="https://github.com/googleapis/googleapis/blob/master/google/api/visibility.proto">API 可见性</a> 是 <code>Google API</code> 基础架构提供的一项高级功能。它允许 <code>API</code> 发布者将一个 <code>API</code> 对外暴露出多个不同的外部 <code>API</code> 视图，每个视图关联一个 <code>API</code> 可见性的标签，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/api/visibility.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Resource &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // 预览功能，勿在生产环境使用</span><br><span class="line">  string display_name = 2</span><br><span class="line">    [(google.api.field_visibility).restriction = &quot;PREVIEW&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见性标签是一个区分大小写的字符串，可以绑定到任意 <code>API</code> 元素上。一般来说，可见性标签应当始终使用全大写字母。所有的 <code>API</code> 元素默认绑定 <code>PUBLIC</code> 的可见性标签，除非显式的声明了可见性。</p><p>每个可见性标签本质上是一个允许访问的列表，<code>API</code> 生产者需要授权给 <code>API</code> 消费者合适的可见性标签才能使用 <code>API</code>。换句话说，可见性标签类似于 <code>API</code> 的 <code>ACL</code>（<code>Access Control List</code>）。</p><p>每个 <code>API</code> 元素可以绑定多个可见性标签，各可见性标签之间用逗号分割（例如 <code>PREVIEW,TRUSTED_TESTER</code>）。多个可见性标签之间是逻辑或的关系，<code>API</code> 消费者只要授权了其中一个可见性标签就可以使用 <code>API</code>。</p><p>一个 <code>API</code> 请求只能使用一个可见性标签，默认使用的是授权给当前 <code>API</code> 消费者的可见性标签。客户端可以显式的指定需要用哪个可见性标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /v1/projects/my-project/topics HTTP/1.1</span><br><span class="line">Host: pubsub.googleapis.com</span><br><span class="line">Authorization: Bearer y29....</span><br><span class="line">X-Goog-Visibilities: PREVIEW</span><br></pre></td></tr></table></figure><p><code>API</code> 生产者可以借助可见性标签来实现版本控制，例如 <code>INTERNAL</code> 和 <code>PREVIEW</code>。<code>API</code> 的新功能从 <code>INTERNAL</code> 可见性标签开始，然后升级到 <code>PREVIEW</code> 可见性标签。当功能稳定可用后，就删除所有的可见性标签，即等同于默认的可见性标签 <code>PUBLIC</code>。</p><p>总体来说，<code>API</code> 的可见性比 <code>API</code> 版本号更容易实现增量的功能迭代，不过这要求比较成熟的 <code>API</code> 基础架构的支持。<code>Google Cloud APIs</code> 经常使用 <code>API</code> 可见性用于预览功能。</p><h2 id="兼容性"><a class="markdownIt-Anchor" href="#兼容性"></a> 兼容性</h2><p>这里的兼容性讨论的是对于 <code>API</code> 使用者的影响，<code>API</code> 生产者应当自身知晓为了实现兼容性需要哪方面的工作。</p><p>总的来说，<code>API</code> 的小版本更新或者补丁更新不应该对客户端造成兼容性问题。可能的不兼容问题包括：</p><ul><li>源代码兼容性：针对1.0版本编写的代码升级到1.1版本后编译失败</li><li>二进制文件兼容性：针对1.0版本编译生成的二进制文件链接到1.1版本后运行失败</li><li>通信兼容性：针对1.0版本编写的应用程序无法和运行1.1版本的服务端通信</li><li>语义兼容性：针对1.0版本编写的应用程序升级到1.1版本后能够运行，但是存在不可预知的结果</li></ul><p>从另一个角度来说，只要主版本号一致，运行着旧版本的客户端程序就能够和运行着新版本的服务端结合使用，并且客户端程序也能轻易的升级小版本。</p><h3 id="后向兼容的修改"><a class="markdownIt-Anchor" href="#后向兼容的修改"></a> 后向兼容的修改</h3><h4 id="向-api-服务添加新的接口"><a class="markdownIt-Anchor" href="#向-api-服务添加新的接口"></a> 向 API 服务添加新的接口</h4><p>从协议角度来看，添加新的接口始终是安全的。需要注意的是有可能新添加的接口名称已经被客户端代码占用了。如果当前新添加的接口与当前存在的接口完全不同，则基本不用担心；但是如果新添加的接口是当前某个存在的接口的简化版本，则有可能和客户端自定义实现的接口冲突。</p><h4 id="向-api-接口添加新的方法"><a class="markdownIt-Anchor" href="#向-api-接口添加新的方法"></a> 向 API 接口添加新的方法</h4><p>除非新添加的方法和客户端自动生成的代码中的某个方法冲突，否则这也是安全的。</p><p>例如当前已经存在了一个 <code>GetFoo</code> 方法，<code>C#</code> 的代码生成器会同时生成一个 <code>GetFooAsync</code> 的方法，如果此时再添加一个 <code>GetFooAsync</code> 方法，则会造成冲突。</p><h4 id="向已有的方法添加-http-绑定"><a class="markdownIt-Anchor" href="#向已有的方法添加-http-绑定"></a> 向已有的方法添加 HTTP 绑定</h4><p>假设绑定 <code>HTTP</code> 没有任何歧义，那么让服务端响应之前拒绝的 <code>URL</code> 就是安全的。这个操作可能在将某个已有的操作映射到某个新资源时发生。</p><h4 id="向请求消息体添加新的字段"><a class="markdownIt-Anchor" href="#向请求消息体添加新的字段"></a> 向请求消息体添加新的字段</h4><p>只要服务端在新版本的代码中处理未传入的新字段的逻辑和老版本代码中的逻辑一致，那么添加新的字段就是安全的。</p><p>一个最可能出错的场景是添加分页相关的字段：如果 <code>v1.0</code> 版本的代码中没有分页功能，那么也不能将分页功能添加到 <code>v1.1</code> 版本中，除非 <code>page_size</code> 的默认值是无限大（但这通常不是个好的设计）。否则的话依赖了 <code>v1.0</code> 版本的客户端期望一次请求获取所有的数据，但实际上可能只获取了第一页的数据。</p><h4 id="向响应消息体添加新的字段"><a class="markdownIt-Anchor" href="#向响应消息体添加新的字段"></a> 向响应消息体添加新的字段</h4><p>对于非资源类的响应消息体来说（例如 <code>ListBooksResponse</code>）添加一个字段都不会造成后向兼容性问题，只要新添加的字段不会影响其他字段的行为即可。消息体中之前暴露的字段应当继续以相同的语义保留，即使可能存在冗余。</p><p>例如，1.0版本的响应消息体中有一个字段是 <code>contained_duplicates</code> 表示返回的结果存在重复值并已经进行了去重。在1.1版本中新增了 <code>duplicate_count</code> 字段表示重复的数据数量，虽然原有的 <code>contained_duplicates</code> 已经冗余了但是该字段也必须保留。</p><h4 id="向枚举添加新值"><a class="markdownIt-Anchor" href="#向枚举添加新值"></a> 向枚举添加新值</h4><p>如果枚举是在请求消息体中使用，那么向枚举添加新值是安全的。因为客户端并不关心它们用不到的值。</p><p>对于在资源消息体或者响应消息体中的枚举，默认的假设是客户端需要能够处理未知的枚举值。不过，<code>API</code> 生产者应当知晓客户端如何正确的处理新的枚举值不是一件简单的事，因此必须在文档中标注如果客户端遇到未知的枚举值时期望的行为是什么。</p><h4 id="添加新的输出字段"><a class="markdownIt-Anchor" href="#添加新的输出字段"></a> 添加新的输出字段</h4><p>如果一个字段只可能会由服务端设置并仅作为输出使用，那么添加这个字段也是安全的。服务端可能会校验客户端发送的消息体中的字段，但是如果新添加的输出字段在请求消息体中不存在，服务端不允许抛出异常。</p><h3 id="后向不兼容的修改"><a class="markdownIt-Anchor" href="#后向不兼容的修改"></a> 后向不兼容的修改</h3><h4 id="移除或者重命名服务字段方法或者枚举值"><a class="markdownIt-Anchor" href="#移除或者重命名服务字段方法或者枚举值"></a> 移除或者重命名服务，字段，方法或者枚举值</h4><p>一般来说，移除或者重命名某个客户端代码可能引用的内容都是一次后向不兼容的修改，必须升级主版本号才能更新。对于某些编程语言来说如果引用了旧的名称则会造成编译问题（例如 <code>C#</code> 和 <code>Java</code>）或者对于另一些编程语言来说造成运行时异常或者数据丢失。</p><h4 id="更改-http-映射"><a class="markdownIt-Anchor" href="#更改-http-映射"></a> 更改 HTTP 映射</h4><p>这里的更改指的是删除然后添加。例如，假设你想将某个已经存在的方法的 <code>HTTP</code> 映射改为 <code>PATCH</code>，而目前暴露的 <code>HTTP</code> 方法是 <code>PUT</code>，你可以添加一个新的 <code>HTTP</code> 映射，但是不能删除原有的 <code>HTTP</code> 映射。</p><h4 id="更改字段类型"><a class="markdownIt-Anchor" href="#更改字段类型"></a> 更改字段类型</h4><p>即使更改后的字段类型和当前的传输格式兼容，也可能造成客户端生成的代码不兼容，因此也必须升级主版本号才能更新。对于静态编译型编程语言来说，这很容易引入编译问题。</p><h4 id="更改资源的命名格式"><a class="markdownIt-Anchor" href="#更改资源的命名格式"></a> 更改资源的命名格式</h4><p>不允许修改资源的名称，这也意味着资源集合的名称也不允许修改。</p><p>如果客户端能够在 <code>v2.0</code> 版本中访问 <code>v1.0</code> 版本中创建的资源（或者反过来），那么该资源在两个版本中就应当使用相同的资源名称。</p><p>另外，有效的资源名称集也不能修改，因为：</p><ul><li>如果集合变小，那么之前成功的请求就有可能失败</li><li>如果集合变大，那么客户端基于之前关于资源名称的假设可能失效。因为客户端很可能会根据资源名称所允许的字符和长度将其存储在其他地方，以及构建自己的资源名称验证规则</li></ul><h4 id="更改现有请求的可见行为"><a class="markdownIt-Anchor" href="#更改现有请求的可见行为"></a> 更改现有请求的可见行为</h4><p>客户端经常会依赖 <code>API</code> 的行为和语义，即使这些行为没有明确的表示支持或者在文档中说明。因此，在大多数情况下更改 <code>API</code> 的行为会造成后向不兼容问题。如果你的 <code>API</code> 的行为不是非常的隐秘，你都应该假设用户已经识别出 <code>API</code> 的行为并依赖它。</p><p>因此，加密分页功能中的页码信息就很有必要（即使该数据没有什么意义），从而防止用户自行创建页码信息，然后当页码行为更改时遭遇后向不兼容问题。</p><h4 id="更改-http-定义中的-url-格式"><a class="markdownIt-Anchor" href="#更改-http-定义中的-url-格式"></a> 更改 HTTP 定义中的 URL 格式</h4><p>除了资源名称之外，还有两个关于 <code>URL</code> 格式的修改：</p><ul><li>自定义方法的名称：虽然自定义方法名称不是资源名称的一部分，但依然是 <code>REST</code> 请求路径的一部分，虽然修改 <code>HTTP</code> 的自定义方法名称不会破坏 <code>gRPC</code> 客户端，但依然要假设存在 <code>REST</code> 客户端的用户</li><li>资源参数名称：例如从 <code>v1/shelves/&#123;shelf&#125;/books/&#123;book&#125;</code> 修改为 <code>v1/shelves/&#123;shelf_id&#125;/books/&#123;book_id&#125;</code> 不会影响资源名称，但是会影响客户端自动生成的代码</li></ul><h4 id="向资源消息体添加读写字段"><a class="markdownIt-Anchor" href="#向资源消息体添加读写字段"></a> 向资源消息体添加读/写字段</h4><p>客户端经常会执行先读，然后修改，最后写入的一整套操作，大多数情况下如果某个字段客户端用不到就不会给它赋值。虽然服务端可以采取缺失值的字段就不执行写入的措施，但不适用于基本类型的字段（包括 <code>string</code> 和 <code>bytes</code>），因为基本类型默认值的存在造成无法区分出是客户端主动设置 <code>int32</code> 类型的字段值为0还是没有设置值从而使用默认值0。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>虽然 <code>Google</code> 的这篇 <code>API</code> 设计主要是面向资源的设计，但同时也针对其不足提出了改进的方案。不管是 <code>RESTful</code> 还是非 <code>RESTful</code> 的接口设计，都只是一种规范，有各自适合的场景没有孰优孰劣，统一的规范胜过生搬硬套。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://cloud.google.com/apis/design">API design guide</a></li><li><a href="https://stackoverflow.com/questions/3715981/what-s-the-best-restful-method-to-return-total-number-of-items-in-an-object">What’s the best RESTful method to return total number of items in an object?</a></li><li><a href="https://docs.digitalocean.com/reference/api/api-reference/">DigitalOcean API (2.0)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/apis/design&quot;&gt;Google API Design Guide&lt;/</summary>
      
    
    
    
    
    <category term="Design" scheme="https://frederick-s.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2 监控内存使用</title>
    <link href="https://frederick-s.github.io/2022/10/09/monitor-ec2-memory-usage/"/>
    <id>https://frederick-s.github.io/2022/10/09/monitor-ec2-memory-usage/</id>
    <published>2022-10-08T16:00:00.000Z</published>
    <updated>2022-10-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AWS</code> <code>EC2</code> 的监控页面默认没有显示内存使用率，需要搭配 <code>CloudWatch</code> 配置使用。</p><p>由于需要在 <code>EC2</code> 上安装 <code>CloudWatch agent</code> 来上报监控数据到 <code>CloudWatch</code>，所以需要先为 <code>EC2</code> 配置 <code>IAM</code> 角色来授予需要的权限。创建 <code>IAM</code> 角色时，在第一步的 <code>Trusted entity type</code> 选择 <code>AWS service</code>，<code>Use case</code> 选择 <code>EC2</code>；在第二步的 <code>Permissions policies</code> 添加 <code>CloudWatchAgentServerPolicy</code> 即可。更多细节可参考 <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/create-iam-roles-for-cloudwatch-agent-commandline.html">Create IAM roles and users for use with CloudWatch agent</a>。</p><p>接着，在 <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/download-cloudwatch-agent-commandline.html">Download and configure the CloudWatch agent using the command line</a> 中根据实际 <code>EC2</code> 的操作系统下载和安装 <code>CloudWatch agent</code>，这里以 <code>ARM64</code> 的 <code>Ubuntu</code> 系统为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/arm64/latest/amazon-cloudwatch-agent.deb</span><br><span class="line">sudo dpkg -i -E ./amazon-cloudwatch-agent.deb</span><br></pre></td></tr></table></figure><p>然后，为 <code>CloudWatch agent</code> 创建一个配置文件，例如 <code>cloudwatch.json</code>，写入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;metrics&quot;:&#123;</span><br><span class="line">      &quot;metrics_collected&quot;:&#123;</span><br><span class="line">         &quot;mem&quot;:&#123;</span><br><span class="line">            &quot;measurement&quot;:[</span><br><span class="line">               &quot;mem_used_percent&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;metrics_collection_interval&quot;:60</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;append_dimensions&quot;: &#123;</span><br><span class="line">        &quot;InstanceId&quot;: &quot;$&#123;aws:InstanceId&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示每隔60秒收集一次内存使用率，接着启动 <code>CloudWatch agent</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:<span class="variable">$HOME</span>/cloudwatch.json -s</span><br></pre></td></tr></table></figure><p>可以通过 <code>amazon-cloudwatch-agent-ctl -a status</code> 来查看 <code>CloudWatch agent</code> 的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;running&quot;,</span><br><span class="line">  &quot;starttime&quot;: &quot;2022-10-09T13:23:11+00:00&quot;,</span><br><span class="line">  &quot;configstatus&quot;: &quot;configured&quot;,</span><br><span class="line">  &quot;cwoc_status&quot;: &quot;stopped&quot;,</span><br><span class="line">  &quot;cwoc_starttime&quot;: &quot;&quot;,</span><br><span class="line">  &quot;cwoc_configstatus&quot;: &quot;not configured&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.247355.0b252062&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 <code>CloudWatch agent</code> 的状态为运行中。</p><p>如果一切正常，那么在 <code>AWS</code> 控制台中 <code>CloudWatch</code> 的 <code>All metrics</code> 下会多出一项 <code>CWAgent</code>（如果原来没有添加过的话）：</p><p><img src="/images/cloudwatch-1.png" alt="alt" /></p><p>点击进入后选择相应的 <code>EC2</code>，点击 <code>Add to graph</code>：</p><p><img src="/images/cloudwatch-2.png" alt="alt" /></p><p>在当前页面上方就会显示对应的内存使用率的监控：</p><p><img src="/images/cloudwatch-3.png" alt="alt" /></p><p>之后也可以创建一个 <code>Dashboard</code>，将这个监控加入到自定义的 <code>Dashboard</code> 中。</p><p>如果在 <code>AWS</code> 控制台没有看到 <code>CWAgent</code> 项目，那么可以查看 <code>EC2</code> 上 <code>CloudWatch agent</code> 的日志是否有异常，日志保存在 <code>/opt/aws/amazon-cloudwatch-agent/logs/amazon-cloudwatch-agent.log</code>。例如，如果忘记为 <code>EC2</code> 配置 <code>IAM</code> 角色，同时 <code>EC2</code> 上又没有其他的权限访问信息，<code>CloudWatch agent</code> 就无法上报监控数据，会提示如下类似的异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-10-09T13:27:36Z E! WriteToCloudWatch failure, err:  NoCredentialProviders: no valid providers in chain</span><br><span class="line">caused by: EnvAccessKeyNotFound: failed to find credentials in the environment.</span><br><span class="line">SharedCredsLoad: failed to load profile, .</span><br><span class="line">EC2RoleRequestError: no EC2 instance role found</span><br><span class="line">caused by: EC2MetadataError: failed to make EC2Metadata request</span><br></pre></td></tr></table></figure><p>最后，如果想要添加更多的监控指标，可以参考 <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/metrics-collected-by-CloudWatch-agent.html">Metrics collected by the CloudWatch agent</a> 添加相应的指标。</p><p>参考：</p><ul><li><a href="https://lepczynski.it/en/aws_en/how-to-monitor-memory-usage-on-aws-ec2/">How to monitor memory usage on AWS EC2 ??</a></li><li><a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/download-cloudwatch-agent-commandline.html">Download and configure the CloudWatch agent using the command line</a></li><li><a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/metrics-collected-by-CloudWatch-agent.html">Metrics collected by the CloudWatch agent</a></li><li><a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/create-iam-roles-for-cloudwatch-agent-commandline.html">Create IAM roles and users for use with CloudWatch agent</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;AWS&lt;/code&gt; &lt;code&gt;EC2&lt;/code&gt; 的监控页面默认没有显示内存使用率，需要搭配 &lt;code&gt;CloudWatch&lt;/code&gt; 配置使用。&lt;/p&gt;
&lt;p&gt;由于需要在 &lt;code&gt;EC2&lt;/code&gt; 上安装 &lt;code&gt;CloudWatch </summary>
      
    
    
    
    
    <category term="AWS" scheme="https://frederick-s.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2 挂载磁盘</title>
    <link href="https://frederick-s.github.io/2022/09/18/add-volume-to-aws-ec2/"/>
    <id>https://frederick-s.github.io/2022/09/18/add-volume-to-aws-ec2/</id>
    <published>2022-09-17T16:00:00.000Z</published>
    <updated>2022-09-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="挂载磁盘"><a class="markdownIt-Anchor" href="#挂载磁盘"></a> 挂载磁盘</h2><p>在创建 <code>AWS</code> 的 <code>EC2</code> 实例时如果添加了额外的磁盘则需要手动挂载到系统中。</p><p>首先运行 <code>lsblk</code> 来查看可用的块设备：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0          7:0    0 22.2M  1 loop /snap/amazon-ssm-agent/5657</span><br><span class="line">loop1          7:1    0   49M  1 loop /snap/core18/2406</span><br><span class="line">loop2          7:2    0 57.8M  1 loop /snap/core20/1498</span><br><span class="line">loop3          7:3    0 38.7M  1 loop /snap/snapd/15909</span><br><span class="line">loop4          7:4    0 71.8M  1 loop /snap/lxd/22927</span><br><span class="line">nvme1n1      259:0    0    8G  0 disk</span><br><span class="line">nvme0n1      259:1    0    8G  0 disk</span><br><span class="line">├─nvme0n1p1  259:2    0  7.9G  0 part /</span><br><span class="line">└─nvme0n1p15 259:3    0   99M  0 part /boot/efi</span><br></pre></td></tr></table></figure><p>其中的 <code>nvme1n1</code> 是本次新添加的磁盘，目前还未挂载到系统中，而 <code>nvme0n1</code> 则是根设备并且有两个分区。</p><blockquote><p><code>lsblk</code> 的输出结果会移除设备路径中的 <code>/dev/</code> 前缀，所以设备 <code>nvme1n1</code> 的完整路径为 <code>/dev/nvme1n1</code>。</p></blockquote><p>然后，我们需要在 <code>nvme1n1</code> 之上创建文件系统才能使用，执行 <code>sudo file -s /dev/nvme1n1</code> 显示 <code>nvme1n1</code> 还没有文件系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme1n1: data</span><br></pre></td></tr></table></figure><p>而如果我们查看 <code>sudo file -s /dev/nvme0n1</code> 则会显示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 16777215 sectors, extended partition table (last)</span><br></pre></td></tr></table></figure><p>执行 <code>sudo mkfs -t xfs /dev/nvme1n1</code> 来为 <code>nvme1n1</code> 创建文件系统，其中 <code>xfs</code> 表示文件系统的类型：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meta-data=/dev/nvme1n1           isize=512    agcount=8, agsize=262144 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                       reflink=1    bigtime=0 inobtcount=0</span><br><span class="line">data     =                       bsize=4096   blocks=2097152, imaxpct=25</span><br><span class="line">         =                       sunit=1      swidth=1 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0, ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=1 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><p>接着，我们就可以创建一个文件夹用来挂载磁盘，例如 <code>sudo mkdir /data</code>。最后将 <code>/dev/nvme1n1</code> 挂载到 <code>/data</code> 上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/nvme1n1 /data</span><br></pre></td></tr></table></figure><p>此时如果查看 <code>df -h</code> 就会包含 <code>/dev/nvme1n1</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filesystem       Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        7.6G  1.6G  6.1G  21% /</span><br><span class="line">tmpfs            926M     0  926M   0% /dev/shm</span><br><span class="line">tmpfs            371M 1000K  370M   1% /run</span><br><span class="line">tmpfs            5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/nvme0n1p15   98M  5.1M   93M   6% /boot/efi</span><br><span class="line">tmpfs            186M  4.0K  186M   1% /run/user/1000</span><br><span class="line">/dev/nvme1n1     8.0G   90M  8.0G   2% /data</span><br></pre></td></tr></table></figure><h2 id="系统启动自动挂载磁盘"><a class="markdownIt-Anchor" href="#系统启动自动挂载磁盘"></a> 系统启动自动挂载磁盘</h2><p>当前的磁盘挂载信息会在系统启动后丢失，如果希望系统启动后自动挂载磁盘则需要向 <code>/etc/fstab</code> 中添加一条记录。</p><p>安全起见先备份下 <code>/etc/fstab</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/fstab /etc/fstab.orig</span><br></pre></td></tr></table></figure><p>然后运行 <code>sudo blkid</code> 来查看设备 <code>/dev/nvme1n1</code> 的 <code>UUID</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1p1: LABEL=<span class="string">&quot;cloudimg-rootfs&quot;</span> UUID=<span class="string">&quot;15ea47e1-ef7d-4928-9dbe-ffaf0e743653&quot;</span> BLOCK_SIZE=<span class="string">&quot;4096&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;1957f80e-a338-441c-a0e0-ed1575eefda3&quot;</span></span><br><span class="line">/dev/nvme0n1p15: LABEL_FATBOOT=<span class="string">&quot;UEFI&quot;</span> LABEL=<span class="string">&quot;UEFI&quot;</span> UUID=<span class="string">&quot;68E7-1A63&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;vfat&quot;</span> PARTUUID=<span class="string">&quot;1eeb08ab-0afd-4477-bd53-4389a42db8f6&quot;</span></span><br><span class="line">/dev/loop1: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop4: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop2: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop0: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/nvme1n1: UUID=<span class="string">&quot;aa81c000-325c-40b7-ba4c-598ec2c824e0&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line">/dev/loop3: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br></pre></td></tr></table></figure><p>最后向 <code>/etc/fstab</code> 添加一条记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=aa81c000-325c-40b7-ba4c-598ec2c824e0  /data  xfs  defaults,nofail  0  2</span><br></pre></td></tr></table></figure><p>可以通过先取消挂载 <code>/data</code> 即 <code>sudo umount /data</code> 然后再执行 <code>sudo mount -a</code> 来验证自动挂载是否生效。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html">Make an Amazon EBS volume available for use on Linux</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;挂载磁盘&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#挂载磁盘&quot;&gt;&lt;/a&gt; 挂载磁盘&lt;/h2&gt;
&lt;p&gt;在创建 &lt;code&gt;AWS&lt;/code&gt; 的 &lt;code&gt;EC2&lt;/code&gt; 实例时如果添加了额外的磁盘则需要手动挂载到系统中。&lt;</summary>
      
    
    
    
    
    <category term="AWS" scheme="https://frederick-s.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>创建 EKS 集群</title>
    <link href="https://frederick-s.github.io/2022/09/11/setup-eks-cluster/"/>
    <id>https://frederick-s.github.io/2022/09/11/setup-eks-cluster/</id>
    <published>2022-09-10T16:00:00.000Z</published>
    <updated>2022-09-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>EKS</code>（<code>Amazon Elastic Kubernetes Service</code>）是 <code>AWS</code> 提供的 <code>Kubernetes</code> 服务，它能大大减轻创建和维护 <code>Kubernetes</code> 集群的负担。</p><h2 id="创建-eks-集群"><a class="markdownIt-Anchor" href="#创建-eks-集群"></a> 创建 EKS 集群</h2><p>有两种方式来创建 <code>EKS</code> 集群，一种是使用本地的 <code>eksctl</code> 程序；另一种是通过 <code>AWS</code> 的管理后台（<code>AWS Management Console</code>），这里选择通过 <code>AWS</code> 的管理后台来创建 <code>EKS</code> 集群。</p><h3 id="创建-cluster-service-role"><a class="markdownIt-Anchor" href="#创建-cluster-service-role"></a> 创建 Cluster service role</h3><p>创建 <code>EKS</code> 集群时需要绑定一个 <code>IAM</code> 角色，因为 <code>Kubernetes</code> 的 <code>control plane</code> 需要管理集群内的资源，所以需要有相应的操作权限。</p><p>首先进入 <a href="https://console.aws.amazon.com/iam/">IAM 控制台</a>，选择左侧 <code>Access management</code> 下的 <code>Roles</code>，点击 <code>Create role</code>。在 <code>Trusted entity type</code> 下选择 <code>AWS service</code>，然后在 <code>Use cases for other AWS services</code> 下选择 <code>EKS</code>，接着选择 <code>EKS - Cluster</code> 并点击 <code>Next</code>。在 <code>Add permissions</code> 这步直接点击 <code>Next</code>。在最后一步设置所创建的角色的名字，如 <code>eksClusterRole</code>，最后点击 <code>Create role</code> 创建角色。</p><h3 id="创建集群"><a class="markdownIt-Anchor" href="#创建集群"></a> 创建集群</h3><p>我们通过 <code>AWS</code> 管理后台中的 <code>Amazon Elastic Kubernetes Service</code> 界面来创建集群，第一步的 <code>Configure cluster</code> 主要设置集群的名称，如 <code>my-cluster</code>，以及绑定在之前步骤中所创建的 <code>Cluster service role</code>。第二步的 <code>Specify networking</code> 这里基本都保持默认，只是将 <code>Cluster endpoint access</code> 设置为 <code>Public and private</code>。第三步的 <code>Configure logging</code> 可以暂时不开启日志监控。最后在第四步的 <code>Review and create</code> 点击 <code>Create</code> 创建集群。</p><h2 id="创建-node-group"><a class="markdownIt-Anchor" href="#创建-node-group"></a> 创建 Node group</h2><p>当集群的状态变为 <code>Active</code> 后就表示集群创建成功，不过此时集群中还没有任何 <code>Node</code>，所以系统级别的 <code>Pod</code> 还无法正常工作，比如在集群详情的 <code>Resources</code> 下查看某个 <code>coredns</code> 的 <code>Pod</code> 会显示 <code>FailedScheduling</code>，因为 <code>no nodes available to schedule pods</code>。</p><p>我们需要创建 <code>Node group</code> 来为系统添加可用的 <code>Node</code>。</p><h3 id="创建-node-iam-role"><a class="markdownIt-Anchor" href="#创建-node-iam-role"></a> 创建 Node IAM role</h3><p>在创建 <code>Node group</code> 前，需要创建一个 <code>Node IAM role</code>。因为集群中的 <code>Node</code> 内部会运行着一个叫做 <code>kubelet</code> 的程序，它负责和集群的 <code>control plane</code> 进行通信，例如将当前 <code>Node</code> 注册到集群中，而某些操作需要调用 <code>AWS</code> 的接口，所以和 <code>Cluster service role</code> 类似，也需要绑定相应的权限。</p><p>这里同样也是通过 <a href="https://console.aws.amazon.com/iam/">IAM 控制台</a> 来创建角色，在 <code>Trusted entity type</code> 下选择 <code>AWS service</code>，在 <code>Use case</code> 下选择 <code>EC2</code>，然后点击 <code>Next</code>。在第二步的 <code>Add permissions</code> 需要添加 <code>AmazonEKSWorkerNodePolicy</code>，<code>AmazonEC2ContainerRegistryReadOnly</code> 和 <code>AmazonEKS_CNI_Policy</code> 三个权限，虽然文档中说不建议将 <code>AmazonEKS_CNI_Policy</code> 权限添加到 <code>Node IAM role</code> 上，不过这里作为示例教程将三个权限都绑定在了 <code>Node IAM role</code> 上。最后也是点击 <code>Create role</code> 创建角色。</p><h3 id="创建-node-group-2"><a class="markdownIt-Anchor" href="#创建-node-group-2"></a> 创建 Node group</h3><p>在集群详情的 <code>Compute</code> 下点击 <code>Add node group</code> 来创建 <code>Node group</code>，在第一步 <code>Configure node group</code> 中设置 <code>node group</code> 的名称及绑定在之前步骤中所创建的 <code>Node IAM role</code>。在第二步 <code>Set compute and scaling configuration</code> 里配置节点的类型和数量等信息，作为教程都采用默认配置。第三步 <code>Specify networking</code> 同样采用默认配置。最后在第四步的 <code>Review and create</code> 点击 <code>Create</code> 完成创建。</p><p>最后当所创建的 <code>Node group</code> 的状态变为 <code>Active</code> 以及该 <code>Node group</code> 下的 <code>Node</code> 的状态变为 <code>Ready</code> 时说明节点创建成功。此时再查看集群详情下 <code>Resources</code> 的 <code>coredns</code> 的 <code>Pod</code> 已成功分配了 <code>Node</code> 运行。</p><h2 id="连接-eks-集群"><a class="markdownIt-Anchor" href="#连接-eks-集群"></a> 连接 EKS 集群</h2><p>日常需要通过 <code>kubectl</code> 管理集群，所以需要先在本地配置访问 <code>EKS</code> 集群的权限。<code>kubectl</code> 本质上是和 <code>Kubernetes API server</code> 打交道，而创建集群时 <code>Cluster endpoint access</code> 部分选择的是 <code>Public and private</code>，所以在这个场景下能够从公网管理 <code>EKS</code> 集群。</p><p>首先需要安装 <a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">AWS CLI</a> 和 <a href="https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html">kubectl</a>。然后在本地通过 <code>aws configure</code> 来设置 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>。根据 <a href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html">Enabling IAM user and role access to your cluster</a> 的描述，创建集群的账户会自动授予集群的 <code>system:masters</code> 权限，本文是通过 <code>AWS</code> 的管理后台创建集群，当前登录的账户为 <code>root</code>，所以 <code>aws configure</code> 需要设置为 <code>root</code> 的 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>：</p><blockquote><p>When you create an Amazon EKS cluster, the AWS Identity and Access Management (IAM) entity user or role, such as a federated user that creates the cluster, is automatically granted system:masters permissions in the cluster’s role-based access control (RBAC) configuration in the Amazon EKS control plane.</p></blockquote><p>一般公司生产环境中的 <code>AWS</code> 是不会直接使用 <code>root</code> 账户登录的，而是创建 <code>IAM</code> 用户，由于这里是个人的 <code>AWS</code> 账户所以直接使用了 <code>root</code>，反之就需要使用 <code>IAM</code> 用户的 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>。设置完成之后可以通过 <code>aws sts get-caller-identity</code> 来验证当前用户是否设置正确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;UserId&quot;: &quot;123&quot;,</span><br><span class="line">    &quot;Account&quot;: &quot;123&quot;,</span><br><span class="line">    &quot;Arn&quot;: &quot;arn:aws:iam::123:user&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行 <code>aws eks update-kubeconfig --region us-west-2 --name my-cluster</code> 来更新本地的 <code>kubeconfig</code>，其中 <code>us-west-2</code> 需要修改为实际的 <code>AWS Region</code>，<code>my-cluster</code> 需要修改为实际的集群名称。最后就可以通过 <code>kubectl get all</code> 来验证能否访问集群，如果没有问题就会输出如下类似内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.100.0.1   &lt;none&gt;        443/TCP   175m</span><br></pre></td></tr></table></figure><h2 id="设置其他用户的集群访问权限"><a class="markdownIt-Anchor" href="#设置其他用户的集群访问权限"></a> 设置其他用户的集群访问权限</h2><p>创建集群的账户可能权限较高，所以需要单独给某些账户开通集群的访问权限。可以通过 <code>kubectl describe -n kube-system configmap/aws-auth</code> 查看当前的权限分配情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name:         aws-auth</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">mapRoles:</span><br><span class="line">----</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers</span><br><span class="line">  - system:nodes</span><br><span class="line">  rolearn: arn:aws:iam::123:role/AmazonEKSNodeRole</span><br><span class="line">  username: system:node:&#123;&#123;EC2PrivateDNSName&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryData</span><br><span class="line">====</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure><p>假设我们需要授予某个 <code>IAM</code> 用户 <code>eks</code> <code>system:masters</code> 的角色，首先运行 <code>kubectl edit -n kube-system configmap/aws-auth</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Please edit the object below. Lines beginning with a &#x27;#&#x27; will be ignored,</span><br><span class="line"># and an empty file will abort the edit. If an error occurs while saving this file will be</span><br><span class="line"># reopened with the relevant failures.</span><br><span class="line">#</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  mapRoles: |</span><br><span class="line">    - groups:</span><br><span class="line">      - system:bootstrappers</span><br><span class="line">      - system:nodes</span><br><span class="line">      rolearn: arn:aws:iam::123:role/AmazonEKSNodeRole</span><br><span class="line">      username: system:node:&#123;&#123;EC2PrivateDNSName&#125;&#125;</span><br><span class="line">  mapUsers: |</span><br><span class="line">    - groups:</span><br><span class="line">      - system:masters</span><br><span class="line">      userarn: arn:aws:iam::123:user/eks</span><br><span class="line">      username: eks</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-09-11T06:33:38Z&quot;</span><br><span class="line">  name: aws-auth</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  resourceVersion: &quot;33231&quot;</span><br><span class="line">  uid: 6b186686-548c-4c99-9f65-0381da1366a4</span><br></pre></td></tr></table></figure><p>这里在 <code>data</code> 下新增了 <code>mapUsers</code>，授予用户 <code>eks</code> <code>system:masters</code> 的角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapUsers: |</span><br><span class="line">  - groups:</span><br><span class="line">    - system:masters</span><br><span class="line">    userarn: arn:aws:iam::123:user/eks</span><br><span class="line">    username: eks</span><br></pre></td></tr></table></figure><p>保存后可以通过 <code>kubectl describe configmap -n kube-system aws-auth</code> 验证改动是否生效。然后下载 <code>aws-auth-cm.yaml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o aws-auth-cm.yaml https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/aws-auth-cm.yaml</span><br></pre></td></tr></table></figure><p>将其中的 <code>&lt;ARN of instance role (not instance profile)&gt;</code> 替换为之前创建的 <code>Node IAM role</code>，然后执行 <code>kubectl apply -f aws-auth-cm.yaml</code> 应用修改，执行 <code>kubectl get nodes --watch</code> 观察是否所有的节点的状态都变为了 <code>Ready</code>。</p><p>接着删除本地的 <code>~/.kube/config</code> 来验证权限是否生效。重新运行 <code>aws configure</code> 来设置某个 <code>IAM</code> 用户的信息，因为我们要重新执行 <code>aws eks update-kubeconfig --region us-west-2 --name my-cluster</code> 来生成新的 <code>~/.kube/config</code>，这里要求当前 <code>IAM</code> 用户拥有 <code>DescribeCluster</code> 的权限，这个权限是 <code>AWS</code> 层面的资源访问权限，而不是 <code>EKS</code> 集群的权限，添加权限后可能需要等待几分钟才会生效。当重新生成了 <code>~/.kube/config</code> 文件之后，就可以继续通过 <code>kubectl get all</code> 验证访问权限是否生效。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role">Creating the Amazon EKS cluster role</a></li><li><a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html#create-worker-node-role">Creating the Amazon EKS node IAM role</a></li><li><a href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html">Enabling IAM user and role access to your cluster</a></li><li><a href="https://stackoverflow.com/questions/50791303/kubectl-error-you-must-be-logged-in-to-the-server-unauthorized-when-accessing">kubectl error You must be logged in to the server (Unauthorized) when accessing EKS cluster</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;EKS&lt;/code&gt;（&lt;code&gt;Amazon Elastic Kubernetes Service&lt;/code&gt;）是 &lt;code&gt;</summary>
      
    
    
    
    
    <category term="Kubernetes" scheme="https://frederick-s.github.io/tags/Kubernetes/"/>
    
    <category term="AWS" scheme="https://frederick-s.github.io/tags/AWS/"/>
    
    <category term="EKS" scheme="https://frederick-s.github.io/tags/EKS/"/>
    
  </entry>
  
  <entry>
    <title>Hello Minikube - Apple M1 Max connection reset</title>
    <link href="https://frederick-s.github.io/2022/09/01/hello-minikube-connection-reset-on-apple-m1-max/"/>
    <id>https://frederick-s.github.io/2022/09/01/hello-minikube-connection-reset-on-apple-m1-max/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2022-08-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Apple M1 Max</code> 处理器上按照 <a href="https://kubernetes.io/docs/tutorials/hello-minikube/">Hello Minikube</a> 进行 <code>minikube</code> 的入门教程，不过最后通过本地链接访问的时候出现了 <code>connection reset</code>。按照 <a href="https://github.com/kubernetes/minikube/issues/12036">这里</a> 的描述需要将镜像由 <code>echoserver:1.4</code> 换成适用于 <code>Apple M1 Max</code> 的 <code>echoserver-arm:1.8</code>，即：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment hello-arm --image=registry.k8s.io/echoserver-arm:1.8</span><br></pre></td></tr></table></figure><p>不过帖子中也有人提到换了镜像之后依然无效，所以也不一定对所有人有用。</p><p>参考：</p><ul><li><a href="https://github.com/kubernetes/minikube/issues/12036">Cannot connect to service from localhost on M1 Mac</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Apple M1 Max&lt;/code&gt; 处理器上按照 &lt;a href=&quot;https://kubernetes.io/docs/tutorials/hello-minikube/&quot;&gt;Hello Minikube&lt;/a&gt; 进行 &lt;code&gt;minikube&lt;/c</summary>
      
    
    
    
    
    <category term="Kubernetes" scheme="https://frederick-s.github.io/tags/Kubernetes/"/>
    
    <category term="minikube" scheme="https://frederick-s.github.io/tags/minikube/"/>
    
  </entry>
  
  <entry>
    <title>Buddy Memory Allocation</title>
    <link href="https://frederick-s.github.io/2022/07/03/buddy-memory-allocation/"/>
    <id>https://frederick-s.github.io/2022/07/03/buddy-memory-allocation/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>Buddy Memory Allocation</code> 是内存分配算法的一种，它假定内存的大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>（<code>N</code> 为整数），并且总是以2的幂次方为单位分配或者释放内存。</p><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><p>假设某个线程需要申请 <code>m</code> 字节内存，<code>Buddy Memory Allocation</code> 会先在当前所有的空闲空间中找到最小的空间满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">2^k \geq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的一半依然大于等于 <code>m</code>，说明当前分配的空间过大，则继续将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>对半分（分裂后的这两块内存区域就成为了互为兄弟关系（<code>buddies</code>）），不断重复上述操作，直到找到最小的 <code>p</code>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">p \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>）满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>m</mi><mo>≤</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">2^{p - 1} &lt; m \leq 2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span>。</p><p>下图描述了从16字节中分配3字节的过程（假设系统总共只有16字节内存）：</p><ol><li>初始状态整个内存只有16字节，是可分配的最小空间；不过由于16字节的一半大于3字节，所以将16字节拆分为两个8字节</li><li>同理一个8字节的一半依然大于3字节，继续将其中一个8字节拆分为两个4字节</li><li>4字节的一半比3字节小，所以4字节就是可分配的最小内存空间</li></ol><p><img src="/images/buddy-1.png" alt="alt" /></p><p>当某个线程需要释放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的内存时，<code>Buddy Memory Allocation</code> 会尝试将这个内存空间及其相邻的兄弟空间一起合并得到一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>大小的空间，然后一直重复此操作，直到某块内存空间无法和其兄弟空间合并，无法合并的情况有三种：</p><ol><li>当前分配的内存空间大小为整个内存空间的大小，所以也就没有兄弟空间</li><li>兄弟空间已全部分配</li><li>兄弟空间已局部分配</li></ol><p>下图描述了从16字节中释放3字节的过程（假设系统总共只有16字节内存）：</p><ol><li>当前系统分配了一个2字节的空间和一个4字节的空间</li><li>此时需要回收被占用的2字节，由于它的兄弟空间没有被占用，所以两个2字节的空间合并为一个4字节的空间</li><li>合并后的4字节的空间的兄弟空间同样没有被占用，两个4字节的空间继续合并为1个8字节的空间</li><li>合并后的8字节的空间的兄弟空间存在部分占用，无法继续合并</li></ol><p><img src="/images/buddy-2.png" alt="alt" /></p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3><p>首先定义一个 <code>Memory</code> 类来表示内存，其内部使用一个 <code>byte</code> 数组来存储数据，数组的索引就是内存地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memory</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;size should be greater than zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.memory = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，<code>Memory</code> 类还支持 <code>bool</code> 和 <code>int32</code> 类型的数据读写，从实现的简化考虑，<code>bool</code> 值的读写以一个 <code>byte</code> 为单位；而 <code>int32</code> 的读写以4个 <code>byte</code> 为单位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定的地址设置布尔值，占据一字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBool</span><span class="params">(<span class="type">int</span> address, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.memory[address] = value ? (<span class="type">byte</span>) <span class="number">1</span> : (<span class="type">byte</span>) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的地址读取布尔值，读取一字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getBool</span><span class="params">(<span class="type">int</span> address)</span> &#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.memory[address] == (<span class="type">byte</span>) <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给定的地址设置 int32，占据4字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInt32</span><span class="params">(<span class="type">int</span> address, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = ByteBuffer.allocate(Constant.INT32_SIZE).putInt(value).array();</span><br><span class="line">    setByteArray(address, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的地址读取 int32，读取4字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInt32</span><span class="params">(<span class="type">int</span> address)</span> &#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (address + Constant.INT32_SIZE &gt; <span class="built_in">this</span>.memory.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;address overflow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[Constant.INT32_SIZE];</span><br><span class="line"></span><br><span class="line">    System.arraycopy(<span class="built_in">this</span>.memory, address, bytes, <span class="number">0</span>, Constant.INT32_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(bytes).getInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block"><a class="markdownIt-Anchor" href="#block"></a> Block</h3><p>定义 <code>Block</code> 表示系统所分配的内存块，其中 <code>address</code> 表示该 <code>Block</code> 的起始内存地址，同时 <code>Block</code> 借助 <code>Memory</code> 对内存实现读写操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">(<span class="type">int</span> address, Memory memory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (address &lt; <span class="number">0</span> || address &gt;= memory.getSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(memory, <span class="string">&quot;memory should not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了一个 <code>Block</code> 在内存中的布局：</p><p><img src="/images/buddy-3.png" alt="alt" /></p><p>一个 <code>Block</code> 除了包含用户数据外还需要保存元数据，所以每个 <code>Block</code> 占据的内存会大于用户实际申请的内存；元数据中的第一个字节表示当前内存块是否被使用；第2到5字节表示 <code>sizeClass</code>，用来计算当前内存块所占据的内存的大小，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{sizeClass}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span></span>；第6到9字节表示前一个空闲内存块的地址；第10到13字节表示后一个空闲内存块的地址；从第14字节开始就是用户数据。当然，这只是一种很粗犷的布局方式，实际应用中的布局必然比这个精炼。</p><p>这里需要前一个/后一个空闲内存块的地址是因为将相同大小的内存块通过双向链表的方式串联在一起，从而能快速找到以及删除某个指定大小的内存块。因为 <code>Buddy Memory Allocation</code> 始终以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>大小分配内存，假设系统的最大内存为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>，则可以建立 <code>N</code> 个双向链表，每个双向链表表示当前大小下可用的内存块，如下图所示：</p><p><img src="/images/buddy-4.png" alt="alt" /></p><p><code>Block</code> 通过 <code>Memory</code> 类提供的 <code>bool</code>，<code>int32</code> 数据的读写功能来实现对元数据的读写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 block 标记为已使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memory.setBool(<span class="built_in">this</span>.address, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 block 是否已使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUsed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.memory.getBool(<span class="built_in">this</span>.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放当前 block</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memory.setBool(<span class="built_in">this</span>.address, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 sizeClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSizeClass</span><span class="params">(<span class="type">int</span> sizeClass)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memory.setInt32(<span class="built_in">this</span>.address + Constant.OFFSET_SIZE_CLASS, sizeClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前 block 的 sizeClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSizeClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.memory.getInt32(<span class="built_in">this</span>.address + Constant.OFFSET_SIZE_CLASS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置前一个空闲的 block</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrev</span><span class="params">(Block block)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memory.setInt32(<span class="built_in">this</span>.address + Constant.OFFSET_PREV, block.getAddress());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前一个空闲的 block</span></span><br><span class="line"><span class="keyword">public</span> Block <span class="title function_">getPrev</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">address</span> <span class="operator">=</span> <span class="built_in">this</span>.memory.getInt32(<span class="built_in">this</span>.address + Constant.OFFSET_PREV);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> address == -<span class="number">1</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">Block</span>(address, <span class="built_in">this</span>.memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置后一个空闲的 block</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Block block)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.memory.setInt32(<span class="built_in">this</span>.address + Constant.OFFSET_NEXT, block.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后一个空闲的 block</span></span><br><span class="line"><span class="keyword">public</span> Block <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">address</span> <span class="operator">=</span> <span class="built_in">this</span>.memory.getInt32(<span class="built_in">this</span>.address + Constant.OFFSET_NEXT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> address == -<span class="number">1</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">Block</span>(address, <span class="built_in">this</span>.memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="blocklist"><a class="markdownIt-Anchor" href="#blocklist"></a> BlockList</h3><p><code>BlockList</code> 表示一个双向链表，用于存储某个 <code>sizeClass</code> 下的所有空闲内存块，为了实现方便，内部使用了一个哨兵头节点来作为双向链表的头节点，新节点的插入采用头插法的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> buddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Block head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sizeClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockList</span><span class="params">(<span class="type">int</span> address, Memory memory, <span class="type">int</span> sizeClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (address &lt; <span class="number">0</span> || address &gt;= memory.getSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(memory, <span class="string">&quot;memory cannot be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sizeClass &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid sizeClass&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Block</span>(address, memory);</span><br><span class="line">        <span class="built_in">this</span>.head.setSizeClass(sizeClass);</span><br><span class="line">        <span class="built_in">this</span>.sizeClass = sizeClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空列表，将头节点指向自身</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head.setNext(<span class="built_in">this</span>.head);</span><br><span class="line">        <span class="built_in">this</span>.head.setPrev(<span class="built_in">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列表是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head.getNext().equals(<span class="built_in">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头节点的后一个节点</span></span><br><span class="line">    <span class="keyword">public</span> Block <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;list must not be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头插法插入一个 block</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFront</span><span class="params">(Block block)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head.insertAfter(block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前列表是否有空闲的内存块，以及该内存块是否能容纳 size 大小的数据（减去元数据占用的内存大小后）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAvailableBlock</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">this</span>.isEmpty() &amp;&amp; Block.getActualSize(<span class="built_in">this</span>.sizeClass) &gt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有空闲内存块的数量，不包含哨兵头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Block</span> <span class="variable">block</span> <span class="operator">=</span> <span class="built_in">this</span>.head.getNext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!block.equals(<span class="built_in">this</span>.head)) &#123;</span><br><span class="line">            length += <span class="number">1</span>;</span><br><span class="line">            block = block.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于需要通过哨兵头节点访问下一个可用的内存块，所以每个哨兵头节点就需要知道下一个 <code>Block</code> 的内存起始地址，因此同样需要将哨兵头节点的信息保存在内存中，对于内存大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>的系统来说，一共需要保存 <code>N</code> 个哨兵头节点的信息，这里将内存分为两部分，前一部分保存所有的哨兵头节点，后一部分保存所有的 <code>Block</code>：</p><p><img src="/images/buddy-5.png" alt="alt" /></p><p>因此第一个 <code>Block</code> 的内存起始位置也就等于所有哨兵节点的大小之和。</p><h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><p>定义 <code>Allocator</code> 负责内存的分配和回收，本质上是对 <code>Block</code> 的管理，即 <code>Block</code> 的分裂和合并：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockList[] blockLists;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SIZE_CLASS</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE_CLASS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Allocator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">allHeadSentinelSize</span> <span class="operator">=</span> <span class="built_in">this</span>.getMemoryOffset();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxMemorySize</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; MAX_SIZE_CLASS) + allHeadSentinelSize;</span><br><span class="line">        <span class="built_in">this</span>.memory = <span class="keyword">new</span> <span class="title class_">Memory</span>(maxMemorySize);</span><br><span class="line">        <span class="built_in">this</span>.blockLists = <span class="keyword">new</span> <span class="title class_">BlockList</span>[MAX_SIZE_CLASS];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化空闲列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SIZE_CLASS; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sizeClass</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">headSentinelAddress</span> <span class="operator">=</span> Constant.HEAD_SENTINEL_SIZE * i;</span><br><span class="line">            <span class="built_in">this</span>.blockLists[i] = <span class="keyword">new</span> <span class="title class_">BlockList</span>(headSentinelAddress, <span class="built_in">this</span>.memory, sizeClass);</span><br><span class="line">            <span class="built_in">this</span>.blockLists[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The single full block</span></span><br><span class="line">        <span class="type">Block</span> <span class="variable">block</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(allHeadSentinelSize, <span class="built_in">this</span>.memory);</span><br><span class="line">        block.setSizeClass(MAX_SIZE_CLASS);</span><br><span class="line">        block.setFree();</span><br><span class="line">        <span class="built_in">this</span>.blockLists[MAX_SIZE_CLASS - <span class="number">1</span>].insertFront(block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们假设系统最大能支持的内存大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>个字节，由于哨兵节点也需要占用一部分内存，所以在构造函数中初始化 <code>Memory</code> 的大小为所有哨兵节点占用的内存大小加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> 个字节。同时，系统可分配的 <code>Block</code> 的大小分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，…，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding="application/x-tex">2^{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，对应需要初始化16个双向链表，这里简单的使用数组来保存这16个双向链表，并初始化对应哨兵头节点的内存起始地址。同时，整个系统在初始状态只有一个 <code>Block</code>，大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>。</p><h4 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h4><p>如前面所述，内存分配的第一步是找到满足用户内存需求的最小的 <code>Block</code>，然后如果 <code>Block</code> 过大则继续将 <code>Block</code> 进行分裂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">alloc</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">Block</span> <span class="variable">block</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SIZE_CLASS; i++) &#123;</span><br><span class="line">        <span class="type">BlockList</span> <span class="variable">blockList</span> <span class="operator">=</span> <span class="built_in">this</span>.blockLists[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到满足用户内存需求的最小的 Block</span></span><br><span class="line">        <span class="keyword">if</span> (!blockList.hasAvailableBlock(size)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        block = blockList.getFirst();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将 block 分裂</span></span><br><span class="line">        block = <span class="built_in">this</span>.split(block, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 block 标记为已使用</span></span><br><span class="line">        block.setUsed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;memory is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有返回 block 的起始地址，因为 block 的起始地址指向的是元数据，实际需要返回用户数据的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> block.getUserAddress();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Block 分裂（如果能分裂的话），返回分裂后的左兄弟</span></span><br><span class="line"><span class="keyword">private</span> Block <span class="title function_">split</span><span class="params">(Block block, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeClass</span> <span class="operator">=</span> block.getSizeClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 block 的一半（减去元数据占据的空间后）仍能容纳 size，则持续将 block 分裂</span></span><br><span class="line">    <span class="comment">// 由于 block 本身需要存储元数据，每个 block 至少需要 2^MIN_SIZE_CLASS 字节</span></span><br><span class="line">    <span class="keyword">while</span> (sizeClass &gt; MIN_SIZE_CLASS &amp;&amp; Block.getActualSize(sizeClass - <span class="number">1</span>) &gt;= size) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newSizeClass</span> <span class="operator">=</span> sizeClass - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 block 分裂为两个，取第一个继续分裂</span></span><br><span class="line">        Block[] buddies = <span class="built_in">this</span>.splitToBuddies(block, newSizeClass);</span><br><span class="line">        block = buddies[<span class="number">0</span>];</span><br><span class="line">        sizeClass = newSizeClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 block 从空闲链表中删除</span></span><br><span class="line">    block.removeFromList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Block[] splitToBuddies(Block block, <span class="type">int</span> sizeClass) &#123;</span><br><span class="line">    block.removeFromList();</span><br><span class="line">    Block[] buddies = <span class="keyword">new</span> <span class="title class_">Block</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新分裂后的 block 的起始地址和 sizeClass，并标记为可用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">address</span> <span class="operator">=</span> block.getAddress() + (<span class="number">1</span> &lt;&lt; sizeClass) * i;</span><br><span class="line">        buddies[i] = <span class="keyword">new</span> <span class="title class_">Block</span>(address, <span class="built_in">this</span>.memory);</span><br><span class="line">        buddies[i].setFree();</span><br><span class="line">        buddies[i].setSizeClass(sizeClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里从后往前遍历 buddies 插入到双链表中是因为最后返回给用户的是第一个 buddy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockLists[sizeClass - <span class="number">1</span>].insertFront(buddies[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buddies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h4><p>应用程序要求释放内存时，提交的是用户数据的起始地址，需要先将其转为 <code>Block</code> 的起始地址（减去 <code>Block</code> 元数据的占用空间大小即可），然后尝试将 <code>Block</code> 和其兄弟合并，并将合并后的 <code>Block</code> 加入到空闲列表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(<span class="type">int</span> userAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据用户数据地址得到 Block 的起始地址</span></span><br><span class="line">    <span class="type">Block</span> <span class="variable">block</span> <span class="operator">=</span> Block.fromUserAddress(userAddress, <span class="built_in">this</span>.memory);</span><br><span class="line">    block.setFree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将 block 和其兄弟合并</span></span><br><span class="line">    <span class="built_in">this</span>.merge(block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Block block)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeClass</span> <span class="operator">=</span> block.getSizeClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多只能合并到 MAX_SIZE_CLASS - 1</span></span><br><span class="line">    <span class="keyword">while</span> (sizeClass &lt; MAX_SIZE_CLASS) &#123;</span><br><span class="line">        <span class="comment">// 得到兄弟 block</span></span><br><span class="line">        <span class="type">Block</span> <span class="variable">buddy</span> <span class="operator">=</span> <span class="built_in">this</span>.getBuddy(block, sizeClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟 block 正在被使用或者已分裂为更小的 block，则不能合并</span></span><br><span class="line">        <span class="keyword">if</span> (buddy.isUsed() || buddy.getSizeClass() != sizeClass) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将兄弟 block 从空闲链表中删除</span></span><br><span class="line">        buddy.removeFromList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果兄弟 block 的起始地址比 block 的起始地址小，说明当前的 block 是右兄弟，由于合并后需要得到整个 block 的起始地址，因此将 block 指向 buddy</span></span><br><span class="line">        <span class="keyword">if</span> (block.getAddress() &gt; buddy.getAddress()) &#123;</span><br><span class="line">            block = buddy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sizeClass += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置合并后的 sizeClass</span></span><br><span class="line">    block.setSizeClass(sizeClass);</span><br><span class="line">    <span class="built_in">this</span>.blockLists[sizeClass - <span class="number">1</span>].insertFront(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个关键的问题在于如何根据 <code>block</code> 的地址知道其兄弟 <code>block</code> 的地址？因为一个 <code>block</code> 会被分为左兄弟和右兄弟两个内存块，如果当前 <code>block</code> 是左兄弟，则右兄弟的地址为 <code>block.getAddress() + 1 &lt;&lt; sizeClass</code>，如果当前 <code>block</code> 是右兄弟，则左兄弟的地址为 <code>block.getAddress() - 1 &lt;&lt; sizeClass</code>。然而由于缺失位置信息我们并不能知道一个 <code>block</code> 是左兄弟还是右兄弟。</p><p>原作者在这里巧妙的在不引入额外的元数据的情况下解决了这个问题。首先，对于某个 <code>sizeClass</code> 为 <code>k</code> 的内存块来说，它的起始地址一定是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，其中 <code>C</code> 为整数。这里使用数学归纳法来证明，假设系统内存最多支持<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>个字节，则初始状态下整个系统只有一个内存块，<code>k</code> 就等于 <code>N</code>，该内存块的起始地址为0，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，取 <code>C = 0</code> 即可。假设某个 <code>sizeClass</code> 为 <code>k</code> 的内存块的起始地址满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则需要进一步证明分裂后的两个内存块的起始地址为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C&#x27;2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。而分裂后的内存块的起始地址分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C2^k + 2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，又<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>C</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C2^k = (2C)2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>C</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C2^k + 2^{k - 1} = (2C+ 1)2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，证明完毕。同时，由这些公式可以发现，对于左兄弟内存块来说，<code>C</code> 是偶数，而对于右兄弟内存块来说 <code>C</code> 是奇数。更进一步来说，左右兄弟内存块的地址差异仅在于从低位往高位数的第 <code>k + 1</code> 位不同。</p><p>因此，根据某个内存块的地址推算出兄弟内存块的地址只需要将当前内存块的地址从低位往高位数第 <code>k + 1</code> 位反转即可。这种涉及反转比特位的操作就可以使用异或运算，我们可以将内存块的地址和 <code>1 &lt;&lt; sizeClass</code>（也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>）进行异或运算，得到的地址就是对应兄弟内存块的地址。</p><p>另外，由于哨兵头节点的存在，<code>Memory</code> 内部的数组大小不是严格的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，在计算兄弟内存块的地址时，可以先将当前内存块的地址减去哨兵头节点的大小之和，计算出兄弟内存块的地址之后，再加回偏移量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Block <span class="title function_">getBuddy</span><span class="params">(Block block, <span class="type">int</span> sizeClass)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">virtualAddress</span> <span class="operator">=</span> block.getAddress() - <span class="built_in">this</span>.getMemoryOffset();</span><br><span class="line">    <span class="type">int</span> <span class="variable">buddyVirtualAddress</span> <span class="operator">=</span> virtualAddress ^ (<span class="number">1</span> &lt;&lt; sizeClass);</span><br><span class="line">    <span class="type">int</span> <span class="variable">buddyAddress</span> <span class="operator">=</span> buddyVirtualAddress + <span class="built_in">this</span>.getMemoryOffset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Block</span>(buddyAddress, <span class="built_in">this</span>.memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>以上仅作为 <code>Buddy Memory Allocation</code> 算法的示例，不具有实际应用意义，例如完全没有考虑线程安全。完整的代码可参考原作者的 <a href="https://github.com/kunigami/blog-examples/blob/master/buddy-algorithm/buddy_algorithm.py">代码</a> 及 <code>Java</code> 版本的 <a href="https://github.com/Frederick-S/buddy-memory-allocation">buddy-memory-allocation</a>。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://www.kuniga.me/blog/2020/07/31/buddy-memory-allocation.html">Buddy Memory Allocation</a></li><li><a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/Buddy.html#buddy-methods">Buddy Methods</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Buddy Memory Allocation&lt;/code&gt; 是内存分配算法的一种，它假定内存的大小为&lt;span class=&quot;ka</summary>
      
    
    
    
    
    <category term="Memory Allocation" scheme="https://frederick-s.github.io/tags/Memory-Allocation/"/>
    
  </entry>
  
  <entry>
    <title>A Template Engine - 简易模板引擎实现</title>
    <link href="https://frederick-s.github.io/2022/06/25/simple-template-engine/"/>
    <id>https://frederick-s.github.io/2022/06/25/simple-template-engine/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-06-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文内容主要来源于 <a href="https://aosabook.org/en/500L/a-template-engine.html">A Template Engine</a>。</p></blockquote><h2 id="支持的语法"><a class="markdownIt-Anchor" href="#支持的语法"></a> 支持的语法</h2><p>首先来看一下这个模板引擎所支持的语法。</p><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>使用 <code>&#123;&#123; variable &#125;&#125;</code> 来表示变量，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>user_name</code> 是 <code>Tom</code>，则最后渲染的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Welcome, Tom!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="对象属性和方法"><a class="markdownIt-Anchor" href="#对象属性和方法"></a> 对象属性和方法</h3><p>除了字面量外，模板引擎的变量还支持复杂对象，可以通过点操作符来访问对象的属性或方法，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;The price is: &#123;&#123;product.price&#125;&#125;, with a &#123;&#123;product.discount&#125;&#125;% discount.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>注意如果访问的是对象的方法，则不需要在方法名后添加 <code>()</code>，模板引擎会自动解析并调用方法。</p><p>同时，还可以使用管道操作符来链式调用过滤器，从而改变所渲染的变量值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Short name: &#123;&#123;story.subject|slugify|lower&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h3><p>使用 <code>&#123;% if condition %&#125; body &#123;% endif %&#125;</code> 来表示条件判断，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user.is_logged_in %&#125;</span><br><span class="line">    &lt;p&gt;Welcome, &#123;&#123; user.name &#125;&#125;!&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3><p>使用 <code>&#123;% for item in list %&#125; body &#123;% endfor %&#125;</code> 来表示循环，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Products:&lt;/p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for product in product_list %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; product.name &#125;&#125;: &#123;&#123; product.price|format_price &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><p>使用 `` 来表示注释，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;# This is the best template ever! #&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>一般来说，一个模板引擎主要做两件事：模板解析和渲染。这里要实现的模板引擎的渲染包括：</p><ul><li>管理动态数据</li><li>执行逻辑语句，例如 <code>if</code>，<code>for</code></li><li>实现点操作符访问和过滤器执行</li></ul><p>类似于编程语言的实现，模板引擎的解析也可以分为解释型和编译型两种。对于解释型来说，模板解析阶段需要生成某个特定的数据结构，然后在渲染阶段遍历该数据结构并执行所遇到的每一条指令；而对于编译型来说，模板解析阶段直接生成可执行代码，而渲染阶段则大大简化，直接执行代码即可。</p><p>本文描述的模板引擎采用编译型的方式，原文的作者将模板编译为了 <code>Python</code> 代码，这里为了进一步加深理解，实现了 <code>.NET Core</code> 版本的简单编译。</p><h2 id="编译为-c-代码"><a class="markdownIt-Anchor" href="#编译为-c-代码"></a> 编译为 C# 代码</h2><p>在介绍模板引擎实现之前，先来看一下模板引擎编译出的 <code>C#</code> 代码示例，对于如下的模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Welcome, &#123;&#123;userName&#125;&#125;!&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Products:&lt;/p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for product in productList %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; product.Name &#125;&#125;:</span><br><span class="line">        &#123;&#123; product.Price|FormatPrice &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>模板引擎会生成类似于下面的代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Render</span>(<span class="params">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; Context Context, Func&lt;<span class="built_in">object</span>, <span class="built_in">string</span>[], <span class="built_in">object</span>&gt; ResolveDots</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> userName = Context[<span class="string">&quot;userName&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> productList = Context[<span class="string">&quot;productList&quot;</span>];</span><br><span class="line">    result.AddRange(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123;<span class="string">&quot;&lt;p&gt;Welcome, &quot;</span>, Convert.ToString(userName), <span class="string">&quot;!&lt;/p&gt;&lt;p&gt;Products:&lt;/p&gt;&lt;ul&gt;&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> product <span class="keyword">in</span> <span class="title">ConvertToEnumerable</span>(<span class="params">productList</span>))</span> &#123;</span><br><span class="line">        result.AddRange(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123;<span class="string">&quot;&lt;li&gt;&quot;</span>, Convert.ToString(ResolveDots(product, <span class="keyword">new</span> [] &#123; <span class="string">&quot;Name&quot;</span> &#125;)), <span class="string">&quot;:&quot;</span>, Convert.ToString(FormatPrice(ResolveDots(product, <span class="keyword">new</span> [] &#123; <span class="string">&quot;Price&quot;</span> &#125;))), <span class="string">&quot;&lt;/li&gt;&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    result.Add(<span class="string">&quot;&lt;/ul&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="built_in">string</span>.Empty, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>Context</code> 表示全局上下文，用于获取渲染需要的动态数据，例如例子中的 <code>userName</code>，<code>Render</code> 方法会先从 <code>Context</code> 中提取出模板中所有需要的变量；<code>ResolveDots</code> 是一个函数指针，用于执行点操作符调用；而变量的值都会通过 <code>Convert.ToString</code> 转为字符串。</p><p>模板引擎的最终产物是一个字符串，所以在 <code>Render</code> 中先使用一个 <code>List</code> 保存每一行的渲染结果，最后再将 <code>List</code> 转换为字符串。</p><p><code>.NET</code> 编译器提供了 <code>Microsoft.CodeAnalysis.CSharp.Scripting</code> 包来将某段字符串当做 <code>C#</code> 代码执行，所以最终模板引擎生成的代码将通过如下方式执行：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> code = <span class="string">&quot;some code&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> scriptOptions = ScriptOptions.Default.WithImports(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;System.Collections.Generic&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> script = CSharpScript.RunAsync(code, scriptOptions, yourCustomGlobals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script.Result.ReturnValue.ToString();</span><br></pre></td></tr></table></figure><h2 id="模板引擎编写"><a class="markdownIt-Anchor" href="#模板引擎编写"></a> 模板引擎编写</h2><h3 id="template"><a class="markdownIt-Anchor" href="#template"></a> Template</h3><p><code>Template</code> 是整个模板引擎的核心类，它首先通过模板和全局上下文初始化一个实例，然后调用 <code>Render</code> 方法来渲染模板：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;numbers&quot;</span>, <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> text = <span class="string">@&quot;&lt;ol&gt;&#123;% for number in numbers %&#125;&lt;li&gt;&#123;&#123; number &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ol&gt;&quot;</span>;</span><br><span class="line">Template template = <span class="keyword">new</span> Template(text, context);</span><br><span class="line"><span class="built_in">string</span> result = template.Render();</span><br></pre></td></tr></table></figure><p>这里将 <code>text</code> 传入 <code>Template</code> 的构造函数后，会在构造函数中完成模板解析，后续的 <code>Render</code> 调用都不需要再执行模板解析。</p><h3 id="codebuilder"><a class="markdownIt-Anchor" href="#codebuilder"></a> CodeBuilder</h3><p>在介绍 <code>Template</code> 的实现之前，需要先了解下 <code>CodeBuilder</code>，<code>CodeBuilder</code> 用于辅助生成 <code>C#</code> 代码，<code>Template</code> 通过 <code>CodeBuilder</code> 添加代码行，以及管理缩进（原文的作者使用 <code>Python</code> 作为编译的目标语言所以这里需要维护正确的缩进，<code>C#</code> 则不需要），并最终通过 <code>CodeBuilder</code> 得到可执行代码。</p><p><code>CodeBuilder</code> 内部维护了一个类型为 <code>List&lt;object&gt;</code> 的变量 <code>Codes</code> 来表示代码行，这里的 <code>List</code> 容器类型不是字符串是因为 <code>CodeBuilder</code> 间可以嵌套，一个 <code>CodeBuilder</code> 可以作为一个完整的逻辑单元添加到另一个 <code>CodeBuilder</code> 中，并最终通过自定义的 <code>ToString</code> 方法来生成可执行代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CodeBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> IndentStep = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBuilder</span>()</span></span><br><span class="line"><span class="function">        : <span class="title">this</span>(<span class="params"><span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBuilder</span>(<span class="params"><span class="built_in">int</span> indentLevel</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Codes = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">        <span class="keyword">this</span>.IndentLevel = indentLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="built_in">object</span>&gt; Codes</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> IndentLevel</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CodeBuilder</code> 的 <code>AddLine</code> 方法非常简单，即根据缩进层级补齐空格后添加一行代码（这里 <code>C#</code> 版本保留了 <code>Python</code> 版本缩进的功能）：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddLine</span>(<span class="params"><span class="built_in">string</span> line</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Codes.AddRange(<span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27; &#x27;</span>, <span class="keyword">this</span>.IndentLevel), line, <span class="string">&quot;\n&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Indent</code> 和 <code>Dedent</code> 用于管理 <code>Python</code> 代码的缩进层级：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Indent</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.IndentLevel += IndentStep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dedent</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.IndentLevel -= IndentStep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddSection</code> 用于创建一个新的 <code>CodeBuilder</code> 对象，并将其添加到当前 <code>CodeBuilder</code> 的代码行中，后续对子 <code>CodeBuilder</code> 的修改都会反应到父 <code>CodeBuilder</code> 中：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CodeBuilder <span class="title">AddSection</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    CodeBuilder section = <span class="keyword">new</span> CodeBuilder(<span class="keyword">this</span>.IndentLevel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.Codes.Add(section);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重写了 <code>ToString()</code> 方法来生成可执行代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="built_in">string</span>.Empty, <span class="keyword">this</span>.Codes.Select(code =&gt; code.ToString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="template-实现"><a class="markdownIt-Anchor" href="#template-实现"></a> Template 实现</h3><h4 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h4><p>模板引擎的模板解析阶段发生在 <code>Template</code> 的构造函数中：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Template</span>(<span class="params"><span class="built_in">string</span> text, Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Context = context;</span><br><span class="line">    <span class="keyword">this</span>.CodeBuilder = <span class="keyword">new</span> CodeBuilder();</span><br><span class="line">    <span class="keyword">this</span>.AllVariables = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">this</span>.LoopVariables = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.Initialize(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Python</code> 版本的代码支持多个 <code>context</code>，会由构造函数统一合并为一个上下文对象，这里只简单实现仅支持一个 <code>context</code>；<code>AllVariables</code> 用于记录模板 <code>text</code> 中需要用到的变量名，例如 <code>userName</code>，然后在代码生成阶段就可以遍历 <code>AllVariables</code> 并通过 <code>var someName = Context[someName];</code> 生成局部变量；不过由于模板中的变量可能还会有循环语句用到的临时变量，这些变量会记录到 <code>LoopVariables</code> 中，最终代码生成阶段用到的变量为 <code>AllVariables - LoopVariables</code>。</p><p>接着我们再来看 <code>Initialize</code> 方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">string</span> text</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="string">&quot;var result = new List&lt;string&gt;();&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> variablesSection = <span class="keyword">this</span>.CodeBuilder.AddSection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 text</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="built_in">string</span> variableName <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">HashSet</span>&lt;<span class="title">string</span>&gt;(<span class="params"><span class="keyword">this</span>.AllVariables.Except(<span class="keyword">this</span>.LoopVariables</span>)))</span></span><br><span class="line">    &#123;</span><br><span class="line">        variablesSection.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;var &#123;0&#125; = Context[&#123;1&#125;];&quot;</span>, variableName, <span class="keyword">this</span>.ConvertToStringLiteral(variableName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="string">&quot;return string.Join(string.Empty, result);&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Initialize</code> 首先会通过 <code>CodeBuilder</code> 分配一个 <code>List</code> 保存所有的代码行，然后新建一个子 <code>CodeBuilder</code> 来保存所有的局部变量，接着解析 <code>text</code>，在完成 <code>text</code> 的解析后就能知道模板中使用了哪些变量，从而根据 <code>AllVariables - LoopVariables</code> 生成局部变量，最后将所有的代码行转成字符串。</p><p>同时，原文作者在这里有一个优化，相比于在生成的代码中不断的调用 <code>result.Add(xxx)</code>，从性能上考虑可以将多个操作合并为一个即 <code>result.AddRange(new List&lt;string&gt; &#123; xxx &#125;)</code>，从而引出了辅助变量 <code>buffered</code> 和辅助方法 <code>FlushOutput</code>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffered = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlushOutput</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; buffered</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffered.Count == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;result.Add(&#123;0&#125;);&quot;</span>, buffered[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (buffered.Count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;result.AddRange(new List&lt;string&gt; &#123;&#123;&#123;0&#125;&#125;&#125;);&quot;</span>, <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, buffered)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffered.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析 <code>text</code> 时，并不会处理完一个 <code>token</code> 就执行一次 <code>this.CodeBuilder.AddLine</code>，而是将多个 <code>token</code> 的处理结果批量的追加到最终的可执行代码中。</p><p>接着，再回到 <code>Initialize</code> 方法中，由于模板中 <code>if</code>，<code>for</code> 可能存在嵌套，为了正确处理嵌套语句，这里引入一个栈 <code>var operationStack = new Stack&lt;string&gt;();</code> 来处理嵌套关系。例如，假设模板中存在 <code>&#123;% if xxx %&#125; &#123;% if xxx %&#125; &#123;% endif %&#125; &#123;% endif %&#125;</code>，每次遇到 <code>if</code> 时则执行入栈，遇到 <code>endif</code> 时则执行出栈，如果出栈时栈为空则说明 <code>if</code> 语句不完整，并抛出语法错误。</p><p>那么，如何解析 <code>text</code> 呢？这里使用正则表达式来将 <code>text</code> 分割为 <code>token</code>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Regex tokenPattern = <span class="keyword">new</span> Regex(<span class="string">&quot;(?s)(&#123;&#123;.*?&#125;&#125;|&#123;%.*?%&#125;|&#123;#.*?#&#125;)&quot;</span>, RegexOptions.Compiled);</span><br><span class="line"><span class="keyword">var</span> tokens = tokenPattern.Split(text);</span><br></pre></td></tr></table></figure><p>其中正则表达式中的 <code>(?s)</code> 使得 <code>.</code> 能够匹配换行符。</p><p>例如对于模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;&#123;% for number in numbers %&#125;&lt;li&gt;&#123;&#123; number &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>分割后的 <code>tokens</code> 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#x27;&lt;ol&gt;&#x27;,</span><br><span class="line">    &#x27;&#123;% for number in numbers %&#125;&#x27;,</span><br><span class="line">    &#x27;&lt;li&gt;&#x27;,</span><br><span class="line">    &#x27;&#123;&#123; number &#125;&#125;&#x27;,</span><br><span class="line">    &#x27;&lt;/li&gt;&#x27;,</span><br><span class="line">    &#x27;&#123;% endfor %&#125;&#x27;,</span><br><span class="line">    &#x27;&lt;/ol&gt;&#x27;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后我们就可以遍历 <code>tokens</code> 处理了，每种 <code>token</code> 对应一种策略，如果是注释，则忽略：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (token.StartsWith(<span class="string">&quot;&#123;#&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是变量，则解析变量的表达式（表达式解析会在后面介绍）的值，然后再将其转为字符串：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token.StartsWith(<span class="string">&quot;&#123;&#123;&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> expression = <span class="keyword">this</span>.EvaluateExpression(token.Substring(<span class="number">2</span>, token.Length - <span class="number">4</span>).Trim());</span><br><span class="line"></span><br><span class="line">    buffered.Add(<span class="built_in">string</span>.Format(<span class="string">&quot;Convert.ToString(&#123;0&#125;)&quot;</span>, expression));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果是 `</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文内容主要来源于 &lt;a href=&quot;https://aosabook.org/en/500L/a-template-engine.html&quot;&gt;A Template Engine&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;支持的</summary>
      
    
    
    
    
    <category term="Template Engine" scheme="https://frederick-s.github.io/tags/Template-Engine/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 - Spanner: Google’s Globally-Distributed Database</title>
    <link href="https://frederick-s.github.io/2022/06/19/mit-6.824-spanner/"/>
    <id>https://frederick-s.github.io/2022/06/19/mit-6.824-spanner/</id>
    <published>2022-06-18T16:00:00.000Z</published>
    <updated>2022-06-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><code>Spanner</code> 是一个由 <code>Google</code> 设计，构建和部署的可扩展的全球分布式数据库。从高层次的抽象来看，作为一个数据库，<code>Spanner</code> 会将数据进行分片，每个分片构建在一组 <code>Paxos</code> 状态机之上，同时所有的数据存储在世界各地的各个数据中心内。<code>Spanner</code> 使用副本来保证数据库的全球可用性和客户端读取数据的就近访问性；客户端也能自动的在各个副本之间实现故障转移。当数据量或者服务器数量发生变化时，<code>Spanner</code> 能自动的跨服务器对数据进行重分区；同时，<code>Spanner</code> 也能自动的跨服务器（甚至是跨数据中心）迁移数据来应对负载均衡或者异常。<code>Spanner</code> 的扩展性能够支持上百个数据中心内的几百万台服务器，以及几万亿的数据行。</p><p>应用程序可以借助 <code>Spanner</code> 来确保高可用，即使是面对大面积的自然灾害，也可以通过将数据存储在单个大洲或者跨大洲的多个数据中心来保证容错。<code>Spanner</code> 的第一个客户是 <code>F1</code>，<code>F1</code> 是 <code>Google</code> 广告后端的一个重构项目。<code>F1</code> 的每份数据在美国境内存有5个副本。大部分其他的应用程序一般会将数据备份在同一个地理区域内的3到5个数据中心中，不过这在应对极端灾害时的容错性要略差一些。因为在能够容忍1到2个数据中心异常的情况下，大多数的应用程序相比于更进一步的高可用来说更看重低延迟。</p><p><code>Spanner</code> 设计的首要关注点是管理跨数据中心的数据副本，不过设计者依然在 <code>Google</code> 已有的分布式系统设施之上花了大量的时间来设计和实现某些重要的数据库特性。虽然 <code>Bigtable</code> 能满足很多项目的需求，不过依然有很多 <code>Bigtable</code> 的用户反馈在某些场景下 <code>Bigtable</code> 难以胜任：例如涉及复杂、不断改变的数据库模式；或者要求在大范围数据复制场景下保证强一致性。由于半关系型数据模型以及同步复制的特性，很多 <code>Google</code> 的应用选择使用 <code>Megastore</code> 来存储数据，尽管 <code>Megastore</code> 的写性能不是很好。因此，<code>Spanner</code> 从一个类似 <code>Bigtable</code> 的带版本号的键值存储演化为了一个基于时间戳的多版本数据库。<code>Spanner</code> 中的数据保存在半关系型的表中；每个数据存有多个版本，每个版本的数据都自动标记着提交时的时间戳；旧版本的数据可以根据可配置的垃圾回收策略进行回收；应用程序可以读取某个旧的时间戳下的数据。<code>Spanner</code> 支持通用的事务，以及提供了一个基于 <code>SQL</code> 的查询语言。</p><p>作为一个全球分布式数据库，<code>Spanner</code> 提供了几个有趣的特性。首先，应用程序能以合适的粒度动态的调控数据复制的配置。应用程序可以通过配置指定哪个数据中心保存什么样的数据，数据存储的位置距离终端用户有多远（控制读延迟），数据的各个副本间距离有多远（控制写延迟），每个数据要保存几个副本（控制持久性，可用性和读性能）。同时，系统可以动态和透明的在各个数据中心间迁移数据，从而在各数据中心间实现资源的均衡使用。第二，<code>Spanner</code> 实现了两个在分布式数据库中难以实现的功能：提供了外部一致性的读和写，以及在某个时间戳上跨全球数据库的一致性读。这些特性使得 <code>Spanner</code> 能够在全球多数据中心级别支持一致性备份，一致性的 <code>MapReduce</code> 任务执行，以及原子的数据库模式更新，即使执行这些操作时存在进行中的事务也没有关系。</p><p><code>Spanner</code> 通过对事务记录全球提交时间戳来实现上述特性，即使事务可能会被分布式的执行。事务的时间戳体现了串行顺序性。另外，这个串行顺序性满足外部一致性（或者相当于线性一致性）：如果某个事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在另一个事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始执行前完成提交，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳。<code>Spanner</code> 是第一个在全球数据中心级别保证这一特性的系统。</p><p>实现上述特性的关键点是一个全新的 <code>TrueTime</code> <code>API</code> 及其实现。这个 <code>API</code> 直接将时间的不确定性暴露给了使用方，而 <code>Spanner</code> 基于 <code>TrueTime</code> 提供的不确定性时间的范围（后面会提到 <code>TrueTime</code> 返回当前时间时不是返回一个单独的值，而是一个范围，<code>TrueTime</code> 会确保当前时间落在这个范围内）实现了事务的时间戳先后顺序保证。如果这个时间的不确定性范围太大，<code>Spanner</code> 会减缓操作来等待不确定性范围变小。<code>Google</code> 的集群管理软件提供了 <code>TrueTime</code> <code>API</code> 的一种实现。这个实现利用多个现代的基准时钟（<code>GPS</code> 和原子钟）能将时间不确定性控制在很小的一个范围内（一般来说小于10毫秒）。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>本节描述了 <code>Spanner</code> 的结构及其底层实现。然后会再介绍目录（<code>directory</code>），和文件系统中的目录不同，<code>Spanner</code> 中的目录是一个抽象的概念，用于管理数据副本和访问局部性，同时也是数据迁移的最小单元。最后会介绍 <code>Spanner</code> 的数据模型，相比于键值数据库 <code>Spanner</code> 更像是个关系型数据库，以及描述了应用程序如何控制数据的存储位置来实现访问局部性。</p><p>一个 <code>Spanner</code> 的完整部署被称之为 <code>universe</code>。因为 <code>Spanner</code> 在全球级别的数据中心管理数据，所以一共只会有几个运行中的 <code>universe</code>。<code>Google</code> 目前运行了一个测试/体验环境的 <code>universe</code>，一个开发/生产环境的 <code>universe</code>，以及一个仅生产环境的 <code>universe</code>。</p><p>一个 <code>Spanner</code> 实例以一组 <code>zone</code> 的形式来组织，每个 <code>zone</code> 差不多等同于部署了一批 <code>Bigtable</code> 服务器。每个 <code>zone</code> 是一个可管理的部署单元。系统在各个 <code>zone</code> 之间进行数据复制。当上线或者下线数据中心时，可以向运行中的系统添加或者删除 <code>zone</code>。<code>zone</code> 也是物理隔离的单位：一个数据中心内可能有1个或者多个 <code>zone</code>，例如不同应用程序的数据需要分片到同一个数据中心内的不同服务器上。</p><p><img src="/images/spanner-1.png" alt="alt" /></p><p>上图展示了 <code>Spanner</code> 的一个 <code>universe</code> 中各服务器的职责。每个 <code>zone</code> 有一个 <code>zonemaster</code> 和成百上千台 <code>spanserver</code>。<code>zonemaster</code> 向 <code>spanserver</code> 分发数据，<code>spanserver</code> 向客户端提供数据服务。同时，客户端通过每个 <code>zone</code> 内的 <code>location proxy</code> 来确定需要访问哪台 <code>spanserver</code> 获取数据。<code>universe master</code> 和 <code>placement driver</code> 目前是单点的。<code>universe master</code> 主要是一个控制台，用于展示所有 <code>zone</code> 的状态信息，从而方便调试。<code>placement driver</code> 负责自动的在各个 <code>zone</code> 之前进行数据迁移，这个的操作耗时一般是分钟级。出于满足数据副本数量的要求以及实现数据访问的负载均衡，<code>placement driver</code> 会周期性的和 <code>spanserver</code> 通信从而确认哪些数据需要迁移。出于篇幅考虑，论文只会描述 <code>spanserver</code> 的实现细节。</p><h3 id="spanserver-软件栈"><a class="markdownIt-Anchor" href="#spanserver-软件栈"></a> Spanserver 软件栈</h3><p><img src="/images/spanner-2.png" alt="alt" /></p><p>本节主要关注 <code>spanserver</code> 的实现并展示了如何在 <code>Bigtable</code> 的实现之上构建数据复制和分布式事务。上图展示了 <code>spanserver</code> 的软件栈。在底部，每个 <code>spanserver</code> 负责管理100到1000个被称之为 <code>tablet</code> 的数据结构实例。<code>tablet</code> 类似于 <code>Bigtable</code> 中表的抽象，其内部维护了如下的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key:string, timestamp:int64) -&gt; string</span><br></pre></td></tr></table></figure><p>和 <code>Bigtable</code> 不同的是，<code>Spanner</code> 给每一个数据都标记了时间戳，从而使得 <code>Spanner</code> 更像是一个多版本数据库而不是键值存储。每个 <code>tablet</code> 的状态会保存在一组类似 <code>B</code> 树的文件以及一个预写日志中，所有的文件都会保存在一个称之为 <code>Colossus</code>（<code>Google File System</code> 的后继者）的分布式文件系统中。</p><p>为了支持数据复制，每个 <code>spanserver</code> 在每个 <code>tablet</code> 之上构建了一个单 <code>Paxos</code> 状态机（<code>Spanner</code> 的早期设计支持每个 <code>tablet</code> 对应多个 <code>Paxos</code> 状态机，这能支持更灵活的复制配置。不过由于这种设计的复杂性作者最终放弃了）。每个状态机将其元数据和日志保存到对应的 <code>tablet</code> 中。<code>Spanner</code> 的 <code>Paxos</code> 实现支持长期存活的主节点，每个主节点会分配一个基于时间的租约，租期的默认长度是10秒。当前 <code>Spanner</code> 的实现会记录两次 <code>Paxos</code> 的写操作，一次是在 <code>tablet</code> 的日志中，另一次是在 <code>Paxos</code> 的日志中。不过这个目前只是权宜之计，可能会在未来修复。<code>Spanner</code> 的 <code>Paxos</code> 实现能以管道的方式执行，因此在 <code>WAN</code> 环境的延迟下能提高 <code>Spanner</code> 的吞吐；不过提交到 <code>Paxos</code> 的写操作会按照顺序执行。</p><p><code>Spanner</code> 借助 <code>Paxos</code> 状态机实现了一致性的数据映射复制。每个副本的键值映射状态都会保存在相应的 <code>tablet</code> 中。客户端的写操作必须由主节点发起 <code>Paxos</code> 协议；而读操作可以由任意一个有着最新数据的副本执行。这些副本构成了一个 <code>Paxos group</code>。</p><p>对于身为主节点的副本来说，每个 <code>spanserver</code> 实现了一个锁表（<code>lock table</code>）来实现并发控制。锁表包含了两阶段锁的状态：它会将某个范围内的键和锁的状态建立映射（长期存活的主节点是高效管理锁表的关键）。在 <code>Bigtable</code> 和 <code>Spanner</code> 中，锁表都是专门为长时间运行的事务设计的（例如，对于报表生成这样的事务可能需要花费分钟级的时间才能完成），但在锁竞争激烈的情况下使用乐观并发控制策略会造成性能不佳。诸如事务读这样需要同步的操作需要先从锁表中获取锁；其他不涉及同步的操作则无需操作锁表。</p><p>对于身为主节点的副本来说，每个 <code>spanserver</code> 实现了一个事务管理器（<code>transaction manager</code>）来支持分布式事务。事务管理器被用来实现 <code>participant leader</code>；而其他同 <code>Paxos</code> 组内的副本则被称为 <code>participant slaves</code>。如果一个事务只涉及一个 <code>Paxos</code> 组（对于大多数的事务来说），则无需事务管理器介入，因为锁表和 <code>Paxos</code> 一起已经提供了事务功能。如果一个事务涉及多个 <code>Paxos</code> 组，则每个组的主节点需要协同完成两阶段提交。其中某个 <code>Paxos</code> 组会被选为协调者：该组的 <code>participant leader</code> 则会担任 <code>coordinator leader</code>，该组内其他的从节点则担任 <code>coordinator slaves</code>。事务管理器的状态会保存在底层的 <code>Paxos</code> 组中（因此这个状态数据也会存有多个副本）。</p><h3 id="目录和数据放置"><a class="markdownIt-Anchor" href="#目录和数据放置"></a> 目录和数据放置</h3><p>在键值映射之上，<code>Spanner</code> 的实现支持被称为目录（<code>directory</code>）的桶的抽象，目录是一组有着公共前缀的连续键的集合（命名为目录是由于历史的偶然；一个更好的命名可能是桶（<code>bucket</code>））。目录的支持使得应用程序可以通过设置合适的键来控制数据访问的局部性。</p><p>一个目录是数据放置的最小单元。每个目录下的所有数据有着相同的复制配置。数据以目录的形式从一个 <code>Paxos</code> 组迁移到另一个 <code>Paxos</code> 组，下图描述了这个过程。<code>Spanner</code> 可能会移动一个目录来减轻某个 <code>Paxos</code> 组的负载；或者将经常被同时访问的多个目录移动到同一个 <code>Paxos</code> 组中；或者将某个目录移动到距离客户端更近的 <code>Paxos</code> 组中。目录的移动可以和客户端的操作同时进行。一个 <code>50 MB</code> 大小的目录可以在几秒内完成。</p><p><img src="/images/spanner-3.png" alt="alt" /></p><p>一个 <code>Paxos</code> 组可能会包含多个目录说明 <code>Spanner</code> 的 <code>tablet</code> 和 <code>Bigtable</code> 的 <code>tablet</code> 不同：<code>Spanner</code> 的 <code>tablet</code> 没有必要是行空间（<code>row space</code>）内按照字典顺序的连续分区。相反，一个 <code>Spanner</code> 的 <code>tablet</code> 可能包含了行空间的多个分区。正是基于此特性才使得多个同时被访问的目录可以被移动到同一个 <code>Paxos</code> 组中。下图展示了各组成部分间的关系：</p><p><img src="/images/spanner-4.png" alt="alt" /></p><p><code>Spanner</code> 使用 <code>Movedir</code> 这样的后台任务在多个 <code>Paxos</code> 组之间移动目录。<code>Movedir</code> 也被用来向 <code>Paxos</code> 组中添加或者删除副本，因为目前 <code>Spanner</code> 还不支持在 <code>Paxos</code> 内部实现配置变更。<code>Movedir</code> 没有被设计为一个独立的事务，这主要是为了避免在进行大量数据移动时阻塞读写请求。相反，<code>movedir</code> 会在后台开始迁移数据。当 <code>movedir</code> 完成数据迁移，但还剩下一小部分数据未迁移时，则会发起一个事务自动的完成数据的迁移，然后更新涉及的两个 <code>Paxos</code> 组的元数据。</p><p>目录是应用程序能够控制副本的地理位置属性（或者简单来说，数据放置）的最小单位。在 <code>Spanner</code> 的设计中，数据放置规范语言（<code>placement-specification language</code>）和管理副本配置的职责相解耦。管理员可以控制两个维度：副本的数量和类型，以及副本所在的地理位置属性。<code>Spanner</code> 为这两个维度提供了可选的选项（例如，<code>North America, replicated 5 ways with 1 witness</code>）。应用程序通过标记每个数据库和/或者单个目录的复制选项组合来控制数据的复制。例如，某个应用程序可能会将每个终端用户的数据保存在自己的目录中，从而使得用户 <code>A</code> 的数据在欧洲有三个副本，用户 <code>B</code> 的数据在北美有5个副本。</p><p>出于表达清晰的考虑作者简化了这块的描述。实际上，如果某个目录包含的数据过多，<code>Spanner</code> 会将其拆分为多个段（<code>fragment</code>）。不同的段会由不同的 <code>Paxos</code> 组提供服务（也对应了不同的服务器）。<code>Movedir</code> 实际上是在各个 <code>Paxos</code> 组之间移动段，而不是整个目录。</p><h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3><p><code>Spanner</code> 为应用程序提供了如下的数据特性：一个基于模式化半关系型表的数据模型，一个查询语言，以及通用型事务。之所以要支持这些特性是受几方面的驱动。支持模式化半关系型表和同步复制的需求来自于 <code>Megastore</code> 的流行。至少有300个 <code>Google</code> 内部的应用程序选择使用 <code>Megastore</code>（尽管它的性能不是很好），因为它的数据模型比 <code>Bigtable</code> 更简单，而且它也支持跨数据中心的同步数据复制（<code>Bigtable</code> 只支持跨数据中心数据复制的最终一致性）。使用 <code>Megastore</code> 的 <code>Google</code> 应用程序中比较有名的有 <code>Gmail</code>，<code>Picasa</code>，<code>Calendar</code>，<code>Android Market</code> 和 <code>AppEngine</code>。在 <code>Spanner</code> 中支持类似 <code>SQL</code> 的查询语言的需求同样很明确，因为交互式数据分析工具 <code>Dremel</code> 也很流行。最后，希望 <code>Bigtable</code> 支持跨行的事务的呼声也很强烈；开发 <code>Percolator</code> 的部分原因就是为了解决这个问题。某些作者认为通用的两阶段提交的支持成本太大，因为它存在性能和可用性问题。不过，<code>Spanner</code> 的作者认为最好交给应用开发人员来处理由于过度使用事务而产生的性能瓶颈，而不是始终在缺少事务的环境下编程。而在 <code>Paxos</code> 之上实现两阶段提交则减缓了可用性问题。</p><p>应用程序的数据模型构建在目录式的键值数据映射之上。一个应用程序会在一个 <code>universe</code> 中创建一个或者多个数据库。每个数据库可以包含不限制数量的模式化表。<code>Spanner</code> 的表类似于关系型数据库中的表，它同样有行，列，以及带版本的值。本文不会深入探讨 <code>Spanner</code> 的查询语言。它和 <code>SQL</code> 很像不过在这基础之上多了些扩展来支持 <code>protocol-buffer</code> 类型的字段。</p><p><code>Spanner</code> 的数据模型不是纯关系型的，它的行必须有名称。更准确的来说，每张表需要有一个或者多个主键列组成的有序集合。这个要求使得 <code>Spanner</code> 看起来像一个键值存储：主键定义了每行的名称，每个表定义了主键列到非主键列的映射。只有某个主键对应有值（即使值是 <code>NULL</code>）才能被认为某一行存在。采用这个结构使得应用程序能通过选择键来控制数据访问的局部性。</p><p><img src="/images/spanner-5.png" alt="alt" /></p><p>上图展示了 <code>Spanner</code> 数据模式的一个示例，在这个例子中，我们创建了两张表来存储每个用户和每张照片的元数据。<code>Spanner</code> 的模式语言和 <code>Megastore</code> 类似，不过 <code>Spanner</code> 有额外的要求，<code>Spanner</code> 的每个数据库必须由客户端分区为一个或者多个层次化的表。客户端程序通过 <code>INTERLEAVE IN</code> 来声明数据库模式的层次化结构。位于层次化结构顶端的表被称之为 <code>directory table</code>。<code>directory table</code> 中以 <code>K</code> 为键的数据，和关联的子孙表中所有键以 <code>K</code> 为起始的行按照字典顺序组成了一个目录。<code>ON DELETE CASCADE</code> 表明如果删除了 <code>directory table</code> 中的一条数据，则需要一并删除关联的子孙表中的数据。上图也展示了示例数据库的交错结构（<code>interleaved layout</code>）：例如，<code>Albums(2, 1)</code> 表示 <code>Albums</code> 表中 <code>user_id</code> 为2，<code>album_id</code> 为1的数据。这种由交错的表组成的目录对于客户端来说非常重要，因为它使得客户端能够描述不同的表之间的局部性关联，这对于分片、分布式的数据库的高性能来说非常重要。如果缺少这个特性，<code>Spanner</code> 将无从知晓最重要的局部性关联。</p><h2 id="truetime"><a class="markdownIt-Anchor" href="#truetime"></a> TrueTime</h2><p>本节主要描述 <code>TrueTime</code> 的 <code>API</code> 及概述其实现。<code>TrueTime</code> 大部分的细节会在另一篇论文中描述，本文主要是展示它对于 <code>Spanner</code> 的重要性。下表列举了 <code>TrueTime</code> 的 <code>API</code>。<code>TrueTime</code> 以 <code>TTinterval</code> 的形式表示时间，<code>TTinterval</code> 是一段表示非确定性时间的有界区间（而标准时间接口并不会将时间的不确定性暴露给客户端）。<code>TTinterval</code> 两个端点值的类型为 <code>TTstamp</code>。<code>TT.now()</code> 会返回一个 <code>TTinterval</code>，并且保证 <code>TTinterval</code> 所表示的时间区间一定包含 <code>TT.now()</code> 被调用时的绝对时间。这个时间类似于带闰秒的 <code>UNIX</code> 时间。定义时间的瞬时误差上限为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，其值为 <code>TTinterval</code> 区间长度的一半，以及定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>为平均误差上限。<code>TT.after()</code> 和 <code>TT.before()</code> 是基于 <code>TT.now()</code> 的更易用的封装。</p><table><thead><tr><th>Method</th><th>Returns</th></tr></thead><tbody><tr><td>TT.now()</td><td>TTinterval: [earliest, latest]</td></tr><tr><td>TT.after(t)</td><td>true if t has definitely passed</td></tr><tr><td>TT.before(t)</td><td>true if t has definitely not arrived</td></tr></tbody></table><p>记某个事件 <code>e</code> 发生的绝对时间为函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{abs}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>。那么以更正式的术语来说，<code>TrueTime</code> 保证对于某次调用 <code>tt = TT.now()</code>，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo>≤</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>e</mi><mrow><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msub><mo stretchy="false">)</mo><mo>≤</mo><mi>t</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tt.earliest \leq t_{abs}(e_{now}) \leq tt.latest</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">e_{now}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是调用 <code>TT.now()</code> 的事件。</p><p><code>TrueTime</code> 底层使用的时间参照是 <code>GPS</code> 和原子钟。<code>TrueTime</code> 使用两种形式的时间参照是因为它们有着不同的异常模式。<code>GPS</code> 发生异常可能是由于天线或者接收器异常，本地电磁波干扰，某些关联异常（例如设计的缺陷造成无法正确处理闰秒和电子欺骗），以及 <code>GPS</code> 系统瘫痪。原子钟的异常模式和 <code>GPS</code> 无关，不过在经过很长一段时间后可能会因为频率误差造成严重的精度缺失。</p><p><code>TrueTime</code> 的实现由每个数据中心中的一组 <code>time master</code> 机器完成，每个机器上存在一个 <code>timeslave</code> 守护进程。大多数的 <code>time master</code> 安装了具有专用天线的 <code>GPS</code> 接收器；这些机器在物理上相互隔离，从而降低天线异常，电磁波干扰和电子欺骗的影响。剩下的 <code>time master</code>（被称之为 <code>Armageddon masters</code>）则配有原子钟。一个原子钟并不是太昂贵；一个 <code>Armageddon master</code> 的成本和一个 <code>GPS master</code> 的成本相当。各个 <code>time master</code> 会定期的互相对比各自的参照时间。每个 <code>time master</code> 也会对比自己的参照时间和本地时钟，如果两者相差过大则该 <code>time master</code> 会退出集群。在时钟同步期间，<code>Armageddon masters</code> 会保守的根据最差情况的时钟漂移来逐渐增加时间的不确定性。<code>GPS masters</code> 的时间不确定性误差一般接近于0。</p><p>每个 <code>timeslave</code> 守护进程会拉取多个 <code>time master</code> 的参照时间来减少单个 <code>time master</code> 异常造成的时间误差。<code>timeslave</code> 轮询的 <code>time master</code> 一部分来自于就近数据中心的 <code>GPS master</code>；剩下的来自于更远的数据中心的 <code>GPS master</code> 以及一些 <code>Armageddon master</code>。获取到其他 <code>time master</code> 的参照时间后，<code>timeslave</code> 守护进程会通过一种 <code>Marzullo</code> 算法的变种来识别出不可信的值，然后根据可信的值同步本地时钟。为了避免异常的本地时钟造成影响，如果某个机器的时钟误差频繁超过组件规范和工作环境下的误差上限，则该机器会从集群中剔除。</p><p>在时钟同步期间，<code>timeslave</code> 守护进程也会逐渐增加时间的不确定性。记<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>表示保守最差情况下的本地时钟偏移。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的值同时也依赖 <code>time master</code> 的不确定性以及和 <code>time master</code> 的通信延迟。在 <code>Google</code> 的生产环境中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>呈现出随时间变化的锯齿形函数，在每次轮询 <code>time master</code> 间隔间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的值在1到7毫秒内浮动。因此在大多数时间里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>的值为4毫秒。当前 <code>timeslave</code> 守护进程轮询 <code>time master</code> 的时间间隔为30秒，以及时钟漂移速率为200微妙/秒，最后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的浮动范围为0到6毫秒。而剩下的1毫秒则来源于和 <code>time master</code> 的通信延迟。当发生异常时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的偏移范围超过7毫秒也是有可能的。例如，有时候 <code>time master</code> 的不可用会造成数据中心范围内<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>值的增加。类似的，服务器过载以及网络链路异常也有可能造成局部范围内<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的值产生毛刺。</p><h2 id="并发控制"><a class="markdownIt-Anchor" href="#并发控制"></a> 并发控制</h2><p>本节描述了 <code>Spanner</code> 如何使用 <code>TrueTime</code> 来保证并发控制下的正确性特性，以及如何利用这些正确性特性来实现诸如外部一致性事务，无锁只读事务以及非阻塞式的读取旧数据。例如要在某个时间戳 <code>t</code> 对整个数据库做一次审计读取操作，则借助这些特性可以保证这次操作一定能够读取到在时间戳 <code>t</code> 之前已经提交的事务修改。</p><p>另外，将 <code>Paxos</code> 的写操作（除非上下文明确的情况下，后续此操作都被称之为 <code>Paxos writes</code>）和 <code>Spanner</code> 的客户端的写操作区分开非常重要。例如，两阶段提交场景下 <code>Paxos</code> 会在准备阶段执行写操作，这个写操作没有任何相关联的客户端写操作。</p><h3 id="时间戳管理"><a class="markdownIt-Anchor" href="#时间戳管理"></a> 时间戳管理</h3><p>下表列举了 <code>Spanner</code> 支持的操作类型。<code>Spanner</code> 支持读写事务（<code>read-write transactions</code>），只读事务（<code>read-only transactions</code>）（预先声明的快照隔离事务（<code>snapshot-isolation transactions</code>）），和快照读（<code>snapshot reads</code>）。单独的写事务由读写事务实现；单独的非快照读由只读事务实现。两者都会在实现内部执行重试（因此客户端无需编写自己的重试逻辑）。</p><table><thead><tr><th>Operation</th><th>Timestamp Discussion</th><th>Concurrency Control</th><th>Replica Required</th></tr></thead><tbody><tr><td>Read-Write Transaction</td><td>Section 4.1.2</td><td>pessimistic</td><td>leader</td></tr><tr><td>Read-Only Transaction</td><td>Section 4.1.4</td><td>lock-free</td><td>leader for timestamp; any for read, subject to section 4.1.3</td></tr><tr><td>Snapshot Read, client-provided timestamp</td><td>——</td><td>lock-free</td><td>any, subject to section 4.1.3</td></tr><tr><td>Snapshot Read, client-provided bound</td><td>Section 4.1.3</td><td>lock-free</td><td>any, subject to section 4.1.3</td></tr></tbody></table><p>只读事务借助了快照隔离从而有着较好的性能。一个只读事务必须事先声明为不包含任何写操作；它并不简单是一个没有写操作的读写事务。系统会为只读事务选择一个时间戳从而能够以无锁的方式读取以该时间戳为基准的数据，因此也不会阻塞接下来的写操作。只读事务中的读操作可以由任何有着足够新的数据的副本执行。</p><p>快照读指的是读取过去的数据因此也无需加锁。客户端可以为快照读指定一个时间戳或者指定一个期望时间戳的上限，然后由 <code>Spanner</code> 选择一个时间戳。不管在哪种情况下，快照读可以由任何有着足够新的数据的副本执行。</p><p>对于只读事务和快照读来说，一旦确定了时间戳事务的提交就不可避免了，除非该时间戳对应的数据已经被垃圾回收了。因此，客户端可以避免在重试循环中缓冲结果。当某个服务器异常时，客户端可以在另一台服务器上重新以期望的时间戳和当前的数据读取位置继续执行查询操作。</p><h4 id="paxos-主节点租约"><a class="markdownIt-Anchor" href="#paxos-主节点租约"></a> Paxos 主节点租约</h4><p><code>Spanner</code> 的 <code>Paxos</code> 实现使用了基于时间的租约来确保某个主节点长期存活（租期默认是10秒）。主节点的候选者会向其他节点发送请求来获取基于时间的租约投票（<code>lease votes</code>）；当该候选者收到大多数的选票后就知道自己持有了租约。当某个副本成功的执行写入后会同时延长租约选票，而对于主节点来说则会在租期快过期前发起延长租约选票的请求。定义某个主节点的租期区间（<code>lease interval</code>）始于获取了大多数的选票，终于不再持有大多数的选票（因为某些选票已过期）。<code>Spanner</code> 依赖如下的不相交不变式（<code>disjointness invariant</code>）：对于每个 <code>Paxos</code> 组来说，每个 <code>Paxos</code> 主节点的租期区间都和任意其他主节点的租期区间不相交。</p><p><code>Spanner</code> 的实现允许某个 <code>Paxos</code> 主节点通过释放从节点的选票来主动发起主节点退位。为了维持不相交不变式（<code>disjointness invariant</code>），<code>Spanner</code> 会限制在什么情况下才能发起主节点退位。定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示某个主节点使用的最大时间戳。后面章节会描述什么时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>会增加。因此，某个主节点只有等到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TT.after(s_{max})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为真时才能发起退位。</p><h4 id="为读写事务分配时间戳"><a class="markdownIt-Anchor" href="#为读写事务分配时间戳"></a> 为读写事务分配时间戳</h4><p>读写事务需要用到两阶段锁。因此，<code>Spanner</code> 可以在获取所有锁之后，释放任意锁之前为事务分配时间戳。对于某个给定的事务来说，<code>Spanner</code> 会以 <code>Paxos</code> 的写操作的时间戳作为事务的提交时间戳。</p><p><code>Spanner</code> 依赖如下的单调不变式（<code>monotonicity invariant</code>）：在每个 <code>Paxos</code> 组内，即使是多个不同的主节点之间，<code>Spanner</code> 分配给 <code>Paxos</code> 写操作的时间戳都是单调递增的。对于单个主节点来说，分配单调递增的时间戳没有什么困难。<code>Spanner</code> 通过不相交不变式（<code>disjointness invariant</code>）确保了在多个不同的主节点之间也能保证单调不变式（<code>monotonicity invariant</code>）：每个主节点只能分配位于任期区间内的时间戳。每当主节点分配了一个时间戳 <code>s</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（某个主节点使用的最大时间戳）都会更新为 <code>s</code> 来确保不相交不变式（<code>disjointness invariant</code>）。</p><p><code>Spanner</code> 同时也保证了如下的外部一致性不变式（<code>external-consistency invariant</code>）：如果某个事务 <code>T2</code> 的开始时间晚于事务 <code>T1</code> 的提交时间，则 <code>T2</code> 的提交时间戳一定大于 <code>T</code> 的提交时间戳。定义事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的开始和提交事件为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05222em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{commit}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0833279999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>；事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则有不变式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>1</mn><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>s</mi><mn>1</mn><mo>&lt;</mo><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t_{abs}(e_1^{commit}) &lt; t_{abs}(e_2^{start}) \implies s1 &lt; s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043556em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span>。<code>Spanner</code> 中执行事务和分配时间戳的协议遵循了如下的两条规则，从而确保了上述的不变式。定义两阶段提交协议的 <code>coordinator leader</code> 针对某个写操作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发起提交请求对应的事件为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{server}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>。则 <code>Spanner</code> 遵循的两条规则为：</p><ul><li>开始（<code>Start</code>）：在事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{server}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>之后，两阶段提交协议的 <code>coordinator leader</code> 分配给某个写事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不会小于 <code>TT.now().latest</code>。注意 <code>participant leaders</code> 在这一阶段不会参与；4.2.1节会介绍在实现提交等待（<code>Commit Wait</code>）规则时 <code>participant leaders</code> 的职责。</li><li>提交等待（<code>Commit Wait</code>）：两阶段提交协议的 <code>coordinator leader</code> 会确保在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TT.after(s_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>返回真之前客户端不会读取到事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>提交的数据。提交等待（<code>Commit wait</code>）确保了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一定小于事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>提交的绝对时间，或者说<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mi>i</mi><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s_i &lt; t_{abs}(e_i^{commit})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0833279999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。4.2.1节会描述提交等待（<code>Commit wait</code>）的实现。其证明如下：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>s</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>1</mn><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi><mtext> </mtext><mi>w</mi><mi>a</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>1</mn><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo stretchy="false">)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><msub><mi>s</mi><mn>2</mn></msub><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>s</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><msub><mi>s</mi><mn>2</mn></msub><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}s_1 &amp;&lt; t_{abs}(e_1^{commit}) \qquad&amp; (commit \, wait) \\t_{abs}(e_1^{commit}) &amp;&lt; t_{abs}(e_2^{start}) \qquad&amp; (assumption) \\t_{abs}(e_2^{start}) &amp;\le t_{abs}(e_2^{server}) \qquad&amp; (causality) \\t_{abs}(e_2^{server}) &amp;\le s_2 \qquad&amp; (start) \\s_1 &amp;&lt; s_2 \qquad&amp; (transitivity)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.572883999999999em;vertical-align:-3.536441999999999em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.036442em;"><span style="top:-6.161778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.627114000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.123558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435559999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-1.623558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-0.12355800000000094em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.536441999999999em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.036442em;"><span style="top:-6.161778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-4.627114000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435559999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-3.123558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-1.623558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-0.12355800000000094em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.536441999999999em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.036442em;"><span style="top:-6.161778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-4.627114000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-3.123558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-1.623558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-0.12355800000000094em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.536441999999999em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="根据某个时间戳读"><a class="markdownIt-Anchor" href="#根据某个时间戳读"></a> 根据某个时间戳读</h4><p>4.1.2节描述的单调不变式（<code>monotonicity invariant</code>）使得 <code>Spanner</code> 能正确的判断某个副本的状态是否足够满足某个客户端的读请求。每个副本都会记录一个称之为安全时间（<code>safe time</code>）的变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，这表示当前副本拥有到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为止所有已提交事务的修改。因此，只要客户端希望读取的数据的时间戳 <code>t</code> 满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≤</mo><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t \leq t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，则当前副本就能够提供读操作。</p><p>定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{safe} = min(t_{safe}^{Paxos}, t_{safe}^{TM})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>表示每个 <code>Paxos</code> 状态机的安全时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>表示每个事务管理器的安全时间。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的实现很简单：它的值等于最近一次提交的 <code>Paxos</code> 的写操作的时间戳。因为 <code>Spanner</code> 会以单调递增的顺序分配时间戳，加上 <code>Paxos</code> 会按顺序应用写操作，因此某个写入操作一定不会在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>或其之前发生。</p><p>当不存在完成了准备阶段（但事务还未提交）的事务时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>——即两阶段提交协议中已完成准备阶段，但还未完成提交阶段的场景（对于 <code>participant slave</code> 来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>指向的是该副本所属主节点的事务管理器的安全时间，从节点可根据主节点下发的写请求中的元数据推断而来）。如果存在这样的事务，则受这些事务影响的状态是不确定的：因为对于 <code>participant replica</code> 来说并不知道这些事务最终是否会被提交。在4.2.1节会介绍，<code>Spanner</code> 的提交协议确保了每个 <code>participant</code> 能知道某个已准备完成的事务的时间戳的下界。每个 <code>participant leader</code>（对应某个 <code>Paxos</code> 组 <code>g</code>）会为某个事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在准备阶段的日志中记录一个时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">s_{i, g}^{prepare}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>。<code>coordinator leader</code> 会确保对于组 <code>g</code> 中的每一个事务的参与者来说，事务的提交时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>≥</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">s_i \geq s_{i, g}^{prepare}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>。因此，对于组 <code>g</code> 中的每个副本来说，在组 <code>g</code> 内完成准备阶段的所有事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_{safe}^{TM} = min_i(s_{i, g}^{prepare}) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p><h4 id="为只读事务分配时间戳"><a class="markdownIt-Anchor" href="#为只读事务分配时间戳"></a> 为只读事务分配时间戳</h4><p>只读事务会有两阶段来执行：首先会分配一个时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后以快照读的方式来执行读取时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>处的数据。快照读可以由任何有着足够新的数据的副本执行。</p><p>可以简单的选取 <code>TT.now().latest</code> 作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值，则类似于4.1.2节中关于写事务的描述，就一定能读取到在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之前提交的事务修改。然而，如果客户端读取的副本的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>还没有更新（从系统层面来看，某个在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之前提交的事务已执行成功，但当前副本并不一定知道这个信息），为了不破坏外部一致性，避免客户端读取到旧的数据，则可能需要阻塞客户端的读取直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>更新完成（另外，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的选取也会导致<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的更新来确保不相交不变式（<code>disjointness invariant</code>））。为了减少阻塞的可能，<code>Spanner</code> 需要选取满足外部一致性前提下最老的时间戳。4.2.2节会介绍如何选取这个时间戳。</p><h3 id="细节"><a class="markdownIt-Anchor" href="#细节"></a> 细节</h3><p>本节会描述读写事务和之前介绍只读事务时省略的实现细节，以及某种特殊的事务类型实现用来支持原子的模式修改。然后会再描述某些对基础方案的改进。</p><h4 id="读写事务"><a class="markdownIt-Anchor" href="#读写事务"></a> 读写事务</h4><p>类似于 <code>Bigtable</code>，在某个事务提交前，其写操作会在客户端中缓冲。因此，某个事务中的读操作不会读取到同一个事务中的写操作。这个设计能很好的适配 <code>Spanner</code>，因为读取操作会返回被读取数据的时间戳，而未提交的写操作还未被分配时间戳。</p><p>读写事务中的读操作会使用 <code>wound-wait</code> 来避免死锁。客户端向主节点发起读操作，主节点会获取相应的锁然后读取最新的数据。当客户端的事务还在进行中时，它会定期的发送消息来避免 <code>participant leaders</code> 将其事务超时。当客户端完成所有的读操作以及缓冲了所有的写操作时，它就会开始执行两阶段提交。客户端会首先选择一个协调者组（<code>coordinator group</code>），然后给每一个 <code>participant leader</code> 发送一条提交消息，这个提交消息中包含了协调者的标识符以及所有客户端缓冲的写操作。由客户端发起两阶段提交避免了在广域链路下发送两次数据（如果两阶段提交不由客户端发起，可能的一种情况是客户端先将缓冲的写操作发给某个 <code>participant leader</code>，不管是这个 <code>participant leader</code> 自己成为 <code>coordinator leader</code> 还是让其他的 <code>participant leader</code> 成为 <code>coordinator leader</code>，都需要将客户端缓冲的写操作发送给其他的节点，这就造成发了两次数据）。</p><p>非协调者的 <code>participant leader</code> 会先获取写锁。然后它会选取一个比之前所有的事务的时间戳都大的时间戳作为准备阶段的时间戳（为了确保单调不变式（<code>monotonicity invariant</code>）），然后通过 <code>Paxos</code> 记录一条准备阶段的日志。然后每个 <code>participant leader</code> 会通知协调者自己所分配的时间戳。</p><p>协调者同样会先获取写锁，但是会跳过准备阶段。在收到所有 <code>participant leader</code> 的时间戳后，它会基于这些时间戳选择一个时间戳作为整个事务的时间戳。所选择的事务提交的时间戳 <code>s</code> 必须大于等于任意一个 <code>participant leader</code> 的准备阶段的时间戳（为了满足4.1.3节的限制约束），同时也要大于协调者收到提交消息时的时间戳 <code>TT.now().latest</code>，以及大于 <code>coordinator leader</code> 所有分配给之前的事务的时间戳（同样是为了确保单调不变式（<code>monotonicity invariant</code>））。然后 <code>coordinator leader</code> 也会通过 <code>Paxos</code> 记录一条提交的日志（或者在等待其他参与者时超时从而放弃当次事务）。</p><p>在允许参与事务的副本执行提交命令前，<code>coordinator leader</code> 会先进行等待直到 <code>TT.after(s)</code> 返回真，这就满足了4.1.2节描述的提交等待（<code>commit-wait</code>）规则。因为 <code>coordinator leader</code> 会基于 <code>TT.now().latest</code> 选择时间戳 <code>s</code>（<code>TT.now().latest</code> 只是其中的一个参考基准，但是实际的时间戳也必然会大于 <code>TT.now().latest</code>），然后现在需要等待直到当前的时间戳大于 <code>s</code>，则等待的时间至少是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">2 * \bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>（时间的瞬时误差上限记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，其值为 <code>TTinterval</code> 区间长度的一半，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>表示平均误差上限。因为最差的情况下当前的绝对时间可能正好是 <code>TTinterval</code> 区间的起始位置，从而需要等待整个区间长度）。不过这个等待时间基本上是和 <code>Paxos</code> 的通信重合的。在提交等待（<code>commit-wait</code>）结束后，协调者将事务的时间戳发送给客户端以及其他的 <code>participant leader</code>。每个 <code>participant leader</code> 通过 <code>Paxos</code> 记录事务的结果。每个参与者也同样在相同的时间戳下应用日志然后释放锁。</p><h4 id="只读事务"><a class="markdownIt-Anchor" href="#只读事务"></a> 只读事务</h4><p>给只读事务分配时间戳需要所有涉及的 <code>Paxos</code> 组进行协商。因此，<code>Spanner</code> 要求每个只读事务需要声明一个 <code>scope</code> 表达式，这个表达式汇总了整个只读事务会读取的键。<code>Spanner</code> 会自动的为独立的查询推导出 <code>scope</code>。</p><p>如果某个 <code>scope</code> 的值只涉及单个 <code>Paxos</code> 组，则客户端会向该 <code>Paxos</code> 组的主节点发起只读事务（当前 <code>Spanner</code> 的实现中只会由主节点为只读事务选取时间戳）。主节点选取时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后开始执行读操作。对于单点（<code>single-site</code>）读操作，<code>Spanner</code> 通常能选取一个比 <code>TT.now().latest</code> 更好的时间戳。定义 <code>LastTS()</code> 表示该 <code>Paxos</code> 组中最后一次提交的写操作的时间戳。如果当前没有任何已完成准备阶段的事务，那么选取 <code>LastTS()</code> 作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值就已经能满足外部一致性：当前的只读事务能读取到上一次写操作的结果，因此该只读事务也发生在这之后。</p><p>如果 <code>scope</code> 的值涉及了多个 <code>Paxos</code> 组，这就有几种选择。其中最复杂的选择就是和每一个 <code>Paxos</code> 组的主节点通信，然后基于每个 <code>Paxos</code> 组的 <code>LastTS()</code> 来选取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<code>Spanner</code> 目前选取了更简单的实现。客户端省略了和所有涉及的 <code>Paxos</code> 组的协商阶段，直接选取 <code>TT.now().latest</code> 作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值（当然前面说过这会造成阻塞，需要等待副本的安全时间满足大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。因此该事务中所有的读操作都可以发送给有着足够新的数据的副本处理。</p><h4 id="模式变更事务"><a class="markdownIt-Anchor" href="#模式变更事务"></a> 模式变更事务</h4><p><code>TrueTime</code> 使得 <code>Spanner</code> 能够支持原子的模式变更。使用标准的事务来处理模式变更是不切实际的，因为涉及的参与者数量（数据库中 <code>Paxos</code> 组的数量）可能有百万级别。<code>Bigtable</code> 支持单个数据中心内的原子模式变更，不过执行模式变更时会阻塞所有的其他操作。</p><p><code>Spanner</code> 的模式变更事务基本上是标准事务的一个非阻塞式的变种。首先，它会被分配一个未来的时间戳，这个时间戳是在准备阶段生成的。因此，涉及几千台服务器的模式变更能够在尽可能少的影响到并发进行的事务的前提下完成。第二，依赖需要变更的模式的读写操作会和分配了时间戳 <code>t</code> 的模式变更事务保持同步：如果读写操作的时间戳小于 <code>t</code>，则这些操作可以继续进行；但是如果读写操作的时间戳大于 <code>t</code>，则需要阻塞等待模式变更事务完成。如果没有 <code>TrueTiime</code>，则定义模式修改发生在时间戳 <code>t</code> 就没有意义。</p><h4 id="改进"><a class="markdownIt-Anchor" href="#改进"></a> 改进</h4><p>上述定义的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>T</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">T_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>存在一个缺陷，某个已完成准备阶段的事务会阻止<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>更新（因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{safe} = min(t_{safe}^{Paxos}, t_{safe}^{TM})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在4.1.3节有描述，当存在完成准备阶段的事务时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_{safe}^{TM} = min_i(s_{i, g}^{prepare}) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，需要依赖各参与者所分配的准备阶段的时间戳）。因此，需要读取后面的时间戳的读操作都无法完成，即使该读操作和当前的事务没有冲突。一种解决方案是建立某个范围内的键到已完成准备阶段的事务的时间戳的映射。这部分的信息可以保存在锁表中，因为锁表本身已经保存了某个范围内的键到锁的元数据的映射。当 <code>Spanner</code> 收到一个读操作时，会先判断要读取的键是否存在已完成准备阶段但还未完成提交的事务，如果不存在这样的事务，则如4.1.3节所述<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值就只取决于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><code>LastTS()</code> 也有类似的问题：如果某个事务刚刚提交，一个无冲突的只读事务所分配的时间戳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>依然要在刚提交的事务的时间戳之后。因此，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的存在，该只读事务也有可能延迟。这个问题的解决方案也类似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>T</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">T_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>，同样是建立某个范围内的键到 <code>LastTS()</code> 的映射（不过目前 <code>Spanner</code> 还未实现这个优化）。当 <code>Spanner</code> 收到某个只读事务时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值取决于读操作涉及的键所对应的 <code>LastTS()</code> 的最大值，除非同时还存在已完成准备阶段但还未完成提交的事务（则又回到上面一种情况）。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的问题在于如果没有写操作，则这个值始终得不到更新。因此，如果某个期望读取时间戳 <code>t</code> 的快照读落在了某个最近一次写操作的时间戳小于 <code>t</code> 的 <code>Paxos</code> 组中，那么在没有新的写操作的情况下，这个快照读始终无法被执行。<code>Spanner</code> 通过主节点租约区间的不相交不变式（<code>disjointness invariant</code>）来解决这个问题。每个主节点维护了一个 <code>Paxos</code> 序号 <code>n</code> 到可能分配给下一个序号 <code>n + 1</code> 的最小时间戳的映射，即 <code>MinNextTS(n)</code>。当某个副本应用了序号 <code>n</code> 的指令后，则可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的值更新为 <code>MinNextTS(n) - 1</code>，因为下一个被分配的最小时间戳为 <code>MinNextTS(n)</code>，减1就保证了不会超过这个值。</p><p>对于单个主节点来说可以很轻易的保证 <code>MinNextTS()</code> 的值的正确性（这里有一种可能的粗暴的方案，例如主节点设定10毫秒后才能提交下一个事务，如果10毫秒内来了一个事务，则直接等待到10毫秒后）。因为 <code>MinNextTS()</code> 的值必然落在当前主节点的租期内，又由于各个主节点租期之间的不相交不变式（<code>disjointness invariant</code>）的存在，使得 <code>Spanner</code> 能够在跨主节点时依然保证 <code>MinNextTS()</code> 的值的正确性（如果 <code>MinNextTS()</code> 的值超过了当前主节点的任期，则 <code>MinNextTS()</code> 的值的正确性就交由下一个主节点保证，从而转为了单主节点问题）。如果某个主节点在当前租期快过期时想要增加 <code>MinNextTS()</code> 的值，那么这个主节点就必须先延长租期。注意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（某个主节点使用的最大时间戳）始终会更新为 <code>MinNextTS()</code> 的最大值来确保不相交不变式（<code>disjointness invariant</code>）。</p><p>主节点默认每8秒增加一次 <code>MinNextTS()</code> 的值（因为如果一直没有写操作，则需要不断更新 <code>MinNextTS()</code> 来确保后续的读请求不会阻塞）。因此，在不存在已完成准备阶段的事务的情况下，某个空闲的 <code>Paxos</code> 组中健康的副本在最差情况下需要等待8秒才能返回数据给客户端。主节点可能也会根据从节点的要求来更新 <code>MinNextTS()</code> 的值。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">Spanner: Google’s Globally-Distributed Database</a></li><li><a href="https://cloud.google.com/spanner/docs/replication#benefits_of_cloud_spanner_replication">Benefits of Cloud Spanner replication</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Spanner&lt;/code&gt; 是一个由 &lt;code&gt;Google&lt;/code&gt; 设计，构建和部署的可扩展的全球分布式数据库。从高层次</summary>
      
    
    
    
    
    <category term="MIT 6.824" scheme="https://frederick-s.github.io/tags/MIT-6-824/"/>
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
    <category term="Distributed Systems" scheme="https://frederick-s.github.io/tags/Distributed-Systems/"/>
    
    <category term="Spanner" scheme="https://frederick-s.github.io/tags/Spanner/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 - Frangipani: A Scalable Distributed File System</title>
    <link href="https://frederick-s.github.io/2022/06/11/mit-6.824-frangipani/"/>
    <id>https://frederick-s.github.io/2022/06/11/mit-6.824-frangipani/</id>
    <published>2022-06-10T16:00:00.000Z</published>
    <updated>2022-06-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>这是一篇上世纪九十年代的论文，在当时的环境下，安装新工作站的需求与日俱增，而针对大量工作站的文件系统管理却费时费力。为了保存更多的文件和服务更多的用户，就需要更多的磁盘，并挂载到更多的机器上。某一组文件经常会被手动分配给某些特定的磁盘，当磁盘空间不足，异常或者成为性能热点时，就需要手动移动或者复制文件到其他磁盘上。使用 <code>RAID</code> 技术管理多个磁盘只能解决部分问题；当系统增长到需要多个磁盘阵列和多台服务器时，系统管理问题也随之而来。</p><p><code>Frangipani</code> 是一个可扩展的分布式文件系统，它能统一管理挂载在不同机器上的磁盘，对外来说，这些磁盘构成了一个独立的共享存储池。组成 <code>Frangipani</code> 的机器默认能够被统一管理而且相互间能安全的通信。在 <code>Frangipani</code> 之前已经有了一些分布式文件系统的实现，并且在吞吐和容量上有很好的扩展性。<code>Frangipani</code> 的一个显著特性是它的内部结构非常简单——各台协作的机器共同访问一个通用的存储，并使用锁来保证访问的同步性。这种简单的结构使得只需要少量的机器就能处理系统恢复，重配置和负载均衡。<code>Frangipani</code> 的另一个关键特性是相比于已知的分布式文件系统，它结合了一系列功能使得 <code>Frangipani</code> 更易于使用和管理：</p><ol><li>所有用户读取到的文件内容都相同。</li><li>可以轻易的向 <code>Frangipani</code> 添加更多的服务器来增加存储容量和吞吐，而无需修改已有服务器的配置，或者中断其操作。这些服务器可以像积木一样根据需要搭建来构建更大的文件系统。</li><li>系统管理员添加新用户时无需关心新用户的数据会由哪台服务器管理或者保存在哪个磁盘上。</li><li>系统管理员可以对整个文件系统进行完整和一致的备份，而无需停止服务。备份可以在线进行，使得用户可以快速访问被意外删除的文件。</li><li>文件系统可以在无需人工干预的情况下容忍机器、网络、磁盘异常并自行恢复。</li></ol><p><code>Frangipani</code> 构建于 <code>Petal</code> 之上，<code>Petal</code> 是一个易于管理的分布式存储系统，为客户端提供了虚拟磁盘。和物理磁盘一样，<code>Petal</code> 的虚拟磁盘也是以块（<code>block</code>）的方式来读取和写入。和物理磁盘不同的是，一个 <code>Petal</code> 虚拟磁盘提供了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>字节的稀疏地址空间，并且只在需要的时候才会分配物理存储。<code>Petal</code> 也支持数据备份来保证高可用。<code>Petal</code> 同时提供了高效的快照功能来支持一致性备份。<code>Frangipani</code> 从下层存储系统继承了扩展性，容错和易于管理的特性，不过将这些特性扩展到文件系统还需要些细致的设计。下一节将会详细描述 <code>Frangipani</code> 的结构以及和 <code>Petal</code> 的关系。</p><p><img src="/images/frangipani-1.png" alt="alt" /></p><p>上图展示了 <code>Frangipani</code> 的层级设计。多个可替换的 <code>Frangipani</code> 服务器运行于一个共享的 <code>Petal</code> 虚拟磁盘之上，不同的用户程序可以各自通过连接的 <code>Frangipani</code> 服务器来访问相同的文件，而各 <code>Frangipani</code> 服务器间通过分布式锁服务来保证数据的一致性。通过添加 <code>Frangipani</code> 服务器可以实现对文件系统层的扩展。<code>Frangipani</code> 通过异常服务器的自动恢复和借助依然存活的服务器来提供服务实现了容错。相比于中心化的网络文件服务器，<code>Frangipani</code> 通过将负载分摊到各个正在使用文件的机器上来提供更好的负载均衡。出于扩展性，容错和负载均衡的考虑，<code>Petal</code> 和 <code>Frangipani</code> 用到的锁服务也是分布式的。</p><p><code>Frangipani</code> 服务器默认信任 <code>Petal</code> 服务器和锁服务。<code>Frangipani</code> 的最佳使用场景是在同一个管理域下的工作站集群，虽然它也可以扩展到其他管理域下。因此，<code>Frangipani</code> 可以被看做是一个集群文件系统。</p><p>论文的作者在 <code>DIGITAL Unix 4.0</code> 之上实现了 <code>Frangipani</code>。得益于 <code>Frangipani</code> 在 <code>Petal</code> 之上构建的简洁的层级设计，使得在几个月内实现了一个可用的系统。</p><p><code>Frangipani</code> 的目标运行环境的场景是程序开发和工程。测试表明在这样的负载下，<code>Frangipani</code> 有着优秀的性能并且能很好的扩展，而最终的性能上限则受限于网络能力。</p><h2 id="系统结构"><a class="markdownIt-Anchor" href="#系统结构"></a> 系统结构</h2><p><img src="/images/frangipani-2.png" alt="alt" /></p><p>上图展示了 <code>Frangipani</code> 系统下各机器的一种典型职责分配。最上方的机器运行着用户程序和 <code>Frangipani</code> 的文件服务模块，这些机器无需挂载磁盘。最下方的机器运行着 <code>Petal</code> 和分布式锁服务。</p><p>不过在实际场景中，组成 <code>Frangipani</code> 的机器无需严格按照上图中的描述承担职责。<code>Petal</code> 和 <code>Frangipani</code> 文件服务不一定要运行在不同的机器上；每台运行着 <code>Petal</code> 的机器也可以同时运行着 <code>Frangipani</code> 文件服务，特别是当 <code>Petal</code> 的机器负载不高时。分布式锁服务独立于系统中的其他服务，上图中描述了每个 <code>Petal</code> 机器上运行着一个锁服务，不过它们也可以运行在 <code>Frangipani</code> 或者其他可用的机器上。</p><h3 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h3><p>如前面的图中所示，用户程序通过标准的系统调用接口来访问 <code>Frangipani</code>。运行在不同机器上的应用程序能访问到相同的文件，而且看到的文件内容也是相同的；也就是说，如果在某台机器上修改了某个文件或者文件夹，那么运行在其他机器上的程序也能马上看到这个修改。对于使用 <code>Frangipani</code> 的程序来说，<code>Frangipani</code> 提供的文件操作语义保证和本地 <code>Unix</code> 文件系统提供的文件操作语义保证相同：程序对文件的修改会先暂存在内核的缓冲区中，在下一次的 <code>fsync</code> 或者 <code>sync</code> 系统调用之前，系统不保证对文件的修改会保存到非易失存储上，不过系统会记录对文件元数据的修改并且可选的保证当系统调用返回时，文件的元数据修改已经保存到了非易失存储上。和本地文件系统的文件操作语义有点小小的不同，<code>Frangipani</code> 中文件的最后访问时间是一个近似值，从而避免了每次读取文件时都需要写元数据。</p><p>每台机器上的 <code>Frangipani</code> 文件服务模块运行在操作系统内核中。通过内核的 <code>file system switch</code> <code>Frangipani</code> 将自己注册为一个可用的文件系统实现。<code>Frangipani</code> 的文件服务模块使用了内核的缓冲区来缓存最近使用的文件数据。它通过本地的 <code>Petal</code> 设备驱动来实现对 <code>Petal</code> 虚拟磁盘的读写。每个文件服务器使用相同的数据结构来读取和写入文件到共享的 <code>Petal</code> 磁盘上，不过各服务器会在 <code>Petal</code> 磁盘的不同区域上针对进行中的修改维护各自的重做日志。因为 <code>Frangipani</code> 的重做日志保存在 <code>Petal</code> 中，所以当某个 <code>Frangipani</code> 服务器异常时，其他的服务器可以通过 <code>Petal</code> 访问日志并进行数据恢复。各 <code>Frangipani</code> 服务器之间无需通信；它们只会和 <code>Petal</code> 和分布式锁通信。这就简化了服务器的添加，删除和恢复。</p><p><code>Petal</code> 的设备驱动程序掩盖了 <code>Petal</code> 分布式的特性，对操作系统的上层应用来说，<code>Petal</code> 就等同于是一块本地磁盘。驱动程序负责和正确的 <code>Petal</code> 服务器通信，以及如果当前的服务器发生异常，能切换到另一台可用的服务器。类似 <code>Digital Unix</code>  的文件系统都可以运行在 <code>Petal</code> 之上，不过只有 <code>Frangipani</code> 提供了多客户端下访问同一文件的数据一致性特性。</p><p><code>Petal</code> 的各服务器基于本地挂载的物理磁盘并通过协作来向 <code>Frangipani</code> 提供大型，可扩展，容错的虚拟磁盘。<code>Petal</code> 可以容忍一个或多个磁盘或者服务器异常，只要大多数的 <code>Petal</code> 服务器依然存活并且相互之间可以通信，以及每个数据块都至少有一个副本保存在物理存储上并且能够被访问。</p><p><code>Frangipani</code> 用到的锁服务能够为网络中的客户端提供通用的读写锁服务。出于容错和扩展性考虑，它的实现是分布式的。<code>Frangipani</code> 使用锁服务来协调对虚拟磁盘的访问，以及保证各服务器内文件缓存的一致性。</p><h3 id="安全和客户端服务器配置"><a class="markdownIt-Anchor" href="#安全和客户端服务器配置"></a> 安全和客户端/服务器配置</h3><p>如 <code>Fugure 2</code> 所示，每台运行着用户程序的机器同时运行着 <code>Frangipani</code> 的文件服务模块。虽然这种配置有利于负载均衡和扩展，不过存在安全隐患。每个 <code>Frangipani</code> 机器都可以对共享的 <code>Petal</code> 虚拟磁盘上的数据块进行任意读写，所以 <code>Frangipani</code> 必须运行在受信任的操作系统上；类似于 <code>NFS</code> 的远程文件访问协议中的身份认证还不足以保证安全性。完整的安全性也要求 <code>Petal</code> 和锁服务运行在受信任的操作系统上，并且 <code>Frangipani</code>、<code>Petal</code>、锁服务这三个组件都需要能够互相认证。最后，为了保证文件数据的私有性，也需要保证没有人能够窃听 <code>Petal</code> 和 <code>Frangipani</code> 机器间的网络通信。</p><p>一种解决方案是运行用户程序的机器被设置为不允许运行自定义修改的操作系统，同时这些机器间通过一个私有网络连接并且用户程序没有权限访问。不过这并不是说需要将所有的机器放在同一个机房中并通过私有的物理网络相连；可以借助某些加密技术来实现系统的安全启动，以及某些认证技术和加密链路来保证通信安全性。另外，对于某些应用程序来说，一个不完整的解决方案也是可以接受的；典型的如 <code>NFS</code> 就不能防止网络窃听以及杜绝用户在自己的工作站上运行修改后的操作系统。论文的作者并没有实现所有的安全措施，不过 <code>Frangipani</code> 基本也可以达到 <code>NFS</code> 的安全级别，<code>Petal</code> 服务器只会接受来自已知网络地址的 <code>Frangipani</code> 服务器的请求。</p><p><img src="/images/frangipani-3.png" alt="alt" /></p><p>如上图所示，<code>Frangipani</code> 文件系统可以扩展到外部非受信的管理域中。图中区分开了 <code>Frangipani</code> 客户端和服务端。只有受信的 <code>Frangipani</code> 服务端可以和 <code>Petal</code> 以及锁服务通信。这三个组件可以放置在一个受限制的环境中并且通过私有的网络连接。而外部的非受信远程客户端只能和 <code>Frangipani</code> 服务端通信，而不能直接访问 <code>Petal</code> 服务器。</p><p>客户端可以和 <code>Frangipani</code> 服务端以任何操作系统支持的文件访问协议通信，例如 <code>DCE/DFS</code>，<code>NFS</code>，<code>SMB</code>，因为对于运行着 <code>Frangipani</code> 服务端的机器来说，<code>Frangipani</code> 就类似于是个本地文件系统。当然，如果访问协议本身支持一致性访问是最好的（例如 <code>DCE/DFS</code>），从而使得 <code>Frangipani</code> 的多服务器间的一致性不会在上一层丢失。理想情况下，客户端的访问协议需要支持故障转移。上述提到的协议并不直接支持故障转移，不过在其他系统中如果某台服务器发生异常，会有另一台服务器接管并复用异常服务器的 <code>IP</code> 地址，因此可以在这里应用同样的手段。</p><p>除了安全之外，还有第二个原因要使用上述的客户端/服务端配置。因为 <code>Frangipani</code> 运行在操作系统内核，不能快速的适配不同的操作系统甚至是不同版本的 <code>Unix</code>。所以通过远程客户端的方式就能使得运行不支持的操作系统的客户端也能够使用 <code>Frangipani</code>。</p><h3 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h3><p>构建文件系统的分层思想——低层提供存储服务，高层提供命名，文件夹和文件服务，并不是 <code>Frangipani</code> 独有的。最早应用这个思想的是 <code>Universal File Server</code>。不过，<code>Petal</code> 提供的存储功能和早先的系统大有不同，从而引申出不同的上层结构设计。</p><p><code>Frangipani</code> 的设计是基于 <code>Petal</code> 提供的抽象存储服务，作者还未充分考虑为了适配其他的存储服务（例如 <code>NASD</code>）需要对 <code>Frangipani</code> 做出哪些修改。</p><p><code>Petal</code> 提供了高可用的存储服务并且能够通过添加资源来实现对吞吐和容量的扩展。不过，<code>Petal</code> 不提供协同功能或者在多个客户端间共享存储。另外，大部分的应用程序不能直接使用 <code>Petal</code> 的接口因为 <code>Petal</code> 面向的是磁盘而不是文件。<code>Frangipani</code> 在 <code>Petal</code> 之上构建了文件系统层使得在保留和扩展了 <code>Petal</code> 有用的特性的同时对应用程序更加易用。</p><p><code>Frangipani</code> 的一个优势是能够透明的添加服务器，删除服务器以及实现故障恢复。通过将预写日志、锁和提供一致性访问、高可用的存储结合使用，<code>Frangipani</code> 能轻易的实现这个特性。</p><p><code>Frangipani</code> 的另一个特性是能在文件系统运行时生成一致性的备份。这个机制会在后面介绍。</p><p>不过 <code>Frangipani</code> 的设计可能在三个方面上存在问题。基于启用了副本的 <code>Petal</code> 虚拟磁盘构建的 <code>Frangipani</code> 有时候会记录重复的日志，一次是 <code>Frangipani</code> 自己写入的日志，这里是 <code>Frangipani</code> 为客户端提供服务；另一次是 <code>Petal</code>记录的日志，这里以 <code>Petal</code> 的视角来说 <code>Frangipani</code> 成为了客户端。第二，<code>Frangipani</code> 无法根据磁盘的位置来选择在哪里保存数据，因为 <code>Petal</code> 提供的是虚拟的磁盘，之所以有这个需求可能是因为类似于 <code>GFS</code> 选择在哪里放置副本一样，如果 <code>Frangipani</code> 能知道具体磁盘的位置，它就能选择一个距离客户端近的磁盘保存文件。最后，<code>Frangipani</code> 会对整个文件或者文件夹加锁而不是对某个数据块加锁。不过作者还没有足够的使用经历来评估这三个问题的影响，不过撇开它们不谈，在作者所处环境下测试出的 <code>Frangipani</code> 的性能还是不错的。</p><h2 id="磁盘布局"><a class="markdownIt-Anchor" href="#磁盘布局"></a> 磁盘布局</h2><p><code>Frangipani</code> 使用 <code>Petal</code> 提供的巨大、稀疏的磁盘地址空间来简化其数据结构。这个想法是受之前有着巨大内存空间的计算机上的相关工作所启发。因为有着如此巨大的地址空间所以可以将其任意切分。</p><p>一个 <code>Petal</code> 虚拟磁盘有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>字节的地址空间。<code>Petal</code> 只会在物理磁盘空间写入后才会将其提交到虚拟地址中。<code>Petal</code> 同时提供了 <code>decommit</code> 原语用来释放某个范围内的虚拟地址所关联的物理磁盘空间。</p><p>为了使内部的数据结构足够小，<code>Petal</code> 会以较大的数据块来提交（<code>commit</code>）和回收（<code>decommit</code>）虚拟地址，目前的数据块大小是 <code>64 KB</code>。也就是说，对于每个 <code>64 KB</code> 的虚拟地址空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>∗</mo><msup><mn>2</mn><mn>16</mn></msup><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><msup><mn>2</mn><mn>16</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[a * 2^{16}, (a + 1) * 2^{16})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，如果有数据写入且没有被回收，那么同时就需要分配 <code>64 KB</code> 的物理磁盘地址空间。因此 <code>Petal</code> 客户端写入的数据不能太稀疏，否则可能由于碎片化造成物理磁盘空间浪费。下图展示了 <code>Frangipani</code> 如何切分 <code>Petal</code> 的虚拟磁盘空间：</p><p><img src="/images/frangipani-4.png" alt="alt" /></p><p>图中的第一个区域用于保存共享的配置参数和其他信息。这个区域的最大大小是 <code>1 T</code>，不过目前实际上只用了几 <code>K</code>。</p><p>第二个区域用于保存日志。每个 <code>Frangipani</code> 服务器会在这块区域中选择一部分来保存自己的私有日志。这里总共预留了 <code>1 T</code> 的空间，并切分为256个分区，所以可以保存256份日志。这就限制了一个 <code>Petal</code> 虚拟磁盘最多支持256个 <code>Frangipani</code> 服务器，不过这可以轻易的通过调整分区个数来扩展。</p><p>第三个区域用于保存分配位图，从而知道余下的虚拟空间中哪些是可用的。每个 <code>Frangipani</code> 服务器会独占式的锁住这块区域中的某一部分。当某台 <code>Frangipani</code> 服务器的分配位图空间不够时，它会再次找到可用的区域然后加锁使用。整个区域的大小是 <code>3 T</code>。</p><p>第四个区域用于保存 <code>inode</code>。每个文件需要一个 <code>inode</code> 来保存元数据，例如访问的时间戳和指向文件数据位置的指针。对于符号链接来说它们的数据直接保存在了 <code>inode</code> 中。每个 <code>inode</code> 的大小为512字节，和磁盘块的大小相同，从而避免了两个服务器同时访问同一个磁盘块上保存的不同 <code>inode</code> 所带来的竞争（也就是 <code>false sharing</code>，<a href="https://pdos.csail.mit.edu/6.824/papers/frangipani-faq.txt">FAQ for Frangipani, Thekkath, Mann, Lee, SOSP 1997</a> 中对这个问题有所解释，磁盘数据的读取以块为单位，如果 <code>inode</code> 小于512字节，某个 <code>Frangipani</code> 服务器先读取了磁盘数据块并缓存，此时另一个服务器需要读取和修改同一个磁盘数据块上的 <code>inode</code>，那么为了保证缓存一致性，第一个服务器再次读取 <code>inode</code> 时就需要重新读取磁盘数据块并刷新缓存，造成两个服务器交替的读取修改同一个数据块的内容，缓存也就失去了意义，而本质上两个服务器之间并不应该有竞争。）。整个区域的大小是 <code>1 TB</code>，所以可以保存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个 <code>inode</code>。在位图分配区域中的比特位和 <code>inode</code> 的映射是固定的，也就是说根据位图分配区域中的比特位地址就能推算出对应 <code>inode</code> 的地址，所以每个 <code>Frangipani</code> 为新文件所创建的 <code>inode</code> 地址在第四个区域中的偏移比例和该 <code>inode</code> 对应位图分配区域中的比特位的偏移比例是一致的。不过任何一个 <code>Frangipani</code> 都可能读写或释放某个已经存在的文件的 <code>inode</code>。</p><p>第五个区域用于保存小数据块，每个数据块大小为 <code>4 KB</code>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>字节）。一个文件的前 <code>64 KB</code>（16个数据块） 的内容会保存在小数据块中。如果某个文件的大小超过 <code>64 KB</code>，则超过的部分会保存在一个大数据块中。<code>Frangipani</code> 在一个 <code>Fetal</code> 虚拟磁盘上最多可以分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>47</mn></msup></mrow><annotation encoding="application/x-tex">2^{47}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>字节（<code>128 T</code>）的小数据块，共计<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>35</mn></msup></mrow><annotation encoding="application/x-tex">2^{35}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>块，是 <code>inode</code> 最大数量的16倍。</p><p><code>Petal</code> 虚拟磁盘剩下的地址空间用于保存大数据块。每个大数据块有 <code>1 TB</code> 空间。</p><p>选择 <code>4 KB</code> 作为数据块大小会比更小的数据块的策略更容易产生磁盘碎片。同时，一个 <code>inode</code> 512字节在某种程度上也是空间浪费。可以将小文件直接保存在 <code>inode</code> 中来缓解这个问题。虽然存在碎片和空间浪费的问题，不过出于设计简洁性的考虑，作者认为这是一种合理的折中选择。</p><p>在当前的设计下，<code>Frangipani</code> 能保存的大文件个数小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>（1600万，大文件需要保存在大数据块中，一个大数据块 <code>1 T</code>，而虚拟空间最大地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mi>T</mi></mrow><annotation encoding="application/x-tex">2^{24} T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，又因为不是整个空间都用来保存大文件，所以实际个数小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>），大文件是指大于 <code>64 KB</code> 的文件。另外，<code>Frangipani</code> 能保存文件的最大大小是16个小数据块加上一个大数据块（<code>64 KB</code> 加 <code>1 TB</code>）。如果需要保存更多的文件，可以通过减小大数据块的大小来解决；以及允许一个大文件可以保存在多个大数据块中，这样就可以提高最大能保存文件的大小。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>字节的地址空间不够，则一个 <code>Frangipani</code> 服务器可以支持扩展为多个 <code>Petal</code> 虚拟磁盘组成的 <code>Frangipani</code> 文件系统。</p><p>作者基于之前文件系统的使用经验设定了上述的系统参数。作者认为这种配置已经足够满足需求，不过还是需要时间和实际使用来检验。<code>Frangipani</code> 的设计足够灵活所以可以通过备份和恢复来验证合适的磁盘布局。</p><h2 id="日志和恢复"><a class="markdownIt-Anchor" href="#日志和恢复"></a> 日志和恢复</h2><p><code>Frangipani</code> 通过元数据的预写重做日志来简化异常恢复和提高性能；不过用户的数据并不会记录到日志中。每个 <code>Frangipani</code> 服务器会将自己的日志保存在 <code>Petal</code> 中。当某个 <code>Frangipani</code> 服务器需要修改某个元数据时，它会首先生成一条日志来描述具体的修改内容并将其添加到内存日志中。这些内存中的日志会周期性的按照修改请求发起的顺序写入到 <code>Petal</code> 中（<code>Frangipani</code> 同时也支持将日志同步的写入到 <code>Petal</code> 中，这会稍微提高容错性不过会增加元数据更新操作的延迟。）。只有当某条日志写入 <code>Petal</code> 之后，系统才会真正修改对应文件的元数据。实际文件的元数据更新会交由一个 <code>Unix</code> 的 <code>update</code> 守护进程来周期性（大概每隔30秒）的更新。</p><p>在当前的实现中，<code>Frangipani</code> 写到 <code>Petal</code> 的日志的最大大小为 <code>128 KB</code>。根据 <code>Petal</code> 的空间分配策略，一份日志会拆分到两个不同的物理磁盘上，每个磁盘上的大小为 <code>64 KB</code>。<code>Frangipani</code> 会以环形缓冲（<code>circular buffer</code>）的方式来管理所分配的日志空间。当日志空间满时，<code>Frangipani</code> 会回收25%的最老的日志空间来存放新的日志。一般来说，被回收的日志所对应的元数据修改都应该已经写入到了 <code>Petal</code> 中（通过之前的 <code>sync</code> 操作），因此回收日志时不需要额外的写操作。如果回收日志时发现存在某些待回收的日志所对应的元数据修改还没有写入到 <code>Petal</code>，则需要先执行元数据的写入操作再回收日志。根据日志缓冲区和单条 <code>Frangipani</code> 日志的大小（80-128字节），如果在两个 <code>sync</code> 周期内存在1000-1600个元数据修改操作就能写满整个日志缓冲区。</p><p>如果某个 <code>Frangipani</code> 服务器发生异常，系统最终能检测到异常并根据该 <code>Frangipani</code> 服务器的日志进行恢复。<code>Frangipani</code> 服务器异常可以被所访问的客户端发现，或者当锁服务向持有锁的 <code>Frangipani</code> 服务器要求返回锁而没有响应时发现。当异常发生时，负责恢复的守护进程会临时拥有异常的 <code>Frangipani</code> 服务器的日志和锁的所有权。异常恢复进程会先找到异常服务器日志的起始位置和结束位置，然后逐条检查每一条日志，判断哪些日志所对应的元数据更新还没有被执行。当日志处理完成后，异常恢复进程就会释放所持有的锁并清空日志。其他的 <code>Frangipani</code> 服务器就可以在不受异常服务器影响的情况下继续工作，而异常的服务器可以在稍后被重启（对应的日志为空）。只要底层的 <code>Petal</code> 磁盘依然可用，系统就能容忍任意数量的 <code>Frangipani</code> 服务器异常。</p><p>为了确保异常恢复进程能找到异常服务器的日志的结束位置（即使磁盘控制器没有按照顺序写数据），系统为每512字节的日志数据块分配了一个递增的序号。只要发现某个数据块的序号小于前一个数据块的序号，那就说明前一个数据块就是日志的结束位置。</p><p><code>Frangipani</code> 确保了日志和异常恢复能正确的处理多条日志。不过这在细节上有几点要注意。</p><p>首先，在下一节会介绍到 <code>Frangipani</code> 的锁协议保证了多个服务器对同一个数据的更新请求会被串行执行。某个持有写锁且修改了数据的服务器需要先将修改的数据写回到 <code>Petal</code> 后才能释放锁，所以要么是该服务器在正常情况下数据更新完成后主动释放锁，要么是服务器异常后由异常恢复进程在数据更新完成后释放锁。这说明对于任意的数据块来说，整个系统中最多只可能有一条数据修改的日志还未完成。</p><p>第二，<code>Frangipani</code> 确保了异常恢复进程只会处理异常服务器在持有锁之后但还未释放锁期间记录的日志。这是为了确保锁协议保证的更新串行化不会被破坏。<code>Frangipani</code> 使用了更强的条件限制来实现这一保证：异常恢复进程永远不会重新执行一个已经执行完成的数据更新。为了保证这一点，<code>Frangipani</code> 给每512字节的元数据块分配了一个版本号。而类似于文件夹的元数据有可能会跨多个数据块，所以也会有多个版本号。对于每个日志要修改的数据块，日志会记录修改的内容及新的版本号。在异常恢复时，恢复进程会比较当前元数据块最新的版本号和日志中记录的版本号，只有当日志中的版本号大于当前最新的版本号时，恢复进程才会执行重做日志。</p><p>由于 <code>Frangipani</code> 记录更新日志时不会记录用户数据，而只有元数据块给版本号预留了空间。这就带来了一个潜在问题。如果某个数据块一开始被用于保存元数据，后来空间被释放，然后又被用来保存用户数据，那么恢复进程就不能正确的跳过依然引用了这个元数据块（现在的用户数据块）的日志，因为原来保存元数据块中的版本号信息已经被用户数据所覆盖，所以恢复进程就无法比较日志中的版本号的大小。<code>Frangipani</code> 通过要求被释放的元数据块只能用于保存新的元数据来避免这个问题。</p><p>最后，<code>Frangipani</code> 保证在任一时刻只会有一个异常恢复进程在恢复重做某个异常服务器的日志。<code>Frangipani</code> 通过对日志文件的互斥锁来实现这一保证。</p><p><code>Frangipani</code> 的日志和异常恢复机制假定当出现磁盘写异常时，单个扇区中的内容要么都是旧的，要么都是新的，而不会是两者的混合。如果某个磁盘扇区已损坏并且在读操作时返回 <code>CRC</code> 异常，那么 <code>Petal</code> 内置的副本机制通常能恢复对应的数据。如果某个扇区的副本都损坏了，或者 <code>Frangipani</code> 内部的数据结构由于软件 <code>bug</code> 造成损坏，则需要对元数据进行一致性检查以及需要一个恢复工具（例如 <code>Unix</code> 的 <code>fsck</code>）进行数据恢复。不过论文的作者写论文时还未实现这个工具。</p><p><code>Frangipani</code> 的日志并不是为了给用户提供高层次的执行语义保证。它的目的是为了提高元数据更新的性能以及发生服务器异常时通过避免执行 <code>fsck</code> 这样的恢复工具来加快异常恢复速度。因为 <code>Frangipani</code> 的日志只会记录元数据的更新，不会记录用户数据，所以站在用户的视角来说，当系统发生异常时，文件系统的状态和异常发生前并不能保证一致。论文的作者并不是声明这样的语义是理想的，不过这个行为和标准的本地 <code>Unix</code> 文件系统的行为是一样的。在本地 <code>Unix</code> 文件系统和 <code>Frangipani</code> 中，用户都可以在合适的时间点调用 <code>fsync</code> 来确保更好的数据一致性保证。</p><p><code>Frangipani</code> 所使用的日志技术最早被应用于数据库，并在之后应用到其他某些基于日志的系统中。<code>Frangipani</code> 本身不是个日志结构（<code>log-structured</code>）的文件系统；它不会将所有的数据都保存在日志中，而是将数据按约定维护在磁盘中，通过较少的日志 <code>Frangipani</code> 实现了较好的性能和异常恢复的原子性。和其他基于日志的文件系统不同，但是和例如 <code>Zebra</code> 这样的日志结构文件系统相同，<code>Frangipani</code> 也会保存多份日志。</p><h2 id="同步和缓存一致性"><a class="markdownIt-Anchor" href="#同步和缓存一致性"></a> 同步和缓存一致性</h2><p>由于会有多个 <code>Frangipani</code> 服务器修改 <code>Petal</code> 的共享数据，所以需要一个细致化的同步手段来确保各服务器读取到的数据是一致的，以及当系统负载增加或者添加新的服务器时能通过有效的并发手段来提高性能。<code>Frangipani</code> 使用多读一写的读写锁来实现必要的同步。当锁服务侦测到冲突的锁请求时，它会要求锁的持有者释放锁或者进行锁降级（写锁降级为读锁）来消除冲突。</p><p>读锁允许一个 <code>Frangipani</code> 服务器从磁盘中读取相应的数据并缓存。如果该服务器被要求释放锁，则在释放锁前必须先清空缓存。写锁允许一个 <code>Frangipani</code> 服务器读取或者修改数据并将其缓存。只有当某个服务器持有写锁时，它所缓存的数据才有可能和磁盘上保存的数据不同。因此，如果持有写锁的服务器被要求释放写锁或者降级为读锁，则必须先将修改的数据写回到磁盘。如果该服务器降级为了读锁，则依然可以保留缓存，不过如果释放了锁则必须清空缓存。</p><p>相比于释放写锁或者降级为读锁时将缓存中的数据写回到磁盘，还可以选择直接将缓存中的数据发送给请求方。不过出于简洁性考虑 <code>Frangipani</code> 并没有这么做。首先，在 <code>Frangipani</code> 的设计中，<code>Frangipani</code> 服务器之间无需通信。它们只会和 <code>Petal</code> 以及锁服务通信。第二，当某台服务器异常时，<code>Frangipani</code> 的设计保证了系统只需要处理异常服务器的日志即可。如果选择将未写入到磁盘中的数据直接发送给请求方，而接收方发生异常时，指向未持久化的数据的日志可能分散在了多台服务器中。这就给系统恢复和日志空间回收都带来了问题。</p><p><code>Frangipani</code> 将磁盘数据结构拆分为了一个个逻辑段，每个逻辑段都对应一把锁。为了避免 <code>false-sharing</code>，<code>Frangipani</code> 确保了一个磁盘扇区不会保存超过1个可共享的数据结构。将磁盘数据结构拆分为可加锁的段是为了将锁的数量控制的足够小，同时又能避免正常情况下的锁竞争，从而使得锁服务不会成为系统的瓶颈。</p><p>每个 <code>Frangipani</code> 服务器的日志都是一个可加锁的段，因为这些日志都是私有的。磁盘布局中的位图区域也切分为了一个个段，并且相互之间加了互斥锁，所以分配新文件时不会发生竞争，因为每个服务器都在自己持有的段内分配。还未分配给文件的数据块或者 <code>inode</code> 也同时被位图中的同一把锁保护，只是该位置的空间当前被标记为可用状态。最后，每个文件，文件夹，或者符号链接都是一个段；也就是说，<code>inode</code> 和其指向的数据都被同一把锁保护。这种每个文件一把锁的锁粒度对于作者所在的工作负载来说已经足够了，因为文件几乎很少会被并发的修改。而对于其他的工作负载来说则可能需要更细粒度的锁。</p><p>有些操作会要求原子的更新被多把锁保护的磁盘数据结构。<code>Frangipani</code> 通过对锁全局排序以及使用两阶段获取锁来避免死锁。首先，某台服务器先确定需要获取哪些锁。这个过程中会涉及获取或者释放某些锁，例如查找文件夹中的某些文件名。然后，服务器对锁按照 <code>inode</code> 的地址排序然后依次获取锁。同时服务器会检查在第一阶段中读取的对象是否在第二阶段发生了修改，如果发生了修改，那么该服务器会释放所有的锁然后重新执行第一阶段。否则，该服务器就可以开始执行具体的操作，在缓存中修改某些数据并记录一条日志。在缓存中的数据写回到磁盘前，该服务器都会持有相关的锁。</p><p>上述描述的缓存一致性协议类似于 <code>Echo</code>、<code>Andrew File System</code>、<code>DCE/DFS</code> 和 <code>Sprite</code> 中的客户端文件缓存协议。这里使用的避免死锁的技术和 <code>Echo</code> 类似。和 <code>Frangipani</code> 一样，<code>Oracle Parallel Server</code> 同样是将缓存中的数据写回到磁盘，而不是直接将缓存中的数据发送给下一个写锁的持有者。</p><h2 id="锁服务"><a class="markdownIt-Anchor" href="#锁服务"></a> 锁服务</h2><p><code>Frangipani</code> 只需要一小部分，通用的锁功能，并且不希望锁服务在日常操作中成为性能瓶颈，有很多种实现可以满足这些需求。在 <code>Frangipani</code> 项目中，一共尝试了三种不同的锁服务的实现，其他已有的锁服务也可以提供需要的功能，只是在其之上可能需要编写额外的代码来适配。</p><p>锁服务提供了多读一写的读写锁。这里的锁不会用完就马上释放，只要没有其他客户端请求相同的锁，这把锁就会一直被某个客户端持有（这里锁服务的客户端指的是 <code>Frangipani</code> 服务器）。</p><p>锁服务通过租约来处理客户端异常。当某个客户端请求锁服务时，它会先获取一个租约。该客户端获取的所有锁都和这个租约绑定。每个租约有一个过期时间，目前是锁创建或者延期后30秒过期。客户端在租约过期前必须先延期，否则锁服务会认为客户端发生了异常。</p><p>网络异常会妨碍 <code>Frangipani</code> 服务器延长租约，即使 <code>Frangipani</code> 服务器没有发生异常。当某个 <code>Frangipani</code> 服务器无法延长租约时，它会释放所有的锁并清空缓存。如果缓存中的数据被修改了，那么该服务器会打开某个内部标记使得后续的客户端请求都返回一个错误。相应的文件系统必须取消挂载才能删除这个异常。<code>Frangipani</code> 使用这种粗暴的方式来报告异常从而避免了异常被忽略。</p><p>第一版的锁服务实现使用了单节点中心化的服务器，所有的锁状态都保存在了内存中。这种设计对于 <code>Frangipani</code> 来说是足够的，因为 <code>Frangipani</code> 的日志中记录了足够的信息，所以即使锁服务发生异常丢失了所有的状态系统也能够恢复。不过，锁服务异常会导致严重的性能问题。</p><p>第二版的锁服务将锁的状态保存在 <code>Petal</code> 中，每个对锁状态的修改都会先写到 <code>Petal</code> 中，然后才会返回给客户端。如果锁服务的主节点异常，那么会由某个备份节点读取 <code>Petal</code> 中的锁状态然后接管异常的主节点并继续提供服务。在这个设计下，异常恢复更加透明，不过日常操作的性能会低于第一种锁实现。作者还未完全实现所有异常的自动恢复就开始了第三种锁服务的实现。</p><p>第三版的锁服务是分布式的，并且能很好的支持容错和性能。它由一组相互间协作的锁节点组成，同时每个 <code>Frangipani</code> 服务器内嵌了一个 <code>clerk</code> 模块。</p><p>锁服务将锁以表（<code>tables</code>）的形式组织，每个表以 <code>ASCII</code> 字符串的形式命名。每个表中的锁以64位的整型命名。一个 <code>Frangipani</code> 文件系统只使用一个 <code>Petal</code> 虚拟磁盘，虽然多个 <code>Frangipani</code> 文件系统可以挂载到同一个机器上。每个文件系统都绑定了一个关于锁的表。当一个 <code>Frangipani</code> 文件系统挂载时，<code>Frangipani</code> 服务器会请求内嵌的 <code>clerk</code>，然后 <code>clerk</code> 就会打开绑定的锁表。当 <code>clerk</code> 成功打开锁表时，锁服务会返回一个租约标识符，这个租约标识符会在后续通信中使用。当文件系统取消挂载时，<code>clerk</code> 就会关闭锁表。</p><p><code>clerk</code> 和锁节点间使用异步消息而不是 <code>RPC</code> 来通信，这样做能减少内存的使用并同时有着足够好的灵活性和性能。和锁相关的基础消息类型是 <code>request</code>，<code>grant</code>，<code>revoke</code> 和 <code>release</code>。<code>request</code> 和 <code>release</code> 消息是由 <code>clerk</code> 发送给锁节点，而 <code>grant</code> 和 <code>revoke</code> 消息则是由锁节点发送给 <code>clerk</code>。锁的升级和降级同样由这四种消息类型来处理。</p><p>锁服务使用了支持容错，分布式的异常监测机制来检测锁节点的异常。这个机制同时也被用于 <code>Petal</code>。该机制基于各节点间定期的心跳交换，同时使用了共识算法来容忍网络分区。</p><p>一把锁会在服务端和 <code>clerk</code> 侧都需要消耗内存。在当前的实现中，服务端会为每个锁分配112字节，每个 <code>clerk</code> 如果有进行中或者已分配的锁请求则额外还需要104字节。所以每个客户端每个锁最多使用232字节。为了避免长时间持有锁带来的内存消耗，<code>clerk</code> 会丢弃长时间（1小时）未使用的锁。</p><p>一小部分全局且不经常修改的状态信息会由 <code>Lamport</code> 的 <code>Paxos</code> 算法复制到所有的锁服务器上。锁服务复用了为 <code>Petal</code> 实现的 <code>Paxos</code> 算法。全局的状态信息包括锁服务器列表，每个锁服务器负责的锁列表，以及打开还未关闭锁表的 <code>clerk</code> 列表。这些信息用于达成共识，即在各个锁服务器间重新分配锁，当某个锁服务器发生异常时能恢复某个锁的状态，以及协助 <code>Frangipani</code> 服务器的异常恢复。从效率考虑，所有的锁被划分到100个不同的锁组中（<code>lock groups</code>），然后以组的形式分配给锁服务器，而不是以单个锁的形式。</p><p>有时候一把锁会被重新分配给其他的锁服务器，一方面是为了故障转移，另一方面是为了充分利用刚异常恢复的锁服务器，避免流量集中。当某个锁服务器被永久的添加到集群或者从集群中删除时，会发生类似的锁重分配。在这种情况下，所有的锁始终会被重分配，因为需要保证每台锁服务器持有的锁的数量是均衡的，锁重分配的次数要尽可能的少，以及每个锁都只会分配给一台锁服务器。锁的重分配也是由两阶段进行。在第一阶段，各个锁服务器丢弃保存在内部状态中的锁。第二阶段，锁服务器会和 <code>clerk</code> 通信，根据其所打开的锁表来重新分配锁。锁服务器根据 <code>clerk</code> 的锁表来重新生成锁的状态，同时通知 <code>clerk</code> 每把锁在重新分配后对应的锁服务器。</p><p>当某个 <code>Frangipani</code> 服务器异常时，在正确的恢复操作执行前，它所持有的锁不能被释放。特别的，系统需要先处理异常 <code>Frangipani</code> 服务器的日志并将未持久化的元数据更新写入到 <code>Petal</code>。当 <code>Frangipani</code> 服务器的租约到期时，锁服务会通知另一台 <code>Frangipani</code> 服务器上的 <code>clerk</code> 来执行恢复操作，并撤销原来异常服务器持有的全部锁。负责恢复的 <code>clerk</code> 会获取一把异常服务器的日志的互斥锁。这把锁同样分配了一个租约，所以当负责恢复的服务器异常时锁服务会再找一台服务器重新开始恢复任务。</p><p>一般来说，<code>Frangipani</code> 系统能够容忍网络分区，并在可能的情况下继续运行，否则就停止服务。特别的，<code>Petal</code> 可以在网络分区的情况下继续运行，只要大多数的 <code>Petal</code> 服务器依然存活并且相互之间可以通信，不过如果某些 <code>Petal</code> 虚拟磁盘在大多数的 <code>Petal</code> 服务器上没有备份的话，那么这些磁盘无法被继续访问。同样的，只要大多数的锁服务器依然存活并且相互之间可以通信，整个锁服务也依然可用。如果某个 <code>Frangipani</code> 服务器无法和锁服务通信，那么它将再也不能延长租约。此时锁服务会认为这个 <code>Frangipani</code> 服务器发生异常，然后会基于它的日志挑选一个新的 <code>Frangipani</code> 服务器发起恢复流程。如果某个 <code>Frangipani</code> 服务器无法和 <code>Petal</code> 通信，那么它将无法读取和写入虚拟磁盘。不管在哪种情况下，<code>Frangipani</code> 服务器都会拒绝后续受影响的文件系统的用户请求，直到网络分区恢复以及文件系统被重新挂载。</p><p>当 <code>Frangipani</code> 服务器的租约过期时存在一个潜在的问题。如果服务器依然存活而只是由于网络原因造成无法和锁服务通信，那么这台服务器可能依然会在租约过期后访问 <code>Petal</code>。<code>Frangipani</code> 服务器会在写入 <code>Petal</code> 前检查租约是否依然有效（并确保在未来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>秒内依然有效）。不过，<code>Petal</code> 并不会校验某个写入请求是否还在租约有效期内。所以，如果 <code>Frangipani</code> 服务器检查租约和写请求到达 <code>Petal</code> 的时间大于剩余租约的时间，那就会带来一个问题：当 <code>Petal</code> 收到写请求时，租约已经过期，该服务器持有的写锁已经分配给了其他服务器。<code>Frangipani</code> 为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>选择了一个足够大的值（15秒）来确保在正常情况下上述问题不会发生，不过依然不能确保一定不会发生。</p><p>在未来 <code>Frangipani</code> 会尝试解决这个问题，论文给出了一个可能的解决方案。<code>Frangipani</code> 会给每一个 <code>Petal</code> 的写请求附加一个过期的时间戳。这个时间戳的值为生成写请求时的租约过期时间减去<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。这样 <code>Petal</code> 就可以忽略任何时间戳小于当前时间的写请求。只要 <code>Petal</code> 和 <code>Frangipani</code> 服务器的时钟在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>内保持同步，<code>Petal</code> 就能够可靠的拒绝租约过期的写请求。</p><p>另一种解决方案则不依赖时钟同步，但是需要将锁服务和 <code>Petal</code> 集成，并且将 <code>Frangipani</code> 服务器获取的租约标识符附加到写请求中，<code>Petal</code> 收到写请求后就可以根据租约标识符校验租约是否过期，从而拒绝过期的写请求。</p><h2 id="添加和删除服务器"><a class="markdownIt-Anchor" href="#添加和删除服务器"></a> 添加和删除服务器</h2><p>系统管理员有时需要添加或者删除 <code>Frangipani</code> 服务器。<code>Frangipani</code> 被设计成能够轻易的处理这些场景。</p><p>添加一台服务器到运行中的系统只需要一点点的系统管理工作。新添加的服务器只需要知道使用哪块 <code>Petal</code> 虚拟磁盘以及锁服务的地址即可。新添加的服务器会和锁服务通信来获取租约，然后根据租约标识符决定使用哪部分的日志空间，然后就开始提供服务。系统管理员不需要修改其他服务器的配置，其他服务器能自动适配新服务器的上线。</p><p>删除一台 <code>Frangipani</code> 服务器则更简单。可以直接关闭这台服务器。不过更可取的方式是让这台服务器先将未持久化的数据写入到 <code>Petal</code>，然后释放持有的锁，最后再停机，不过这不是强制要求的。当服务器异常停机时，如果后续该服务器持有的锁需要被使用，则系统会自动发起恢复流程，并最终使得共享磁盘的数据达成一致。同样的，系统管理员也不需要修改其他服务器的配置。</p><p>如 <code>Petal</code> 的论文所描述，<code>Petal</code> 服务器同样可以无缝的添加和删除，锁服务器也同理。</p><h2 id="备份"><a class="markdownIt-Anchor" href="#备份"></a> 备份</h2><p><code>Petal</code> 的快照功能提供了一个简便的方法来备份一份完整的 <code>Frangipani</code> 文件系统快照。<code>Petal</code> 的客户端可以在任意时刻创建一个虚拟磁盘的快照。所创建的快照的虚拟磁盘和普通的虚拟磁盘一样，只不过它是只读的。实际快照实现时采用了写时复制（<code>copy-on-write</code>）技术来提高效率。<code>Petal</code> 创建的快照是崩溃一致的（<code>crash-consistent</code>）：也就是说，快照中保存的是在 <code>Petal</code> 虚拟磁盘中的数据，<code>Frangipani</code> 服务器内存中的数据不会记录到快照中。</p><p>因此，我们可以简单的通过创建 <code>Petal</code> 快照并将其拷贝到磁带中来备份一个 <code>Frangipani</code> 文件系统。快照会包含所有的日志，所以可以将其复制到一个新的 <code>Petal</code> 虚拟磁盘中然后根据日志运行恢复程序来恢复一个 <code>Frangipani</code> 文件系统。归功于崩溃一致的特性，从快照中恢复系统后要解决的问题就简化成了和发生系统级别的停电后恢复系统所要解决的问题一样。</p><p>可以对 <code>Frangipani</code> 稍作修改来改进这个恢复机制，即创建一个系统文件级别一致的快照，从而也无需执行恢复操作。可以让备份程序先强制要求所有的 <code>Frangipani</code> 服务器进入一个栅栏，这个功能可以由锁服务提供的全局锁来实现。每个 <code>Frangipani</code> 服务器以共享的模式获取这把锁然后执行修改操作，而备份程序以互斥的方式来处理请求。当 <code>Frangipani</code> 服务器收到请求要求释放锁时，它会阻塞所有新的修改数据的文件系统调用然后进入栅栏，接着清空缓存中已修改的数据，最后释放锁。当所有的 <code>Frangipani</code> 服务器进入栅栏后，备份程序会以互斥的模式获取锁，然后创建一个 <code>Petal</code> 快照并释放锁。之后各 <code>Frangipani</code> 就可以继续以共享的模式获取锁，然后恢复服务。</p><p>在后一种方案下，一个 <code>Frangipani</code> 的快照可以无需进行恢复就直接挂载使用。用户就可以从新的磁盘卷中在线获取单个文件，或者将其以一个更方便的格式转储到磁带中而无需 <code>Frangipani</code> 参与数据恢复。新添加的卷必须以只读的格式挂载，因为底层的 <code>Petal</code> 快照是只读的。在未来作者可能扩展 <code>Petal</code> 的快照使其可写，或者在 <code>Petal</code> 之上再抽象一层来模拟写操作。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://pdos.csail.mit.edu/6.824/papers/thekkath-frangipani.pdf">Frangipani: A Scalable Distributed File System</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/frangipani-faq.txt">FAQ for Frangipani, Thekkath, Mann, Lee, SOSP 1997</a></li><li><a href="https://kb.synology.com/en-global/DSM/tutorial/What_is_file_system_consistent_snapshot">What is the difference between crash-consistent and file-system consistent snapshots?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;这是一篇上世纪九十年代的论文，在当时的环境下，安装新工作站的需求与日俱增，而针对大量工作站的文件系统管理却费时费力。为了保存更多的文件和服务更多</summary>
      
    
    
    
    
    <category term="MIT 6.824" scheme="https://frederick-s.github.io/tags/MIT-6-824/"/>
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
    <category term="Distributed Systems" scheme="https://frederick-s.github.io/tags/Distributed-Systems/"/>
    
  </entry>
  
</feed>
