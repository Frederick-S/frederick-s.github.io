<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Übung macht den Meister</title>
  
  
  <link href="https://frederick-s.github.io/atom.xml" rel="self"/>
  
  <link href="https://frederick-s.github.io/"/>
  <updated>2022-02-21T16:00:00.000Z</updated>
  <id>https://frederick-s.github.io/</id>
  
  <author>
    <name>Xiaodan Mao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉搜索树的删除</title>
    <link href="https://frederick-s.github.io/2022/02/22/delete-node-in-binary-search-tree/"/>
    <id>https://frederick-s.github.io/2022/02/22/delete-node-in-binary-search-tree/</id>
    <published>2022-02-21T16:00:00.000Z</published>
    <updated>2022-02-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树的删除可以分为三种情况。第一，被删除的节点是叶子节点：</p><p><img src="/images/bst-delete-1.png" alt="alt"></p><p>第二，被删除的节点只有一个孩子节点：</p><p><img src="/images/bst-delete-2.png" alt="alt"></p><p>第三，被删除的节点有两个孩子节点：</p><p><img src="/images/bst-delete-3.png" alt="alt"></p><p>对于第一种情况，我们只需断开被删除的节点和其父节点的关联即可，即将节点3的左孩子节点指针置为空；对于第二种情况，我们可以用被删除的节点的孩子节点来替代被删除的节点，即将节点5的右孩子指针改为指向节点7；第三种情况是最为复杂的情况，相当于删除一个子树的根节点，为了保持二叉搜索树的性质，我们可以使用左子树中的最大值或右子树的最小值来替代被删除的根节点。</p><p>不过在实现时，考虑到实现的简便，对于第三种情况会通过直接修改当前节点的值来替代修改节点的指针指向，以上述例子来说，如果使用指针修改的方式，则需要修改节点5的左孩子指针，修改节点2的左孩子指针和右孩子指针（这里假设使用节点2来替代被删除的节点3），总共三处修改较为繁琐；而如果使用修改节点值的方式，只需要先将节点3的值改为2（这里假设使用节点2来替代被删除的节点3），然后就可以将问题转化为在余下的左子树中删除节点2。具体代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">                root.val = self._find_min(root.right)</span><br><span class="line">                root.right = self.deleteNode(root.right, root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root.left <span class="keyword">or</span> root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_find_min</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉搜索树的删除可以分为三种情况。第一，被删除的节点是叶子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/bst-delete-1.png&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二，被删除的节点只有一个孩子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="https://frederick-s.github.io/tags/Data-Structure/"/>
    
    <category term="Algorithm" scheme="https://frederick-s.github.io/tags/Algorithm/"/>
    
    <category term="Binary Search Tree" scheme="https://frederick-s.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 Lab 1 (1) - MapReduce: Simplified Data Processing on Large Clusters</title>
    <link href="https://frederick-s.github.io/2022/02/13/map-reduce/"/>
    <id>https://frederick-s.github.io/2022/02/13/map-reduce/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2022-02-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>MapReduce: Simplified Data Processing on Large Clusters</code> 是 <a href="https://pdos.csail.mit.edu/6.824/">6.824: Distributed Systems</a> 中所介绍的第一篇论文。它提出了一种针对大数据处理的编程模型和实现，使得编程人员无需并行和分布式系统经验就可以轻松构建大数据处理应用。该模型将大数据处理问题拆解为两步，即 <code>map</code> 和 <code>reduce</code>，<code>map</code> 阶段将一组输入的键值对转化为中间结果键值对，<code>reduce</code> 阶段对中间结果键值对按照相同的键进行值的合并，从而得到最终的结果。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于 <code>Google</code> 来说，每天运行的系统会产生大量的原始数据，同时又要对这些原始数据进行加工产生各种衍生数据，虽然大部分数据加工的逻辑都较为简单，然而由于数据量过于庞大，为了在合理的时间内完成数据处理，通常需要将待处理的数据分发到几百或几千台机器上并行计算，这就存在几个问题：</p><ol><li>如何使计算可并行</li><li>如何分发数据</li><li>如何处理异常</li></ol><p>如果每一个数据加工任务都需要独立去解决上述的问题，一方面会使得原本简单的代码逻辑变得庞大、复杂和难以维护，另一方面也是在重复工作。受 <code>Lisp</code> 等其他函数式编程语言中的 <code>map</code> 和 <code>reduce</code> 函数的启发，<code>Google</code> 的工程师们发现大部分的数据处理遵循如下的模式：</p><ol><li>对输入的每一条数据应用一个 <code>map</code> 函数产生一组中间结果键值对</li><li>对中间结果键值对按照相同的键聚合后，应用 <code>reduce</code> 函数生成最终的衍生数据</li></ol><p>因此，<code>Google</code> 的工程师们抽象出了 <code>MapReduce</code> 框架，使得应用开发人员可以专注于计算逻辑实现而无需关心底层运行细节，统一由框架层处理并行、容错、数据分发和负载均衡等系统问题。现在再来看前面提到的问题是如何解决的：</p><ol><li>如何使计算可并行：在 <code>map</code> 阶段，对数据分发后，各任务间无依赖，可并行执行；在 <code>reduce</code> 阶段，不同 <code>key</code> 的数据处理间无依赖，可并行执行</li><li>如何分发数据：在 <code>map</code> 阶段，可按执行 <code>map</code> 任务的节点数量平均分发（这只是一种可能的策略，具体分发策略见后文描述）；在 <code>reduce</code> 阶段，可按 <code>key</code> 相同的数据聚合后分发</li><li>如何处理异常：重新执行某个节点上失败的 <code>map</code> 或 <code>reduce</code> 任务作为首要的容错手段</li></ol><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><p>假设需要统计一组文档中每个单词出现的次数，在 <code>MapReduce</code> 框架下用户需要编写 <code>map</code> 和 <code>reduce</code> 函数，近似的伪代码表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    &#x2F;&#x2F; key: document name</span><br><span class="line">    &#x2F;&#x2F; value: document contents</span><br><span class="line">    for each word w in value:</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    &#x2F;&#x2F; key: a word</span><br><span class="line">    &#x2F;&#x2F; values: a list of counts</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        result +&#x3D; ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure><p>假设有两个文档 <code>hello.txt</code> 和 <code>world.txt</code>，其内容分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello.txt:</span><br><span class="line">It was the best of times</span><br><span class="line"></span><br><span class="line">world.txt:</span><br><span class="line">it was the worst of times</span><br></pre></td></tr></table></figure><p>对上述 <code>map</code> 和 <code>reduce</code> 函数来说，<code>map</code> 函数每次处理一个文档，<code>key</code> 为文档的名称，<code>value</code> 为文档的内容，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map(&quot;hello.txt&quot;, &quot;It was the best of times&quot;)</span><br><span class="line">map(&quot;world.txt&quot;, &quot;it was the worst of times&quot;)</span><br></pre></td></tr></table></figure><p><code>map</code> 函数执行时会遍历文档的内容，对每个单词输出中间结果键值对（作为示例，这里省去了将文档内容拆分为单词的过程，同时也忽略了标点符号、大小写等与示例无关的内容），键为单词，值为 <code>&quot;1&quot;</code>，所有 <code>map</code> 函数执行完成后生成的中间结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hello.txt:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">best 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br><span class="line"></span><br><span class="line">world.txt:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">worst 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br></pre></td></tr></table></figure><p>然后，<code>MapReduce</code> 框架对所有中间结果按照相同的键进行聚合，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">was [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">the [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">best [&quot;1&quot;]</span><br><span class="line">worst [&quot;1&quot;]</span><br><span class="line">of [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">times [&quot;1&quot;, &quot;1&quot;]</span><br></pre></td></tr></table></figure><p>最后，<code>MapReduce</code> 框架将上述聚合后的数据分发给 <code>reduce</code> 函数执行，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reduce(&quot;it&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;was&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;the&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;best&quot;, [&quot;1&quot;])</span><br><span class="line">reduce(&quot;worst&quot;, [&quot;1&quot;])</span><br><span class="line">reduce(&quot;of&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;times&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br></pre></td></tr></table></figure><p><code>reduce</code> 函数执行时会遍历 <code>values</code>，将每个字符串转换为整型后累加，然后作为 <code>reduce</code> 的结果返回，最终得到所有单词出现的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it 2</span><br><span class="line">was 2</span><br><span class="line">the 2</span><br><span class="line">best 1</span><br><span class="line">worst 1</span><br><span class="line">of 2</span><br><span class="line">times 2</span><br></pre></td></tr></table></figure><p>实际执行 <code>reduce</code> 函数时，并不会将 <code>values</code> 一次性传给某个 <code>reduce</code> 函数，因为有可能数据量太大无法完全载入内存，所以 <code>values</code> 在实现时是个迭代器，<code>reduce</code> 函数能以流式的形式获取值。</p><p>另外，虽然在上述的例子中 <code>map</code> 和 <code>reduce</code> 处理的都是字符串类型的数据，但是也可以支持其他类型的数据，<code>map</code> 和 <code>reduce</code> 处理的数据类型遵循如下的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map (k1, v1) -&gt; list(k2, v2)</span><br><span class="line">reduce (k2, list(v2)) -&gt; list(v2)</span><br></pre></td></tr></table></figure><p>可以看到，<code>map</code> 产生的中间结果的数据类型和最终结果的数据类型是一致的。对整个框架来说，最初的输入和最终的输出都是某种形式的字节流或字符串，因此在 <code>Google</code> 的 <code>C++</code> 实现中，提供了专门的数据转换接口，用户可实现该接口用于字符串和 <code>map</code>、<code>reduce</code> 需要的数据类型之间转换。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>MapReduce</code> 的具体实现视硬件环境的不同而不同，论文中描述的实现是针对 <code>Google</code> 内部广泛使用的硬件环境，即通过交换以太网相连的大量廉价 <code>PC</code> 组成的集群：</p><ol><li>每台机器的配置一般为双核 <code>x86</code> 处理器，<code>2-4 GB</code> 内存，运行 <code>Linux</code> 系统</li><li>使用廉价网络硬件，带宽一般为 <code>100 Mbit/s</code> 或 <code>1 Gbit/s</code>，不过平均来说会小于 <code>bisection bandwidth</code>（<code>bisection bandwidth</code> 指当某个网络被分成两部分时，这两部分间的带宽）</li><li>一个集群一般由几百上千台机器组成，所以机器异常是家常便饭</li><li>存储使用的是廉价的 <code>IDE</code> 硬盘，并直接装载到了机器上。不过 <code>Google</code> 内部实现了一套分布式文件存储系统来管理这些硬盘上的数据，并通过数据冗余作为在不可靠的硬件上实现可用性和可靠性的手段。</li><li>用户向调度系统提交一组任务，每个任务包含多个子任务，调度系统会为每个任务分配一批集群内的机器执行。</li></ol><h3 id="执行概览"><a href="#执行概览" class="headerlink" title="执行概览"></a>执行概览</h3><p>在 <code>map</code> 执行阶段，框架会自动将输入数据分为 <code>M</code> 片，从而将 <code>map</code> 任务分发到多台机器上并行执行，每台机器只处理某一片的数据。同样的，在 <code>reduce</code> 阶段，框架首先将中间结果数据根据分片函数（例如 <code>hash(key) mod R</code>）拆分为 <code>R</code> 片，然后分发给 <code>reduce</code> 任务执行，用户可自行指定 <code>R</code> 的值和实现具体的分片函数。</p><p>下图展示了 <code>Google</code> 所实现的 <code>MapReduce</code> 框架的整体执行流程：</p><p><img src="/images/map-reduce.png" alt="alt"></p><p>当用户提交 <code>MapReduce</code> 任务后，框架会执行以下一系列流程（下文中的序号和上图中的序号对应）：</p><ol><li>首先 <code>MapReduce</code> 框架将输入数据分为 <code>M</code> 片，每片数据大小一般为 <code>16 MB</code> 至 <code>64 MB</code>（具体大小可由用户入参控制），然后将 <code>MapReduce</code> 程序复制到集群中的一批机器上运行。</li><li>在所有的程序拷贝中，某台机器上的程序会成为主节点（<code>master</code>），其余称为工作节点（<code>worker</code>），由主节点向工作节点分派任务，一共有 <code>M</code> 个 <code>map</code> 任务和 <code>R</code> 个 <code>reduce</code> 任务需要分派。主节点会选择空闲的工作节点分派 <code>map</code> 或 <code>reduce</code> 任务。</li><li>如果某个工作节点被分派了 <code>map</code> 任务则会读取当前的数据分片，然后将输入数据解析为一组键值对后传递给用户自定义的 <code>map</code> 函数执行。<code>map</code> 函数产生的中间结果键值对会暂存在内存中。</li><li>暂存在内存中的中间结果键值对会周期性的写入到本地磁盘中，并根据某个分片函数将这些数据写入到本地磁盘下的 <code>R</code> 个区，这样相同键的中间结果数据在不同的 <code>map</code> 节点下属于同一个区号，就可以在后续将同一个键的中间结果数据全部发给同一个 <code>reduce</code> 节点。同时，这些数据写入后的地址会回传给 <code>master</code> 节点，<code>master</code> 节点会将这些数据的地址发送给相应的 <code>reduce</code> 节点。</li><li>当 <code>reduce</code> 节点接收到 <code>master</code> 节点发送的中间结果数据地址通知后，将通过 <code>RPC</code> 请求根据数据地址读取 <code>map</code> 节点生成的数据。在所有中间结果数据都读取完成后，<code>reduce</code> 节点会先将所有中间结果数据按照键进行排序，这样所有键相同的数据就聚合在了一起。之所以要排序是因为一个 <code>reduce</code> 节点会分发处理多个键下的中间结果数据。如果中间结果数据量太大不足以完全载入内存，则需要使用外部排序。</li><li><code>reduce</code> 节点执行时会先遍历排序后的中间结果数据，每遇到一个新的键就会将该键及其对应的所有中间结果数据传递给用户自定义的 <code>reduce</code> 函数执行。<code>reduce</code> 函数执行的结果数据会追加到当前 <code>reduce</code> 节点的最终输出文件里。</li><li>当所有 <code>map</code> 任务和 <code>reduce</code> 任务都执行完成后，<code>master</code> 节点会唤醒用户程序，并将控制权交还给用户代码。</li></ol><p>当成功结束 <code>MapReduce</code> 任务后，其执行结果就保存在了 <code>R</code> 个文件中（每个文件对应一个 <code>reduce</code> 节点的产出，文件的名字由用户所指定）。一般来说，用户不必将这 <code>R</code> 个输出文件合并成一个，它们通常会作为另一个 <code>MapReduce</code> 任务的输入，或交由其他分布式应用处理。</p><p>基于上述流程，再来看在 <code>编程模型</code> 这节中的例子。假设有6个文档，分别是 <code>1.txt</code> 到 <code>6.txt</code>，每个文档中的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.txt:</span><br><span class="line">It was the best of times</span><br><span class="line"></span><br><span class="line">2.txt:</span><br><span class="line">it was the worst of times</span><br><span class="line"></span><br><span class="line">3.txt:</span><br><span class="line">it was the age of wisdom</span><br><span class="line"></span><br><span class="line">4.txt:</span><br><span class="line">it was the age of foolishness</span><br><span class="line"></span><br><span class="line">5.txt:</span><br><span class="line">it was the epoch of belief</span><br><span class="line"></span><br><span class="line">6.txt:</span><br><span class="line">it was the epoch of incredulity</span><br></pre></td></tr></table></figure><p>对应 <code>MapReduce</code> 执行流程为：</p><ol><li>我们假设每两个文档的数据大小为 <code>16 MB</code>，则6个文档对应3片数据</li><li>由1所知一共有3个 <code>map</code> 任务，不妨将 <code>reduce</code> 任务也设为3个，并将6个文档按顺序每两个一组依次分发给每个 <code>map</code> 节点</li><li>每个 <code>map</code> 节点处理的数据分片为两个文档，所产生的中间结果数据分别为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">map worker 1:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">best 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">worst 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br><span class="line"></span><br><span class="line">map worker 2:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">age 1</span><br><span class="line">of 1</span><br><span class="line">wisdom 1</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">age 1</span><br><span class="line">of 1</span><br><span class="line">foolishness 1</span><br><span class="line"></span><br><span class="line">map worker 3:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">epoch 1</span><br><span class="line">of 1</span><br><span class="line">belief 1</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">epoch 1</span><br><span class="line">of 1</span><br><span class="line">incredulity 1</span><br></pre></td></tr></table></figure></li><li>在每个 <code>map</code> 节点上将中间结果数据按照某个哈希函数分发到3个区，不妨为以下结果： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">map worker 1:</span><br><span class="line">    region 1:</span><br><span class="line">    it 1</span><br><span class="line">    best 1</span><br><span class="line">    it 1</span><br><span class="line"></span><br><span class="line">    region 2:</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    was 1</span><br><span class="line">    worst 1</span><br><span class="line">    of 1</span><br><span class="line"></span><br><span class="line">    region 3:</span><br><span class="line">    the 1</span><br><span class="line">    times 1</span><br><span class="line">    the 1</span><br><span class="line">    times 1</span><br><span class="line"></span><br><span class="line">map worker 2:</span><br><span class="line">    region 1:</span><br><span class="line">    it 1</span><br><span class="line">    age 1</span><br><span class="line">    it 1</span><br><span class="line">    age 1</span><br><span class="line">    foolishness 1</span><br><span class="line"></span><br><span class="line">    region 2:</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    of 1</span><br><span class="line">    wisdom 1</span><br><span class="line">    was 1</span><br><span class="line"></span><br><span class="line">    region 3:</span><br><span class="line">    the 1</span><br><span class="line">    the 1</span><br><span class="line"></span><br><span class="line">map worker 3:</span><br><span class="line">    region 1:</span><br><span class="line">    it 1</span><br><span class="line">    epoch 1</span><br><span class="line">    belief 1</span><br><span class="line">    it 1</span><br><span class="line">    epoch 1</span><br><span class="line">    </span><br><span class="line">    region 2:</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    </span><br><span class="line">    region 3:</span><br><span class="line">    the 1</span><br><span class="line">    the 1</span><br><span class="line">    incredulity 1</span><br></pre></td></tr></table></figure></li><li><code>reduce</code> 节点按照数据分区接收到所有中间结果数据后将其按照键排序： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">reduce worker 1:</span><br><span class="line">age 1</span><br><span class="line">age 1</span><br><span class="line">belief 1</span><br><span class="line">best 1</span><br><span class="line">epoch 1</span><br><span class="line">epoch 1</span><br><span class="line">foolishness 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line"></span><br><span class="line">reduce worker 2:</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">wisdom 1</span><br><span class="line">worst 1</span><br><span class="line"></span><br><span class="line">reduce worker 3:</span><br><span class="line">incredulity 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">times 1</span><br><span class="line">times 1</span><br></pre></td></tr></table></figure></li><li><code>reduce</code> 节点调用用户自定义 <code>reduce</code> 函数计算单词出现次数，最终每个 <code>reduce</code> 节点的输出文件为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">reduce worker 1 output:</span><br><span class="line">age 2</span><br><span class="line">belief 1</span><br><span class="line">best 1</span><br><span class="line">epoch 2</span><br><span class="line">foolishness 1</span><br><span class="line">it 6</span><br><span class="line"></span><br><span class="line">reduce worker 2 output:</span><br><span class="line">of 6</span><br><span class="line">was 6</span><br><span class="line">wisdom 1</span><br><span class="line">worst 1</span><br><span class="line"></span><br><span class="line">reduce worker 3 output:</span><br><span class="line">incredulity 1</span><br><span class="line">the 6</span><br><span class="line">times 2</span><br></pre></td></tr></table></figure></li><li>将代码控制权交还给用户代码</li></ol><h3 id="Master-节点数据结构"><a href="#Master-节点数据结构" class="headerlink" title="Master 节点数据结构"></a>Master 节点数据结构</h3><p><code>master</code> 节点需要维护当前所有的 <code>map</code> 和 <code>reduce</code> 任务，每个任务需区分不同的状态（空闲、进行中、完成），同时还需要知道每个任务对应的工作节点。作为 <code>map</code> 节点和 <code>reduce</code> 节点间中间结果数据的传输媒介，<code>master</code> 节点需保存 <code>R</code> 个中间结果分区，每当一个 <code>map</code> 节点执行成功时，会将生成的 <code>R</code> 个中间结果文件地址发送给 <code>master</code> 节点，当 <code>master</code> 节点收到通知后，会将其转发给对应进行中的 <code>reduce</code> 节点。</p><p>对应数据结构简单示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 任务状态</span><br><span class="line">enum TaskState &#123;</span><br><span class="line">    &#x2F;&#x2F; 空闲</span><br><span class="line">    Idle,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 进行中</span><br><span class="line">    InProgress,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 完成</span><br><span class="line">    Completed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个 map 或 reduce 任务</span><br><span class="line">class Task &#123;</span><br><span class="line">    &#x2F;&#x2F; 任务状态</span><br><span class="line">    TaskState state;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对应的工作节点 id</span><br><span class="line">    int workerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 工作节点</span><br><span class="line">class Worker &#123;</span><br><span class="line">    &#x2F;&#x2F; 节点 id</span><br><span class="line">    int id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Map 任务产生的中间结果文件，一个 map 任务一般会产生多个中间结果文件</span><br><span class="line">class IntermediateFile &#123;</span><br><span class="line">    &#x2F;&#x2F; 文件地址</span><br><span class="line">    string location;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 文件大小</span><br><span class="line">    long size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中间结果文件集，所有 map 任务产生的中间结果文件会根据分片函数划分到本地磁盘下的 R 个区</span><br><span class="line">class IntermediateFileRegion &#123;</span><br><span class="line">    &#x2F;&#x2F; 中间结果文件</span><br><span class="line">    IntermediateFile[] intermediateFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Map 节点</span><br><span class="line">class MapWorker : Worker &#123;</span><br><span class="line">    &#x2F;&#x2F; 中间结果文件集，一共有 R 个</span><br><span class="line">    IntermediateFileRegion[] intermediateFileRegions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Reduce 节点</span><br><span class="line">class ReduceWorker : Worker &#123;</span><br><span class="line">    &#x2F;&#x2F; 中间结果文件，master 节点会不断发送中间结果文件给 reduce 节点，当所有中间结果文件都收到后，reduce 节点开始工作</span><br><span class="line">    IntermediateFile[] intermediateFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主节点</span><br><span class="line">class Master &#123;</span><br><span class="line">    &#x2F;&#x2F; Map 任务，一共有 M 个</span><br><span class="line">    Task[] mapTasks;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Reduce 任务，一共有 R 个</span><br><span class="line">    Task[] reduceTasks;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 工作节点，最多有 M + R 个，一个工作节点并不是只负责 map 或者 reduce 任务，master 节点会选择空闲节点分派 map 或者 reduce 任务</span><br><span class="line">    Worker[] workers;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 中间结果文件集，一共有 R 个，由 map 节点下的中间结果文件集聚合而来，某个 map 节点执行成功后会将生成的 R 个中间结果文件地址发送给 master 节点，由 master 节点将某个区下的中间结果文件地址转发给对应 reduce 节点</span><br><span class="line">    IntermediateFileRegion[] intermediateFileRegions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>因为 <code>MapReduce</code> 框架借助几百或几千台机器来处理海量数据，所以必须优雅的应对机器异常。</p><h4 id="工作节点异常"><a href="#工作节点异常" class="headerlink" title="工作节点异常"></a>工作节点异常</h4><p><code>master</code> 节点会周期性的对工作节点进行探活。如果某个工作节点在一段时间内无响应，则 <code>master</code> 节点会将该工作节点标记为异常。该工作节点完成的所有 <code>map</code> 任务的状态都会被重置为空闲，可重新被 <code>master</code> 节点调度到其他工作节点上执行。类似的，该工作节点所有进行中的 <code>map</code> 或 <code>reduce</code> 任务也都会被重置为空闲，并重新接受调度。</p><p>之所以这里已完成的 <code>map</code> 任务也需要重新执行是因为所产生的中间结果文件是保存在 <code>map</code> 节点的本地磁盘上，当该节点无响应时便认为无法与之连通从而认为无法通过 <code>RPC</code> 请求获取这些数据。而如果 <code>reduce</code> 节点异常，它所完成的 <code>reduce</code> 任务不需要重新执行是因为 <code>reduce</code> 节点执行成功后产生的输出文件是保存在全局的文件系统上。</p><p>如果某个 <code>map</code> 任务一开始由工作节点 <code>A</code> 执行，之后由工作节点 <code>B</code> 执行（因为节点 <code>A</code> 发生了异常），则所有执行 <code>reduce</code> 任务的节点都会被通知，其中所有要从节点 <code>A</code> 读取数据但还未读取的 <code>reduce</code> 节点会转而从节点 <code>B</code> 读取数据。</p><p><code>MapReduce</code> 框架能从容应对大量的节点异常。例如，在某次 <code>MapReduce</code> 任务中，由于对运行中的集群进行网络维护一次性造成了80台机器在几分钟内无法连通。<code>MapReduce</code> 框架可直接重新分发和执行这些不连通的节点正在处理的任务，然后继续后续流程，并最终完成当次任务。</p><h4 id="主节点异常"><a href="#主节点异常" class="headerlink" title="主节点异常"></a>主节点异常</h4><p>类似于游戏的自动存档，我们可以定期为主节点内部的数据结构保存检查点。如果主节点发生异常，则可以重新启动一个主节点程序并加载最新的检查点数据。然而对于单个主节点来说，主节点异常发生的概率较小，所以在 <code>Google</code> 的实现中，如果主节点发生异常，则会直接中断当次 <code>MapReduce</code> 任务。客户端可捕获到这种情况，并根据自身需要决定是否进行重试。</p><h4 id="执行语义"><a href="#执行语义" class="headerlink" title="执行语义"></a>执行语义</h4><p>如果用户编写的 <code>map</code> 和 <code>reduce</code> 函数是确定性的函数（即对于相同的输入始终返回相同的输出），则对于同一份输入，分布式的 <code>MapReduce</code> 框架的执行结果和一个串行执行且没有任何异常的 <code>MapReduce</code> 框架的执行结果相同。</p><p>不论是 <code>map</code> 还是 <code>task</code> 任务，都需要将执行结果写入到文件系统上，通过原子性的写入提交，可实现上述的语义保证。每个进行中的任务会先将输出结果写入到私有临时文件中，对 <code>reduce</code> 任务来说，最终只产生一个文件，而对于 <code>map</code> 任务则会产生 <code>R</code> 个文件（每个文件对应一个 <code>reduce</code> 任务）。当一个 <code>map</code> 任务执行完成时，<code>map</code> 节点会发送一条消息给 <code>master</code> 节点，这条消息中包含了 <code>map</code> 任务所生成的 <code>R</code> 个临时文件的名字。如果 <code>master</code> 节点收到了一条已经完成的 <code>map</code> 任务的消息，则会忽略该消息，否则将 <code>R</code> 个临时文件的名字保存在内部的数据结构中。</p><p>当 <code>reduce</code> 任务执行完成时，<code>reduce</code> 节点能原子性的将其生成的临时文件重命名为最终的输出文件。如果同一个 <code>reduce</code> 任务有多个工作节点执行（因为网络连通问题导致 <code>master</code> 重新分发 <code>reduce</code> 任务），则对同一个最终输出文件会有多个文件重命名的请求。通过底层文件系统的原子性重命名保证，最终的输出文件只会对应一个 <code>reduce</code> 任务的结果。</p><p>在 <code>Google</code> 内部大部分的 <code>map</code> 和 <code>reduce</code> 函数都是确定性的，在这种情况下分布式程序执行的结果和串行程序执行的结果相同的语义性保证使得开发人员能很容易的审视所编写的程序的行为（即如果程序的执行结果不符合预期，那么可以基本肯定的是开发人员编写的 <code>map</code> 或者 <code>reduce</code> 函数存在问题，而不是 <code>MapReduce</code> 框架存在问题）。当 <code>map</code> 或者 <code>reduce</code> 函数不具有确定性时，框架能提供稍弱一级但仍是合理的语义性保证。在非确定性的函数下，某个 <code>reduce</code> 任务 <code>R1</code> 由分布式执行的结果等价于一个串行执行的程序 <code>A</code> 执行 <code>R1</code> 后的结果。但是，另一个 <code>reduce</code> 任务 <code>R2</code> 的执行结果也可能等同于由另一个不同的串行执行的程序 <code>B</code> 执行后的结果。</p><p>假设有一个 <code>map</code> 任务 <code>M</code>，以及总共有两个 <code>reduce</code> 任务 <code>R1</code> 和 <code>R2</code>，记 <code>e(Ri)</code> 表示 <code>Ri</code> 执行并提交成功的结果。以前面的单词统计为例，假设发送给 <code>map</code> 任务的只有两个文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.txt:</span><br><span class="line">It was the best of times</span><br><span class="line"></span><br><span class="line">2.txt:</span><br><span class="line">it was the worst of times</span><br></pre></td></tr></table></figure><p>在 <code>map</code> 函数是非确定性的情况下，不妨这样实现 <code>map</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    &#x2F;&#x2F; key: document name</span><br><span class="line">    &#x2F;&#x2F; value: document contents</span><br><span class="line">    for each word w in value:</span><br><span class="line">        r &#x3D; Random(0, 1)</span><br><span class="line"></span><br><span class="line">        if r &gt; 0.5:</span><br><span class="line">            EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line">        else:</span><br><span class="line">            EmitIntermediate(w, &quot;0&quot;);</span><br></pre></td></tr></table></figure><p>即对于某个单词，<code>map</code> 函数有一半的概率计数为1，一半的概率计数为0。</p><p>类似的，以同样的手段来实现 <code>reduce</code> 函数，对于某个单词的所有出现次数，<code>reduce</code> 函数有一半的概率会计数，一半的概率会忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    &#x2F;&#x2F; key: a word</span><br><span class="line">    &#x2F;&#x2F; values: a list of counts</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        r &#x3D; Random(0, 1)</span><br><span class="line"></span><br><span class="line">        if r &gt; 0.5:</span><br><span class="line">            result +&#x3D; ParseInt(v);</span><br><span class="line">        else:</span><br><span class="line">            result +&#x3D; 0;</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure><p>令 <code>R1</code> 为统计单词 <code>it</code> 的个数，经过 <code>map</code> 任务后，生成的中间结果键值对可能为以下四种情况：</p><ol><li>[0, 1]</li><li>[1, 0]</li><li>[1, 1]</li><li>[0, 0]</li></ol><p>最后由 <code>reduce</code> 任务执行后的结果可能为0、1、2三种情况，而相同的输入由一个串行执行的程序来执行也是同样的结果，即不管是分布式的程序还是串行的程序最终结果都是相同的集合，所以认为两者是等价的，也是合理的。</p><p>在确定性的函数下，相同的输入必然返回相同的输出，而在不确定性的函数下，不同的输入可能返回相同的输出或者相同的输入可能返回不同的输出。这就类似于知道 <code>x</code> 的定义域是 <code>&#123;1, 2, 3&#125;</code>，<code>y</code> 值域是 <code>&#123;4, 5, 6&#125;</code>，求 <code>f(x)</code>，显然 <code>f(x)</code> 存在不止唯一的解。</p><p>记上述的 <code>map</code> 和 <code>reduce</code> 函数组成的串行程序为 <code>A</code>，假设有另一个串行程序 <code>B</code>，其中 <code>map</code> 函数不变，<code>reduce</code> 函数变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    &#x2F;&#x2F; key: a word</span><br><span class="line">    &#x2F;&#x2F; values: a list of counts</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        r &#x3D; Random(0, 1)</span><br><span class="line"></span><br><span class="line">        if r &gt; 0.5:</span><br><span class="line">            result +&#x3D; 0;</span><br><span class="line">        else:</span><br><span class="line">            result +&#x3D; ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure><p>令 <code>R2</code> 为统计单词 <code>was</code> 的个数，由 <code>A</code> 或 <code>B</code> 执行的最终结果都等于集合 <code>&#123;0, 1, 2&#125;</code>，相比于确定性的函数，开发人员因此无法有效的审视所编写函数的行为。</p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>在 <code>Google</code> 内部的运行环境中网络带宽属于稀缺资源，不管是 <code>map</code> 还是 <code>reduce</code> 任务都依托于文件的读取，不可避免的会产生大量网络 <code>IO</code>。而在前面提到，<code>Google</code> 内部实现了一套分布式文件存储系统（<code>GFS</code>）来管理存储在集群内机器本地磁盘上的文件，对于每一个文件 <code>GFS</code> 会将其切分为若干个 <code>64MB</code> 的数据块，每个数据块存有多份冗余（一般是3份）保存在不同的机器上。对于 <code>MapReduce</code> 框架来说，原始的数据输入是保存在本地磁盘上的，依据这个特性，框架在分发 <code>map</code> 任务时，根据输入数据在 <code>GFS</code> 内的位置会优先选择本地磁盘上存有对应输入数据的工作节点。如果找不到这样的工作节点，则会选择一个距离输入数据最近的工作节点（例如工作节点和存有输入数据的节点由同一个交换机相连）。当运行大量的 <code>MapReduce</code> 任务时，大部分的输入数据都是从本地读取从而不消耗任何网络带宽。</p><h3 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h3><p>如前文所述 <code>MapReduce</code> 框架会根据输入数据拆分为 <code>M</code> 个 <code>map</code> 任务和 <code>R</code> 个 <code>reduce</code> 任务。理想情况下，<code>M</code> 和 <code>R</code> 的值应该远大于工作节点的数量。为什么需要远大于？首先，<code>M</code> 和 <code>R</code> 的数量比工作节点的数量少是不适合的，会造成资源空闲；其次，如果 <code>M</code> 和 <code>R</code> 的数量和工作节点相等，由于每台机器的处理能力有差异或者输入数据不同，每个工作节点完成某个任务需要的时间也不同，会存在部分机器先完成任务的情况，同样会造成资源空闲，另一方面 <code>MapReduce</code> 面向的是大数据处理，输入数据的数据量远大于工作节点的数量，<code>M</code> 和 <code>R</code> 数量较少的情况下单个工作节点需要处理的数据量则较大，单次处理时间可能较慢，而如果发生了异常，重新执行的成本也较高。所以 <code>M</code> 和 <code>R</code> 的数量设置较大能更好的应对负载均衡，性能好的机器在完成任务后可以继续处理其他任务，同时当某个任务执行异常时也能更快的恢复：该异常的工作节点已完成的 <code>map</code> 任务可分发给余下的工作节点执行。</p><p>当然 <code>M</code> 和 <code>R</code> 的数量也是存在上限的，对于 <code>master</code> 节点来说，它需要维护 <code>M</code> 个 <code>map</code> 任务和 <code>R</code> 个 <code>reduce</code> 任务，时间复杂度是 <code>O(M + R)</code>，另一方面每个 <code>map</code> 任务会产出 <code>R</code> 份中间结果数据，对应 <code>R</code> 个 <code>reduce</code> 任务，所以 <code>master</code> 节点也需要 <code>O(M * R)</code> 的空间复杂度来维护这样的对应关系（<code>Google</code> 实际实现时，每个 <code>map/reduce</code> 关系对约占据 <code>1 byte</code> 内存）。</p><p>另外，由于每个 <code>reduce</code> 任务的最终产出结果是一个单独的文件所以 <code>R</code> 的数量受用户设置限制。在实践中，会趋向于让每个 <code>map</code> 任务处理 <code>16 MB</code> 到 <code>64 MB</code> 的输入数据来确定 <code>M</code> 的大小，因为 <code>64 MB</code> 正好是 <code>GFS</code> 单个数据块的大小，这样每个 <code>map</code> 任务必然能从本地磁盘读取输入数据而不会涉及网络 <code>IO</code>（如果能将任务分发给存有对应输入数据的节点的话），而 <code>R</code> 的数量会在工作节点的数量上乘上一个较小的常数得到。<code>Google</code> 内部运行 <code>MapReduce</code> 任务时通常设置 <code>M</code> 为200000，使用2000台机器的情况下设置 <code>R</code> 为5000。</p><h3 id="后备任务"><a href="#后备任务" class="headerlink" title="后备任务"></a>后备任务</h3><p>类似于木桶原理，一次 <code>MapReduce</code> 任务完成的时间取决于最慢的机器完成 <code>map</code> 或 <code>reduce</code> 任务的时间，这也是造成 <code>MapReduce</code> 任务耗时长的常见原因之一。某台机器执行慢可能有好几个原因造成，例如某台机器的磁盘存在异常，可能频繁遭遇可校正的异常，从而使得磁盘的读速度从 <code>30 MB/s</code> 降低到 <code>1 MB/s</code>。而调度系统同时有可能分配了其他的任务给这台机器，会进一步引发 <code>CPU</code>、内存、本地磁盘、网络带宽的竞争，从而造成执行 <code>MapReduce</code> 任务的耗时更长。<code>Google</code> 内部曾经遇到一个问题，由于机器初始化代码中的一个 <code>bug</code> 造成处理器的缓存被禁用，在这些受影响的机器上运行的任务耗时增长了超过100倍。</p><p>针对这个问题，<code>Google</code> 提出了一个通用的缓解机制。当一次 <code>MapReduce</code> 任务快执行结束时，框架会将剩余还在进行中的任务分配给其他机器执行。不管是原先分配的机器执行完成，还是新分配的机器执行完成，对应的任务都将标记为完成。让一个任务由两台机器同时执行势必存在资源浪费，<code>Google</code> 通过调优使得耗费的计算资源控制在了增加几个百分比以内。这个机制在处理一个数据量巨大的 <code>MapReduce</code> 任务时能大幅降低整体耗时。在某个约需处理 <code>1T</code> 数据的排序任务中，不启用这个机制的情况下整体耗时会增加44%。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>大多数情况下用户仅需编写 <code>map</code> 和 <code>reduce</code> 函数就能满足需求，本节主要描述一些 <code>MapReduce</code> 的扩展，可能在某些场合下会比较有用。</p><h3 id="分片函数"><a href="#分片函数" class="headerlink" title="分片函数"></a>分片函数</h3><p>用户可指定 <code>MapReduce</code> 任务最终输出文件的数量 <code>R</code>，也即 <code>reduce</code> 任务的数量。那么由 <code>map</code> 任务产生的中间结果数据应该发给哪个 <code>reduce</code> 节点执行呢？这个就交由分片函数决定，默认的分片函数是哈希函数（例如 <code>hash(key) mod R</code>），这种分片结果一般比较均匀。不过，有时候自定义分片函数会更有用，例如，当最终结果文件的键是 <code>URL</code> 时，我们希望同属于一个 <code>host</code> 下的 <code>URL</code> 对应的数据最终都在同一个文件里，用户可自定义分片函数来实现，例如 <code>hash(Hostname(urlkey)) mod R</code>，即先通过 <code>urlkey</code> 提取 <code>host</code>，然后对 <code>host</code> 计算哈希最后取模 <code>R</code>。</p><h3 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h3><p><code>MapReduce</code> 框架保证在同一个中间结果分区内，即同一个 <code>reduce</code> 任务内，中间结果数据是按照键的升序处理的，因为 <code>reduce</code> 任务处理前会先将中间结果数据按照键进行排序。这样在 <code>reduce</code> 任务处理完成后，最终结果文件内的数据也是按照键的顺序排序的，这就有利于对最终结果文件按键进行高效的随机查找，或方便其他需要排好序的数据的场景。</p><h3 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数"></a>合并函数</h3><p>在某些场景下，<code>map</code> 任务产生的中间结果数据的键存在大量的重复，同时用户编写的 <code>reduce</code> 函数又符合交换律和结合律（即 <code>a + b = b + a</code>，<code>(a + b) + c = a + (b + c)</code>）。一个典型案例就是前文描述的单词计数程序，每个 <code>map</code> 任务都会产生成百上千的形如 <code>&lt;the, 1&gt;</code> 的中间结果数据，其中 <code>the</code> 指某个单词，1表示该单词出现的次数。这些同键的中间结果数据接着会经过网络传输发送给 <code>reduce</code> 任务，然后由 <code>reduce</code> 函数合并相加。为了减少这种雷同数据的网络传输，用户可编写自定义的合并函数，<code>map</code> 任务在生成中间结果数据前先进行同键的合并，从而将原来成百上千的同键网络传输降低为1次。</p><p>一般来说，合并函数和 <code>reduce</code> 函数的用户代码实现是相同的。不同在于 <code>MapReduce</code> 框架如何处理这两个函数产出的结果，<code>reduce</code> 函数的产出结果会写到最终的结果文件里，而合并函数的产出结果会写到中间结果文件里，然后发送给 <code>reduce</code> 任务。</p><p>在特定情况下，由于省去了大量的网络 <code>IO</code>，合并函数能显著的降低一次 <code>MapReduce</code> 任务执行的耗时。</p><h3 id="输入和输出类型"><a href="#输入和输出类型" class="headerlink" title="输入和输出类型"></a>输入和输出类型</h3><p><code>MapReduce</code> 框架支持从多个数据格式读取输入数据。例如，<code>text</code> 模式下将输入数据的每一行作为键值对，其中键通过在文本中的偏移量来确定，而值就是当前行的内容。另一种通用支持的格式是本身保存了已排好序的键值对。不管是哪种输入格式，<code>MapReduce</code> 都能从原始输入中准确切分出键值对供 <code>map</code> 任务使用（例如 <code>text</code> 模式保证以每一行的结束进行切分）。用户也可实现自定义的 <code>reader</code> 接口来支持读取新的输入格式，不过大部分情况下内置的输入格式已经能满足需求。</p><p>虽然前文描述过 <code>MapReduce</code> 的原始输入数据来源于文本文件，不过用户自定义的 <code>reader</code> 接口并不一定要从文本文件读取，例如还可以从数据库或内存中读取。</p><p>类似的，<code>MapReduce</code> 框架也支持不同的最终输出数据的格式，用户也同样可实现支持自定义的输出格式。</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>在某些情况下，用户可能希望在 <code>map</code> 或 <code>reduce</code> 阶段生成额外的辅助文件，这就要求开发人员自己保证输出文件的原子性和幂等性，特别是用户程序先将数据写入到临时文件内，最后在所有数据写入完成后能原子性的将临时文件重命名。</p><p>不过，<code>MapReduce</code> 框架本身并不支持两阶段协议来保证 <code>map</code> 或 <code>reduce</code> 任务输出多个文件时的一致性，同样的，这也需要开发人员自己来保证。因此多文件一致性对应的任务应当是确定性的，否则如何确定产出的文件是符合一致性的？而在实践中要求任务是确定性的并不是个问题。</p><h3 id="忽略异常数据"><a href="#忽略异常数据" class="headerlink" title="忽略异常数据"></a>忽略异常数据</h3><p>有时候由于用户编写的 <code>map</code> 或 <code>reduce</code> 函数存在 <code>bug</code>，导致处理某些数据时 <code>map</code> 或 <code>reduce</code> 函数必然发生异常，这就造成 <code>MapReduce</code> 任务无法正常完成。正常来说应当修复 <code>bug</code>，但有时候不可行，例如造成 <code>bug</code> 的代码可能是第三方库引入的。另一方面，有时候忽略这些造成异常的数据也是可以接受的，例如在对一个数据量非常庞大的数据集做统计分析时。因此，<code>MapReduce</code> 框架提供了一种可选的执行模式，当其检测到某些输入数据必然造成异常时，则会跳过这些数据从而使得执行流程能继续走下去。</p><p>为了实现这个功能，首先每个工作节点上都安装了一个 <code>signal handler</code> 程序用于捕获段异常和总线异常。在执行 <code>map</code> 或 <code>reduce</code> 任务之前，<code>MapReduce</code> 框架首先将当前任务需要的输入数据所对应的序号保存在工作节点内的一个全局变量中，在执行 <code>map</code> 或 <code>reduce</code> 任务时，如果用户代码发生异常，此时 <code>signal handler</code> 能捕获到相应的异常信号，然后 <code>signal handler</code> 会发送一个 <code>UDP</code> 数据包给主节点，该数据包中包含了执行当次任务的输入数据序号。如果主节点发现某个数据对应的任务执行失败了多次，则会忽略该数据而不是重新执行 <code>map</code> 或 <code>reduce</code> 任务。按照这样的描述，被忽略的数据是数据片维度，而不是键值对维度，因为每片的数据块大小相比于总数据量的大小来说微乎其微，所以整体影响不大。</p><h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>调试分布式程序并不是件简单的事，对于 <code>MapReduce</code> 任务来说，一次任务会被分发到几千台机器上执行，每台机器实际执行的任务也无法预测。为了方便调试、性能分析和小规模测试，<code>Google</code> 实现的 <code>MapReduce</code> 框架也提供了一个串行执行的版本，能在单台机器上串行执行所有任务。同时，用户也可通过参数控制一次 <code>MapReduce</code> 任务只执行些特定的 <code>map</code> 任务。通过在启动程序时指定调试参数，用户就可轻松的使用调试或测试工具（如 <code>gdb</code>）对编写的程序进行调试和测试。</p><h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>主节点内部同时运行了一个 <code>HTTP</code> 服务，用于提供给用户查看一系列状态信息。状态信息页面展示了当前任务的进度，例如有多少个任务已经完成，有多少个任务正在进行中，输入数据的大小，中间结果数据的大小，最终结果数据的大小，任务处理百分比等。同时，状态页面也提供了每个任务执行产生的标准错误输出和标准输出文件。用户可根据这些信息来预测任务需要多久才能完成，以及是否需要添加更多的计算资源。状态页面也可用于判断当前任务执行耗时是否比预期的长。</p><p>此外，状态页面也显示了失败的工作节点，以及这些失败的工作节点对应的 <code>map</code> 或 <code>reduce</code> 任务。这有助于用户排查编写的代码中是否有 <code>bug</code>。</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p><code>MapReduce</code> 框架内部提供了一个计数器用于统计各个事件发生的次数。例如，用户可能希望统计一次任务中一共处理了多少个单词，或者有多少个德语文档建立了索引。</p><p>如果要开启这个功能，用户需要编写一个命名计数器，然后在 <code>map</code> 或 <code>reduce</code> 函数中在需要的时候对计数器自增，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase &#x3D; GetCounter(&quot;uppercase);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">    for each word w in contents:</span><br><span class="line">        if (IsCapitalized(w)):</span><br><span class="line">            uppsercase-&gt;Increment();</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br></pre></td></tr></table></figure><p>每个工作节点上的计数器的值会周期性的发送给主节点（如前文所述，主节点会周期性的对工作节点进行心跳探测，工作节点会在响应结果中带上计数器的值）。主节点会对执行成功的 <code>map</code> 和 <code>reduce</code> 任务返回的计数器聚合，当整个 <code>MapReduce</code> 任务完成将控制权交还给用户代码时，用户代码可获取到创建的计数器的值。当前的计数器的值也同样会展示在状态页面，用户也可根据此信息来观测整个任务的进展。在对计数器聚合时，和主节点会忽略已完成的某个任务的重复通知一样，主节点同样会忽略某个来自已完成任务的计数器更新，从而避免重复计数（任务的重复执行主要有两种情况，一种是由于网络不连通，导致主节点重新分配某个 <code>map</code> 或 <code>reduce</code> 任务到新的工作节点上；另一种是触发了后备任务，主节点主动分发同一个 <code>map</code> 或 <code>reduce</code> 任务给多个工作节点执行）。</p><p><code>MapRecue</code> 框架本身也维护了一些计数器，例如已处理的输入数据键值对的数量，以及已生成的最终数据键值对的数量。</p><p>用户能很方便的通过计数器来检查 <code>MapReduce</code> 任务的行为。例如，在任务执行时用户可通过计数器来确保输出的键值对数量是否等于输入的键值对数量，或者已处理的德语文档的数量在全部已处理的文档数量中的占比是否符合预期。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>这一节主要描述 <code>MapReduce</code> 在 <code>Google</code> 内部环境下运行的性能情况，这里不再赘述。简单举例来说，在1800台机器上执行一个 <code>10T</code> 数据量的分布式 <code>grep</code> 搜索耗时约150秒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，来自 <code>Google</code> 的总结：</p><ol><li>限制性的编程模型使得计算并行化变得容易，以及有着较好的容错性，这也体现了计算机领域的一个重要思想：抽象</li><li>对于大型系统来说，网络 <code>IO</code> 容易成为瓶颈</li><li>冗余执行可以作为有效降低成为性能短板的机器带来的影响的手段，另外冗余也是应对机器异常、数据丢失的方式</li></ol><p>参考：</p><ul><li><a href="https://research.google/pubs/pub62/">MapReduce: Simplified Data Processing on Large Clusters</a></li><li><a href="https://en.wikipedia.org/wiki/Bisection_bandwidth">Bisection bandwidth</a></li><li><a href="https://networkengineering.stackexchange.com/questions/28894/understanding-bisection-bandwidth">Understanding bisection bandwidth</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;MapReduce: Simplified Data Processing on Large Clusters&lt;/code&gt; 是</summary>
      
    
    
    
    
    <category term="Paper" scheme="https://frederick-s.github.io/tags/Paper/"/>
    
    <category term="MIT 6.824" scheme="https://frederick-s.github.io/tags/MIT-6-824/"/>
    
    <category term="MapReduce" scheme="https://frederick-s.github.io/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的插入</title>
    <link href="https://frederick-s.github.io/2022/02/07/add-node-in-binary-search-tree/"/>
    <id>https://frederick-s.github.io/2022/02/07/add-node-in-binary-search-tree/</id>
    <published>2022-02-06T16:00:00.000Z</published>
    <updated>2022-02-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>往一个二叉搜索树中插入一个节点后的结果并不唯一，例如对于下面的二叉搜索树：</p><p><img src="/images/bst-add-1.png" alt="alt"></p><p>如果要插入节点2，可以将2作为3的左子节点：</p><p><img src="/images/bst-add-2.png" alt="alt"></p><p>或者将2作为1的右子节点：</p><p><img src="/images/bst-add-3.png" alt="alt"></p><p>对于第一种方法，类似于往单链表的中间插入节点，既要更新前继节点的 <code>next</code> 指针，又要将新的节点的 <code>next</code> 指针指向下一个节点；而对于第二种方法，只需要将新节点挂载到目标节点的左子节点或右子节点即可，实现上较为简洁，可分为非递归和递归两种解法。</p><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>整体算法分为两步：</p><ol><li>找到要挂载的叶子节点</li><li>将新节点挂载到该叶子节点的左子节点或右子节点上</li></ol><p>第一步等同于二叉搜索树的查找，从根节点开始，将目标值和当前节点的值进行比较，如果当前节点的值比目标值小，说明要找的节点在右子树中，移动到右子节点中查找；如果当前节点的值比目标值大，说明要找的节点在左子树中，移动到左子节点中查找。</p><p>找到目标叶子节点后，比较该叶子节点的值和目标值的大小，来决定新节点是作为左子节点还是右子节点插入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">        prev, current = <span class="literal">None</span>, root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            prev = current</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current.val &lt; val:</span><br><span class="line">                current = current.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prev.val &gt; val:</span><br><span class="line">            prev.left = TreeNode(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev.right = TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一般的二叉树问题的递归解法遵循如下的模式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="comment"># 处理终止条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 一种情况是左右子树只处理一边</span></span><br><span class="line">    <span class="keyword">if</span> some condition:</span><br><span class="line">        dfs(root.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 另一种情况是左右子树都处理</span></span><br><span class="line">    dfs(root.left)</span><br><span class="line">    dfs(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure><p>在当前的问题下，终止条件发生的条件为找到了目标叶子节点，此时需要新建一个节点；而对于递归的处理，这里适用于第一种情况，即左右子树只处理一边，判断条件为比较当前节点的值和目标值的大小，所以可以粗略的构造出程序的框架：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        create new node <span class="keyword">with</span> val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">        dfs(root.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure><p>下一个问题是，这个递归函数的返回值是什么？从终止条件的处理可以看到递归函数返回的是某个节点，联想到往一个二叉搜索树中插入一个节点后需要返回一个新的树，所以这里递归函数的返回值应该是根节点。</p><p>然而还缺少一步，就是新节点的挂载，目前新节点返回后并没有任何节点引用它，需要在终止条件的上层调用中处理，即每次递归调用时都重新赋值左子树或右子树的根节点：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;往一个二叉搜索树中插入一个节点后的结果并不唯一，例如对于下面的二叉搜索树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/bst-add-1.png&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要插入节点2，可以将2作为3的左子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="https://frederick-s.github.io/tags/Data-Structure/"/>
    
    <category term="Algorithm" scheme="https://frederick-s.github.io/tags/Algorithm/"/>
    
    <category term="Binary Search Tree" scheme="https://frederick-s.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>二叉树非递归遍历</title>
    <link href="https://frederick-s.github.io/2022/02/02/binary-tree-traverse-with-stack/"/>
    <id>https://frederick-s.github.io/2022/02/02/binary-tree-traverse-with-stack/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-02-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的遍历直观的解法是使用递归求解，不过同样也可使用非递归方式求解。</p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>先来看前序遍历的递归求解：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        values = []</span><br><span class="line"></span><br><span class="line">        self._preorder_traversal(root, values)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_preorder_traversal</span>(<span class="params">self, root: TreeNode, values: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        values.append(root.val)</span><br><span class="line"></span><br><span class="line">        self._preorder_traversal(root.left, values)</span><br><span class="line">        self._preorder_traversal(root.right, values)</span><br></pre></td></tr></table></figure><p>对于如下的二叉树：</p><p><img src="/images/binary-tree.jpg" alt="alt"></p><p>其调用链为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_preorder_traversal(1)</span><br><span class="line">    _preorder_traversal(2)</span><br><span class="line">        _preorder_traversal(4)</span><br><span class="line">        _preorder_traversal(5)</span><br><span class="line">    _preorder_traversal(3)</span><br></pre></td></tr></table></figure><p>可以看到越深的节点对应的函数调用越先返回，对应先进后出的模型，即栈，所以递归转非递归可借助栈实现。</p><p>由于前序遍历是先访问根节点，所以对于每个子树，可以先将根节点入栈，然后依次弹出栈顶的节点，从而实现先访问根节点，然后将左右子树的根节点入栈，由于左子树需要先于右子树被访问，所以右子树的根节点要先入栈，然后再入栈左子树的根节点：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        values = []</span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current = stack.pop()</span><br><span class="line">            values.append(current.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current.right:</span><br><span class="line">                stack.append(current.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current.left:</span><br><span class="line">                stack.append(current.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>在递归的方案下，前序遍历改为中序遍历只需改变 <code>values.append(root.val)</code> 的执行位置即可，而在非递归方案下，并不能通过直接改变 <code>values.append(current.val)</code> 的执行位置来实现，因为不管放到哪个位置，都会提前访问到根节点。</p><p>中序遍历下，最左下方的节点是最先被访问的，沿着左子树的根节点这条线，等同于一个单链表的倒序访问，单链表的倒序如果用栈来实现则是将单链表的所有节点从链表头开始遍历依次放入栈，然后再依次出栈，类似的，只要当前节点存在左子树，则持续将左子树的根节点压入栈，这样下次出栈时，就会先访问最左下方的节点。当某个节点出栈时，由于上述的操作，它必然是某个子树的最左下方的节点，此时需要转到该节点的右子树重复上述流程从而访问右子树的全部节点：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        values = []</span><br><span class="line">        stack = []</span><br><span class="line">        current = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            current = stack.pop()</span><br><span class="line">            values.append(current.val)</span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><p>虽然前序遍历的非递归方案不适用于中序遍历，不过中序遍历的递归方案可略微修改适用于前序遍历，只需将 <code>values.append(current.val)</code> 放在不断入栈左子树的循环中即可：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        values = []</span><br><span class="line">        stack = []</span><br><span class="line">        current = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                values.append(current.val)</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            current = stack.pop()</span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历和中序遍历相同，最先访问的都是最左下方的节点，所以对左子树不断入栈这段逻辑不变，不同的是当出栈时，当前出栈的节点有可能存在右子树，而右子树还还没有被访问，所以当前节点还不能出栈。因此，需要先判断栈顶的节点是否存在右子树，以及右子树是否被访问过，如果存在右子树且未被访问则转向右子树重复上述流程，否则可弹出栈顶节点。而判断栈顶的右子树是否被访问可通过比较栈顶的右子树和上一个被访问的节点来实现，如果两者相等，说明栈顶的右子树刚被访问过，否则未被访问过：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        current = root</span><br><span class="line">        stack = []</span><br><span class="line">        values = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            top = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> top.right <span class="keyword">and</span> prev != top.right:</span><br><span class="line">                current = top.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = stack.pop()</span><br><span class="line">                values.append(current.val)</span><br><span class="line">                prev = current</span><br><span class="line">                current = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h2 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h2><p>上述各非递归方案各不相同，是否存在和递归方案类似的通用模板方案？<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/1736072/Java-This-simple-template-can-be-used-for-3-traversals">这里</a> 给出了一种通用方案，首先需要额外引入一个数据结构来标记节点是否被访问过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> visited;</span><br><span class="line">    TreeNode node;</span><br><span class="line"></span><br><span class="line">    Pair(TreeNode node, <span class="keyword">boolean</span> visited) &#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.visited = visited;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Python</code> 中，可简单通过元组来实现，对应模板代码为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xxxTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack = [(root, <span class="literal">False</span>)]</span><br><span class="line">        values = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current, visited = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                values.append(current.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 在这里处理左子树，右子树，根节点的入栈顺序</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><p>对于三种遍历方式，上述模板方法仅在处理左子树，右子树，根节点的入栈顺序上不同，实际入栈顺序和遍历顺序相反：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="keyword">if</span> current.right:</span><br><span class="line">    stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.left:</span><br><span class="line">    stack.append((current.left, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">stack.append((current, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="keyword">if</span> current.right:</span><br><span class="line">    stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">stack.append((current, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.left:</span><br><span class="line">    stack.append((current.left, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line">stack.append((current, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.right:</span><br><span class="line">    stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.left:</span><br><span class="line">    stack.append((current.left, <span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p>从出栈的角度来说，上述方法和理论遍历顺序并不一致，每个节点会入栈两次，第二次入栈时才会设置 <code>visited</code> 为 <code>True</code>，但从 <code>visited</code> 的角度来说顺序是和理论遍历顺序一致的。</p><p>参考：</p><ul><li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/1736072/Java-This-simple-template-can-be-used-for-3-traversals">[Java] This simple template can be used for 3 traversals</a></li><li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45551/Preorder-Inorder-and-Postorder-Iteratively-Summarization">Preorder, Inorder, and Postorder Iteratively Summarization</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉树的遍历直观的解法是使用递归求解，不过同样也可使用非递归方式求解。&lt;/p&gt;
&lt;h2 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h2&gt;&lt;p&gt;先来看前序遍历的递归求解：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="https://frederick-s.github.io/tags/Data-Structure/"/>
    
    <category term="Algorithm" scheme="https://frederick-s.github.io/tags/Algorithm/"/>
    
    <category term="Binary Tree" scheme="https://frederick-s.github.io/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 自动构建和推送 Docker 镜像到 Docker Hub</title>
    <link href="https://frederick-s.github.io/2021/12/26/build-and-push-docker-image-to-docker-hub-with-github-actions/"/>
    <id>https://frederick-s.github.io/2021/12/26/build-and-push-docker-image-to-docker-hub-with-github-actions/</id>
    <published>2021-12-25T16:00:00.000Z</published>
    <updated>2021-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker Hub</code> 的免费账户已不再支持关联 <code>GitHub</code> 仓库并自动构建镜像的功能，不过可以通过 <code>GitHub Actions</code> 来自动构建和推送镜像。实现方式非常简单，<code>Docker</code> 官方已给出了示例（<a href="https://github.com/marketplace/actions/build-and-push-docker-images">Build and push Docker images</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">name: ci</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - &#39;master&#39;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  docker:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      -</span><br><span class="line">        name: Set up QEMU</span><br><span class="line">        uses: docker&#x2F;setup-qemu-action@v1</span><br><span class="line">      -</span><br><span class="line">        name: Set up Docker Buildx</span><br><span class="line">        uses: docker&#x2F;setup-buildx-action@v1</span><br><span class="line">      -</span><br><span class="line">        name: Login to DockerHub</span><br><span class="line">        uses: docker&#x2F;login-action@v1 </span><br><span class="line">        with:</span><br><span class="line">          username: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;</span><br><span class="line">          password: $&#123;&#123; secrets.DOCKERHUB_TOKEN &#125;&#125;</span><br><span class="line">      -</span><br><span class="line">        name: Build and push</span><br><span class="line">        id: docker_build</span><br><span class="line">        uses: docker&#x2F;build-push-action@v2</span><br><span class="line">        with:</span><br><span class="line">          push: true</span><br><span class="line">          tags: user&#x2F;app:latest</span><br></pre></td></tr></table></figure><p>一共有三处要注意，第一开头的 <code>branches</code> 下对于新建的仓库需要填写 <code>main</code> 而不是 <code>master</code>。</p><p>第二需要为 <code>Login to DockerHub</code> 阶段设置 <code>Docker</code> 的 <code>Access Token</code>，<code>Access Token</code> 可以通过 <code>Docker Hub</code> 的 <code>Account Settings -&gt; Security -&gt; New Access Token</code> 创建，然后通过 <code>GitHub</code> 仓库的 <code>Settings -&gt; Secrets -&gt; New repository secret</code> 分别创建 <code>DOCKERHUB_USERNAME</code> 和 <code>DOCKERHUB_TOKEN</code>。</p><p>第三最后的 <code>tags: user/app:latest</code> 中的 <code>user</code> 和 <code>app</code> 需要修改为实际的用户名和镜像名。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/61989951/github-action-workflow-not-running">GitHub Action workflow not running</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Docker Hub&lt;/code&gt; 的免费账户已不再支持关联 &lt;code&gt;GitHub&lt;/code&gt; 仓库并自动构建镜像的功能，不过可以通过 &lt;code&gt;GitHub Actions&lt;/code&gt; 来自动构建和推送镜像。实现方式非常简单，&lt;code&gt;Docker</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://frederick-s.github.io/tags/Docker/"/>
    
    <category term="GitHub Actions" scheme="https://frederick-s.github.io/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>Commodity Hardware</title>
    <link href="https://frederick-s.github.io/2021/12/23/commodity-hardware/"/>
    <id>https://frederick-s.github.io/2021/12/23/commodity-hardware/</id>
    <published>2021-12-22T16:00:00.000Z</published>
    <updated>2021-12-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Commodity Hardware</code> 指较为廉价的硬件设备，它具有如下特点：</p><ol><li>价格相对低廉</li><li>易采购</li><li>和同类型的硬件可相互替换</li></ol><p>由此相关的一个概念叫 <code>commodity computing</code>，即使用大量的廉价硬件来实现低成本、高性能的并行计算，与之相对的则是使用较少数高成本的超级计算机。</p><p>参考：</p><ul><li><a href="https://www.suse.com/suse-defines/definition/commodity-hardware/">Commodity Hardware</a></li><li><a href="https://en.wikipedia.org/wiki/Commodity_computing">Commodity computing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Commodity Hardware&lt;/code&gt; 指较为廉价的硬件设备，它具有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;价格相对低廉&lt;/li&gt;
&lt;li&gt;易采购&lt;/li&gt;
&lt;li&gt;和同类型的硬件可相互替换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此相关的一个概念叫 &lt;code</summary>
      
    
    
    
    
    <category term="English" scheme="https://frederick-s.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>迁移业余项目数据到 Azure MySQL</title>
    <link href="https://frederick-s.github.io/2021/12/19/how-to-import-data-to-azure-mysql/"/>
    <id>https://frederick-s.github.io/2021/12/19/how-to-import-data-to-azure-mysql/</id>
    <published>2021-12-18T16:00:00.000Z</published>
    <updated>2021-12-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建了 <code>Azure MySQL</code> 实例后（这里使用的是 <code>Flexible Server</code>），首先导出原始数据库的数据，因为用的是 <code>Docker</code> 所以通过以下方式导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec $&#123;container_id&#125; &#x2F;usr&#x2F;bin&#x2F;mysqldump -u $&#123;user_name&#125; --password&#x3D;$&#123;password&#125; $&#123;database_name&#125; &gt; backup.sql</span><br></pre></td></tr></table></figure><p>然后通过 <code>Azure CLI</code> 创建一个新的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az mysql flexible-server db create --resource-group $&#123;resource_group&#125; --server-name $&#123;server_name&#125; --database-name $&#123;database_name&#125;</span><br></pre></td></tr></table></figure><p>最后通过 <code>Azure CLI</code> 导入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az mysql flexible-server execute -n $&#123;server_name&#125; -u $&#123;user_name&#125; -p $&#123;password&#125; -d $&#123;database_name&#125; -f $&#123;path_to_backup_sql_file&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/Azure-samples/mysql-database-samples">Sample Databases for Azure Database for MySQL flexible server</a></li><li><a href="https://docs.microsoft.com/en-us/cli/azure/mysql/flexible-server?view=azure-cli-latest">az mysql flexible-server</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建了 &lt;code&gt;Azure MySQL&lt;/code&gt; 实例后（这里使用的是 &lt;code&gt;Flexible Server&lt;/code&gt;），首先导出原始数据库的数据，因为用的是 &lt;code&gt;Docker&lt;/code&gt; 所以通过以下方式导出：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    
    <category term="Azure" scheme="https://frederick-s.github.io/tags/Azure/"/>
    
    <category term="MySQL" scheme="https://frederick-s.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>为什么 Java 方法重载不允许仅返回值类型不同</title>
    <link href="https://frederick-s.github.io/2021/11/28/java-function-overload-return-different-type-only/"/>
    <id>https://frederick-s.github.io/2021/11/28/java-function-overload-return-different-type-only/</id>
    <published>2021-11-27T16:00:00.000Z</published>
    <updated>2021-11-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Java</code> 中，如果两个同名方法仅返回值类型不同，这是不允许的，即编译器不会认为这是方法重载，如下述类中的方法 <code>f</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会提示 <code>&#39;f()&#39; is already defined in &#39;Demo&#39;</code>。假设编译器支持这种方式的方法重载，会有什么问题？在某些情况下，编译器无法区分调用的是哪个方法，例如当调用 <code>f()</code> 却忽略返回值时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br></pre></td></tr></table></figure><p>所以仅返回值类型不同不能作为方法重载的形式。</p><p>参考：</p><ul><li>Thinking in Java</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中，如果两个同名方法仅返回值类型不同，这是不允许的，即编译器不会认为这是方法重载，如下述类中的方法 &lt;code&gt;f&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="Java" scheme="https://frederick-s.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python for/while else</title>
    <link href="https://frederick-s.github.io/2021/08/08/python-for-while-else/"/>
    <id>https://frederick-s.github.io/2021/08/08/python-for-while-else/</id>
    <published>2021-08-07T16:00:00.000Z</published>
    <updated>2021-08-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>和常见的语言不同，<code>Python</code> 的 <code>for/while</code> 可以配合 <code>else</code> 使用。简单来说，当 <code>for/while</code> 循环体中没有执行 <code>break</code> 时，就会执行 <code>else</code> 中的代码。假设需要判断数组中是否存在某个数，如果不存在的话则抛出异常，一种可能的写法是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="number">10</span></span><br><span class="line">found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i == target:</span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;not found&#x27;</span>)</span><br></pre></td></tr></table></figure><p>借助 <code>for/while else</code> 可改写成：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i == target:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;not found&#x27;</span>)</span><br></pre></td></tr></table></figure><p>虽然代码少了几行，但是对于不熟悉该语法特性的人来说可能无法一眼看穿代码的意图。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/9979970/why-does-python-use-else-after-for-and-while-loops">Why does python use ‘else’ after for and while loops?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和常见的语言不同，&lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;for/while&lt;/code&gt; 可以配合 &lt;code&gt;else&lt;/code&gt; 使用。简单来说，当 &lt;code&gt;for/while&lt;/code&gt; 循环体中没有执行 &lt;code&gt;break&lt;/code&gt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://frederick-s.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python heapq 自定义比较器</title>
    <link href="https://frederick-s.github.io/2021/07/31/python-heapq-custom-comparator/"/>
    <id>https://frederick-s.github.io/2021/07/31/python-heapq-custom-comparator/</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2021-07-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>Python</code> 的 <code>heapq</code> 模块时，如果处理的是较为复杂的数据结构，则需要实现自定义比较器来比较两个元素的大小。</p><h2 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h2><p>如果 <code>heapq</code> 中放入的是元组，那么元组的第一个元素会用于大小比较。假设有这样一个问题，给定一个数组，返回前 <code>k</code> 小的数字所在数组中的位置。<code>Top k</code> 的问题的一个解法是使用堆，但是这里要求的是数字在数组中的位置而不是数字本身，所以不能直接将数组堆化，可以先将数组中的每个数字转换成一个包含2个元素的元组，元组的第一个元素是数字本身，第二个元素则是数字在数组中的位置。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k</span>(<span class="params">numbers, k</span>):</span></span><br><span class="line">  heap = [(n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers)]</span><br><span class="line">  heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: heapq.heappop(heap)[<span class="number">1</span>], <span class="built_in">range</span>(k)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  print(top_k([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], <span class="number">3</span>)) <span class="comment"># [4, 3, 2]</span></span><br></pre></td></tr></table></figure><h2 id="实现自定义比较器"><a href="#实现自定义比较器" class="headerlink" title="实现自定义比较器"></a>实现自定义比较器</h2><p>当放入堆中的是自定义类时，可以通过实现 <code>__lt__</code> 方法来比较元素大小。假设有一个自定义类为 <code>Node</code>，它包含一个 <code>value</code> 属性，现在问题改为给定一个 <code>Node</code> 的数组，返回前 <code>k</code> 小的 <code>Node</code> 的值，可通过实现 <code>__lt__</code> 方法求解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">    self.value = value</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k</span>(<span class="params">nodes, k</span>):</span></span><br><span class="line">  heap = [node <span class="keyword">for</span> node <span class="keyword">in</span> nodes]</span><br><span class="line">  heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: heapq.heappop(heap).value, <span class="built_in">range</span>(k)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  print(top_k([Node(<span class="number">5</span>), Node(<span class="number">4</span>), Node(<span class="number">3</span>), Node(<span class="number">2</span>), Node(<span class="number">1</span>)], <span class="number">3</span>)) <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/8875706/heapq-with-custom-compare-predicate/8875823">heapq with custom compare predicate</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;heapq&lt;/code&gt; 模块时，如果处理的是较为复杂的数据结构，则需要实现自定义比较器来比较两个元素的大小。&lt;/p&gt;
&lt;h2 id=&quot;使用元组&quot;&gt;&lt;a href=&quot;#使用元组&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="Python" scheme="https://frederick-s.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 磁盘占用清理</title>
    <link href="https://frederick-s.github.io/2021/07/11/clean-up-docker/"/>
    <id>https://frederick-s.github.io/2021/07/11/clean-up-docker/</id>
    <published>2021-07-10T16:00:00.000Z</published>
    <updated>2021-07-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>日常随着 <code>Docker</code> 的使用，<code>Docker</code> 会逐渐占用磁盘空间，通过 <code>docker system df</code> 可查看 <code>Docker</code> 所占用的空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          20        14        22.21GB   17.07GB (76%)</span><br><span class="line">Containers      29        0         6.743GB   6.743GB (100%)</span><br><span class="line">Local Volumes   2         0         417MB     417MB (100%)</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure><p>其中 <code>Images</code> 表示镜像，<code>Containers</code> 表示容器，<code>Local Volumes</code> 表示本地卷，<code>Build Cache</code> 表示构建缓存。</p><h2 id="整体清理"><a href="#整体清理" class="headerlink" title="整体清理"></a>整体清理</h2><p>可以通过 <code>docker system prune</code> 进行一次空间清理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING! This will remove:</span><br><span class="line">  - all stopped containers</span><br><span class="line">  - all networks not used by at least one container</span><br><span class="line">  - all dangling images</span><br><span class="line">  - all dangling build cache</span><br><span class="line"></span><br><span class="line">Are you sure you want to continue? [y&#x2F;N]</span><br></pre></td></tr></table></figure><p>该操作会删除所有停止的容器，所有未被至少一个容器使用的网络，所有的 <code>dangling</code> 镜像（在构建镜像时产生的 <code>tag</code> 为 <code>none</code> 的镜像，没有和任何其他有 <code>tag</code> 的镜像有关联），所有的 <code>dangling</code> 构建缓存（和 <code>dangling</code> 镜像同理）。</p><p>更激进一点，还可以执行 <code>docker system prune -a</code>，该操作还会删除没有和运行中的容器有关联的镜像。</p><h2 id="镜像清理"><a href="#镜像清理" class="headerlink" title="镜像清理"></a>镜像清理</h2><p><code>Docker</code> 镜像是某个应用（如数据库、某个程序语言的运行时）的磁盘快照，可以通过 <code>docker image ls -a</code> 查看所有的镜像（活跃的以及 <code>dangling</code> 的镜像）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   4 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>可以通过 <code>docker image rm &lt;name_or_id&gt;</code> 来删除某个镜像，支持批量删除多个镜像，多个镜像 <code>id</code> 之间使用空格分隔即可。不过，删除镜像要求该镜像没有被某个容器所使用，否则会提示下述类似错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: conflict: unable to delete 4cdc5dd7eaad (must be forced) - image is being used by stopped container 3d9f62acc483</span><br><span class="line">Error response from daemon: conflict: unable to delete d1165f221234 (must be forced) - image is being used by stopped container 57027ba35bdd</span><br></pre></td></tr></table></figure><p>可以通过在执行时增加 <code>-f</code> 来强制删除镜像。</p><h2 id="容器清理"><a href="#容器清理" class="headerlink" title="容器清理"></a>容器清理</h2><p>容器是某个镜像的一个运行实例，可以通过 <code>docker container ls -a</code> 查看所有的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">3d9f62acc483   4cdc5dd7eaad   &quot;&#x2F;docker-entrypoint.…&quot;   11 minutes ago   Exited (0) 11 minutes ago             sleepy_babbage</span><br></pre></td></tr></table></figure><p>要删除一个容器必须要先停止该容器（<code>docker container stop &lt;name_or_id&gt;</code>），然后通过 <code>docker container rm &lt;name_or_id&gt;</code> 删除，同样的，和删除镜像类似，该命令支持批量删除多个容器，多个容器 <code>id</code> 之间使用空格分隔。</p><h2 id="网络清理"><a href="#网络清理" class="headerlink" title="网络清理"></a>网络清理</h2><p><code>Docker</code> 网络用于容器间的通信，它们都是一些配置文件，并不会占用多大空间，可以通过 <code>docker network ls</code> 查看所有的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">b96312481a51   bridge    bridge    local</span><br><span class="line">85a64f881d4d   host      host      local</span><br><span class="line">e6808b80f888   none      null      local</span><br></pre></td></tr></table></figure><p>可以通过 <code>docker network rm &lt;name_or_id&gt;</code> 来删除一个网络。</p><h2 id="数据卷清理"><a href="#数据卷清理" class="headerlink" title="数据卷清理"></a>数据卷清理</h2><p><code>Docker</code> 数据卷用于持久化容器运行时保存的数据，例如通过 <code>Docker</code> 运行 <code>MySQL</code> 时指定数据卷，从而对 <code>MySQL</code> 的数据进行备份，可以通过 <code>docker volume ls</code> 查看所有的数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     test-volume</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker volume rm &lt;name&gt;</code> 来删除指定的数据卷，或者使用 <code>docker volume prune</code> 来删除所有未和运行中的容器关联的数据卷，以及通过 <code>docker volume prune -a</code> 删除所有的数据卷。</p><p>最后，<code>docker system prune -a --volumes</code> 是在 <code>docker system prune -a</code> 的基础上删除所有未使用的卷。</p><p>参考：</p><ul><li><a href="https://dockerwebdev.com/tutorials/clean-up-docker/">How to clean your Docker data</a></li><li><a href="https://jinnabalu.medium.com/docker-frequently-used-commands-on-images-b812d76a4b8e">Dangling or Unused Images in Docker</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常随着 &lt;code&gt;Docker&lt;/code&gt; 的使用，&lt;code&gt;Docker&lt;/code&gt; 会逐渐占用磁盘空间，通过 &lt;code&gt;docker system df&lt;/code&gt; 可查看 &lt;code&gt;Docker&lt;/code&gt; 所占用的空间：&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://frederick-s.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Permissions 0644 for &#39;xxx.pem&#39; are too open</title>
    <link href="https://frederick-s.github.io/2021/07/10/permissions-0644-for-xx-are-too-open/"/>
    <id>https://frederick-s.github.io/2021/07/10/permissions-0644-for-xx-are-too-open/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2021-07-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>SSH</code> 连接到 <code>Azure</code> 的虚拟机时遇到错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ssh -i &#x2F;path&#x2F;to&#x2F;some.pem xxx@x.x.x.x</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions 0644 for &#39;&#x2F;path&#x2F;to&#x2F;some.pem&#39; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;&#x2F;path&#x2F;to&#x2F;some.pem&quot;: bad permissions</span><br><span class="line">xxx@x.x.x.x: Permission denied (publickey).</span><br></pre></td></tr></table></figure><p>这是因为创建虚拟机时从 <code>Azure</code> 下载的私钥默认权限太大，需要将其权限改为只读且仅当前用户可见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 some.pem</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/8193768/trying-to-ssh-into-an-amazon-ec2-instance-permission-error">Trying to SSH into an Amazon Ec2 instance - permission error</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;SSH&lt;/code&gt; 连接到 &lt;code&gt;Azure&lt;/code&gt; 的虚拟机时遇到错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="SSH" scheme="https://frederick-s.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>为什么1不是质数</title>
    <link href="https://frederick-s.github.io/2021/07/04/why-is-1-not-a-prime/"/>
    <id>https://frederick-s.github.io/2021/07/04/why-is-1-not-a-prime/</id>
    <published>2021-07-03T16:00:00.000Z</published>
    <updated>2021-07-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个数除了1和它本身外，没有其他约数，我们称这个数为质数，但在这个定义下，1却不是质数。要回答这个问题需要先了解质数的作用，质数的主要作用在于构建欧几里得的算数基本定理：</p><blockquote><p>任何一个大于1的自然数都可以唯一分解成有限个质数的乘积。</p></blockquote><p>如果把1列为质数，就会破坏这种唯一性，因为在这种情况下每个自然数都有无限种分解方式，即在原有分解的基础上再乘以任意个数的1，所以1不作为质数。</p><p>参考：</p><ul><li><a href="https://math.stackexchange.com/questions/120/why-is-1-not-a-prime-number">Why is 1 not a prime number?</a></li><li><a href="https://primes.utm.edu/notes/faq/one.html">FAQ: Why is the number one not prime?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果一个数除了1和它本身外，没有其他约数，我们称这个数为质数，但在这个定义下，1却不是质数。要回答这个问题需要先了解质数的作用，质数的主要作用在于构建欧几里得的算数基本定理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何一个大于1的自然数都可以唯一分解成有限个质数的乘积。&lt;</summary>
      
    
    
    
    
    <category term="Math" scheme="https://frederick-s.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>如何在 JDK 11 中建立 jstatd 连接</title>
    <link href="https://frederick-s.github.io/2020/11/21/how-to-use-jstatd-with-jdk11/"/>
    <id>https://frederick-s.github.io/2020/11/21/how-to-use-jstatd-with-jdk11/</id>
    <published>2020-11-20T16:00:00.000Z</published>
    <updated>2020-11-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>VisualVM</code> 的 <code>Virsual GC</code> 插件需要先和服务器建立 <code>jstatd</code> 连接，在 <code>JDK 9</code> 之前需要首先创建一个 <code>policy</code> 文件并声明权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant codebase &quot;file:$&#123;java.home&#125;&#x2F;lib&#x2F;tools.jar&quot; &#123;</span><br><span class="line">   permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，从 <code>JDK 9</code> 开始，<code>tools.jar</code> 已被移除，需要将 <code>policy</code> 文件的内容修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grant codebase &quot;jrt:&#x2F;jdk.jstatd&quot; &#123;    </span><br><span class="line">   permission java.security.AllPermission;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">grant codebase &quot;jrt:&#x2F;jdk.internal.jvmstat&quot; &#123;    </span><br><span class="line">   permission java.security.AllPermission;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/51032095/starting-jstatd-in-java-9">Starting jstatd in Java 9+</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;VisualVM&lt;/code&gt; 的 &lt;code&gt;Virsual GC&lt;/code&gt; 插件需要先和服务器建立 &lt;code&gt;jstatd&lt;/code&gt; 连接，在 &lt;code&gt;JDK 9&lt;/code&gt; 之前需要首先创建一个 &lt;code&gt;policy&lt;/code&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://frederick-s.github.io/tags/Java/"/>
    
    <category term="VisualVM" scheme="https://frederick-s.github.io/tags/VisualVM/"/>
    
  </entry>
  
  <entry>
    <title>如何修改 AppVeyor 的 JDK 版本</title>
    <link href="https://frederick-s.github.io/2020/10/24/how-to-change-jdk-version-in-appveyor/"/>
    <id>https://frederick-s.github.io/2020/10/24/how-to-change-jdk-version-in-appveyor/</id>
    <published>2020-10-23T16:00:00.000Z</published>
    <updated>2020-10-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>AppVeyor</code> 的<code>Visual Studio 2019</code> 镜像构建 <code>Java</code> 项目时默认使用的是 <code>JDK 1.8</code>（<a href="https://www.appveyor.com/docs/windows-images-software/#java">这里</a>说明了 <code>AppVeyor</code> 各个镜像下默认使用的 <code>JDK</code> 版本，虽然表格里写着 <code>Visual Studio 2019</code> 镜像下的默认 <code>JDK</code> 是1.7，不过实际是1.8），如果想更换 <code>JDK</code> 版本，比如更换为 <code>JDK 11</code>，可以重新设置 <code>JAVA_HOME</code> 和 <code>PATH</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before_test:</span><br><span class="line">  - SET JAVA_HOME&#x3D;C:\Program Files\Java\jdk11</span><br><span class="line">  - SET PATH&#x3D;%JAVA_HOME%\bin;%PATH%</span><br></pre></td></tr></table></figure><p>完整的代码可参考 <a href="https://github.com/Frederick-S/appveyor-jdk11-demo">GitHub</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;AppVeyor&lt;/code&gt; 的&lt;code&gt;Visual Studio 2019&lt;/code&gt; 镜像构建 &lt;code&gt;Java&lt;/code&gt; 项目时默认使用的是 &lt;code&gt;JDK 1.8&lt;/code&gt;（&lt;a href=&quot;https://www.appv</summary>
      
    
    
    
    
    <category term="Java" scheme="https://frederick-s.github.io/tags/Java/"/>
    
    <category term="AppVeyor" scheme="https://frederick-s.github.io/tags/AppVeyor/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 JUnit 测试异常信息</title>
    <link href="https://frederick-s.github.io/2020/09/26/how-to-test-exception-message-with-junit/"/>
    <id>https://frederick-s.github.io/2020/09/26/how-to-test-exception-message-with-junit/</id>
    <published>2020-09-25T16:00:00.000Z</published>
    <updated>2020-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设有如下的 <code>SumService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;a must be positive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;b must be positive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>a</code> 或者 <code>b</code> 非正数时会抛出 <code>IllegalArgumentException</code> 异常，由于两者抛出的是同一个异常，所以无法直接使用 <code>expected = IllegalArgumentException.class</code> 进行区分测试，故需要测试具体的异常信息。</p><h2 id="使用-try-catch"><a href="#使用-try-catch" class="headerlink" title="使用 try/catch"></a>使用 try/catch</h2><p>用一个 <code>try/catch</code> 包裹测试的方法，判断抛出的异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldAssertExceptionMessageByAssertThrows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IllegalArgumentException illegalArgumentException = </span><br><span class="line">            Assert.assertThrows(IllegalArgumentException.class, () -&gt; SumService.sum(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;a must be positive&quot;</span>, illegalArgumentException.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-assertThrows"><a href="#使用-assertThrows" class="headerlink" title="使用 assertThrows"></a>使用 assertThrows</h2><p>借助 <code>Assert.assertThrows</code> 执行测试方法返回一个异常，然后判断返回的异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldAssertExceptionMessageByAssertThrows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IllegalArgumentException illegalArgumentException = Assert.assertThrows(IllegalArgumentException.class, () -&gt; SumService.sum(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;a must be positive&quot;</span>, illegalArgumentException.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-ExpectedException"><a href="#使用-ExpectedException" class="headerlink" title="使用 ExpectedException"></a>使用 ExpectedException</h2><p>借助 <code>ExpectedException</code> 预先设定预期抛出的异常和异常信息，然后执行测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> ExpectedException expectedException = ExpectedException.none();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldAssertExceptionMessageByRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expectedException.expect(IllegalArgumentException.class);</span><br><span class="line">    expectedException.expectMessage(<span class="string">&quot;a must be positive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SumService.sum(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可参考 <a href="https://github.com/Frederick-S/test-exception-message-with-junit-demo">GitHub</a>。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/2469911/how-do-i-assert-my-exception-message-with-junit-test-annotation">How do I assert my exception message with JUnit Test annotation?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设有如下的 &lt;code&gt;SumService&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="Java" scheme="https://frederick-s.github.io/tags/Java/"/>
    
    <category term="JUnit" scheme="https://frederick-s.github.io/tags/JUnit/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 JUnit 测试异步代码</title>
    <link href="https://frederick-s.github.io/2020/09/13/how-to-test-async-code-with-junit/"/>
    <id>https://frederick-s.github.io/2020/09/13/how-to-test-async-code-with-junit/</id>
    <published>2020-09-12T16:00:00.000Z</published>
    <updated>2020-09-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于以下的异步代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为其编写一个测试用例，并在 <code>CompletableFuture#whenComplete</code> 中判断返回值是否与预期相符，然而即使返回值与预期不符，该测试也不会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionWontBeCaptured</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DemoService demoService = <span class="keyword">new</span> DemoService();</span><br><span class="line"></span><br><span class="line">    demoService.hello()</span><br><span class="line">            .whenComplete((result, e) -&gt; &#123;</span><br><span class="line">                Assert.assertEquals(<span class="string">&quot;wrongValue&quot;</span>, result);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="CompletableFuture-get"><a href="#CompletableFuture-get" class="headerlink" title="CompletableFuture#get()"></a>CompletableFuture#get()</h3><p>我们可以借助 <code>CompletableFuture#get()</code> 阻塞主线程等待结果的特点，将异步代码转成同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockMainThreadByGet</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    DemoService demoService = <span class="keyword">new</span> DemoService();</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;hello&quot;</span>, demoService.hello().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>上述方案依赖了一个具体的异步类方法，如果实际的异步类不提供相应的同步方法，上述方案则不适合。针对这种情况，可以借助 <code>CountDownLatch</code>，初始化一个计数为1的 <code>CountDownLatch</code> 的实例，在测试方法中调用 <code>CountDownLatch#await()</code> 方法进行等待，当异步方法执行成功后在其回调中调用 <code>CountDownLatch#countDown()</code> 使计数器减1变为0，从而继续执行后续的测试判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitOnCountDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    DemoService demoService = <span class="keyword">new</span> DemoService();</span><br><span class="line">    AtomicReference&lt;String&gt; actualValue = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    demoService.hello()</span><br><span class="line">            .whenComplete((result, e) -&gt; &#123;</span><br><span class="line">                actualValue.set(result);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    countDownLatch.await();</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;hello&quot;</span>, actualValue.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Awaitility"><a href="#Awaitility" class="headerlink" title="Awaitility"></a>Awaitility</h3><p><a href="https://github.com/awaitility/awaitility">Awaitility</a> 让测试异步代码变得简单明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poweredByAwaitility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DemoService demoService = <span class="keyword">new</span> DemoService();</span><br><span class="line">    AtomicReference&lt;String&gt; actualValue = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    demoService.hello()</span><br><span class="line">            .whenComplete((result, e) -&gt; &#123;</span><br><span class="line">                actualValue.set(result);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    await().atMost(<span class="number">5</span>, SECONDS).untilAsserted(() -&gt; &#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;hello&quot;</span>, actualValue.get());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可参考 <a href="https://github.com/Frederick-S/test-async-code-with-junit-demo">GitHub</a>。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/631598/how-to-use-junit-to-test-asynchronous-processes">How to use JUnit to test asynchronous processes</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;对于以下的异步代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    
    <category term="Java" scheme="https://frederick-s.github.io/tags/Java/"/>
    
    <category term="JUnit" scheme="https://frederick-s.github.io/tags/JUnit/"/>
    
  </entry>
  
  <entry>
    <title>如何减小 Docker 镜像的大小</title>
    <link href="https://frederick-s.github.io/2020/08/04/how-to-reduce-docker-image-size/"/>
    <id>https://frederick-s.github.io/2020/08/04/how-to-reduce-docker-image-size/</id>
    <published>2020-08-03T16:00:00.000Z</published>
    <updated>2020-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先来看一个例子，构建一个 <code>C</code> 语言版的 <code>hello world</code> 镜像：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>Dockerfile</code> 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM gcc</span><br><span class="line">COPY hello.c .</span><br><span class="line">RUN gcc -o hello hello.c</span><br><span class="line">CMD [&quot;.&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><p>然后执行 <code>docker build -t hello-world .</code> 构建一个名为 <code>hello-world</code> 的镜像，然而以这种方式构建的镜像的大小竟然有1.19 GB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              b11e170bd1d2        6 minutes ago       1.19GB</span><br></pre></td></tr></table></figure><p>因为这种构建方式生成的镜像会同时包含 <code>gcc</code> 镜像的内容，查看 <code>gcc</code> 镜像大小发现达到了1.19 GB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">gcc                 latest              21f378ba43ec        11 days ago         1.19GB</span><br></pre></td></tr></table></figure><p>如果我们把基础镜像换成 <code>Ubuntu</code> 并安装 <code>gcc</code> 编译 <code>hello.c</code> 重新构建镜像，最后的镜像大小为213 MB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">COPY hello.c .</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install gcc -y</span><br><span class="line">RUN gcc -o hello hello.c</span><br><span class="line">CMD [&quot;.&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">hello-world         latest              42f17d1d12a5        About a minute ago   213MB</span><br></pre></td></tr></table></figure><p>虽然新镜像相比1.19 GB有大幅减少，但相比于 <code>hello-world</code> 程序本身的大小（17k）来说，213 MB依然是个庞大的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls hello -hl</span><br><span class="line">-rwxr-xr-x 1 root root 17K Aug  4 13:54 hello</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="Multi-stage"><a href="#Multi-stage" class="headerlink" title="Multi-stage"></a>Multi-stage</h3><p>对于 <code>hello-world</code> 这个镜像来说，我们真正需要的只是最终的可执行程序，而并不关心中间的编译过程，如果能将编译阶段作为一个临时阶段而并不包含在最终的镜像中，则可有效减少最终的镜像大小。针对此，<code>Docker</code> 在 17.05 版本开始提供了名为 <code>multi-stage</code> 构建的功能。我们将原来的 <code>Dockerfile</code> 稍作修改，将原来的编译阶段抽取为一个 <code>stage</code>，然后将编译好的可执行文件复制到最终的 <code>stage</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM gcc AS mybuildstage</span><br><span class="line">COPY hello.c .</span><br><span class="line">RUN gcc -o hello hello.c</span><br><span class="line">FROM ubuntu</span><br><span class="line">COPY --from&#x3D;mybuildstage hello .</span><br><span class="line">CMD [&quot;.&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><p>最终的镜像大小只有73.9 MB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              7dd2b51c53b2        7 minutes ago       73.9MB</span><br></pre></td></tr></table></figure><h3 id="FROM-scratch"><a href="#FROM-scratch" class="headerlink" title="FROM scratch"></a><code>FROM scratch</code></h3><p>在上一步中，我们使用 <code>Ubuntu</code> 作为基础镜像来运行 <code>hello-world</code>，相比于一个可执行程序，<code>Ubuntu</code> 依然过于庞大，有没有比 <code>Ubuntu</code> 更轻量的镜像呢？有，那就是 <code>scratch</code>，这表示一个空的镜像，继续将 <code>Dockerfile</code> 稍作修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM gcc AS mybuildstage</span><br><span class="line">COPY hello.c .</span><br><span class="line">RUN gcc -o hello hello.c</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from&#x3D;mybuildstage hello .</span><br><span class="line">CMD [&quot;.&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><p>最终的镜像大小只有16.4 KB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              676253b0e9c4        31 minutes ago      16.4kB</span><br></pre></td></tr></table></figure><p>不过在运行该镜像时却提示错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:211: exec user process caused &quot;no such file or directory&quot;</span><br></pre></td></tr></table></figure><p>这是因为这种方式构建出的镜像缺少 <code>hello-world</code> 运行时依赖的库。我们可以在编译 <code>hello-world</code> 时通过指定 <code>-static</code> 参数将依赖的库包含到最后的可执行文件中来解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM gcc AS mybuildstage</span><br><span class="line">COPY hello.c .</span><br><span class="line">RUN gcc -o hello hello.c -static</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from&#x3D;mybuildstage hello .</span><br><span class="line">CMD [&quot;.&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><p>不过包含了依赖的库后最终镜像的大小也上涨为945 KB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              e6a1fccc2de7        9 seconds ago       945kB</span><br></pre></td></tr></table></figure><p>另外，如果不想将依赖的库包含到最终的镜像中，可以使用 <code>busybox:glibc</code> 这个基础镜像，该镜像包含了 <code>C</code> 语言的标准库，有了这个镜像在编译 <code>hello-world</code> 时则无需指定 <code>-static</code> 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM gcc AS mybuildstage</span><br><span class="line">COPY hello.c .</span><br><span class="line">RUN gcc -o hello hello.c</span><br><span class="line">FROM busybox:glibc</span><br><span class="line">COPY --from&#x3D;mybuildstage hello .</span><br><span class="line">CMD [&quot;.&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><p>不过由于该镜像本身有一定大小，最终镜像的大小达到了5.22 MB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              e2f2c0544800        7 seconds ago       5.22MB</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <code>multi-stage</code> 构建可以有效的减少 <code>Docker</code> 镜像的大小，而基础镜像的选择则要具体情况分析，在满足需求的情况下选择合理的基础镜像。</p><p>参考：</p><ul><li><a href="https://www.ardanlabs.com/blog/2020/02/docker-images-part1-reducing-image-size.html">Docker Images : Part I - Reducing Image Size</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;首先来看一个例子，构建一个 &lt;code&gt;C&lt;/code&gt; 语言版的 &lt;code&gt;hello world&lt;/code&gt; 镜像：&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://frederick-s.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何解决 ModuleNotFoundError: No module named &#39;distutils.util&#39; 错误</title>
    <link href="https://frederick-s.github.io/2020/08/02/how-to-fix-no-module-named-distutils.util/"/>
    <id>https://frederick-s.github.io/2020/08/02/how-to-fix-no-module-named-distutils.util/</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2020-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Ubuntu</code> 下安装 <code>pip</code> 时遇到 <code>ModuleNotFoundError: No module named &#39;distutils.util&#39;</code> 错误，执行以下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-distutils</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/pypa/get-pip/issues/43">Issue with “python3 get-pip.py –user” with python 3.6.7</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Ubuntu&lt;/code&gt; 下安装 &lt;code&gt;pip&lt;/code&gt; 时遇到 &lt;code&gt;ModuleNotFoundError: No module named &amp;#39;distutils.util&amp;#39;&lt;/code&gt; 错误，执行以下命令即可：&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Python" scheme="https://frederick-s.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何解决 add-apt-repository: not found 错误</title>
    <link href="https://frederick-s.github.io/2020/08/01/how-to-fix-add-apt-repository-not-found-error/"/>
    <id>https://frederick-s.github.io/2020/08/01/how-to-fix-add-apt-repository-not-found-error/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2020-07-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Ubuntu</code> 下执行 <code>add-apt-repository</code> 添加第三方仓库时遇到 <code>add-apt-repository: not found</code> 错误，执行以下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://phoenixnap.com/kb/add-apt-repository-command-not-found-ubuntu">How To Fix ‘Add-Apt-Repository Command Not Found’ On Ubuntu &amp; Debian</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Ubuntu&lt;/code&gt; 下执行 &lt;code&gt;add-apt-repository&lt;/code&gt; 添加第三方仓库时遇到 &lt;code&gt;add-apt-repository: not found&lt;/code&gt; 错误，执行以下命令即可：&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
    <category term="Ubuntu" scheme="https://frederick-s.github.io/tags/Ubuntu/"/>
    
  </entry>
  
</feed>
