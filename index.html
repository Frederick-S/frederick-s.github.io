<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frederick-s.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Übung macht den Meister">
<meta property="og:url" content="https://frederick-s.github.io/index.html">
<meta property="og:site_name" content="Übung macht den Meister">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaodan Mao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frederick-s.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Übung macht den Meister</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J1NC2B33VK"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J1NC2B33VK');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Übung macht den Meister" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Übung macht den Meister</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fas fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-mit-6.824">

    <a href="/mit-6.824/" rel="section"><i class="fas fa-landmark fa-fw"></i>MIT 6.824</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-赞赏">

    <a href="/sponsor/" rel="section"><i class="fas fa-heart fa-fw"></i>赞赏</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fas fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Frederick-S" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/09/18/add-volume-to-aws-ec2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/add-volume-to-aws-ec2/" class="post-title-link" itemprop="url">AWS EC2 挂载磁盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-18T00:00:00+08:00">2022-09-18</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="挂载磁盘"><a class="markdownIt-Anchor" href="#挂载磁盘"></a> 挂载磁盘</h2>
<p>在创建 <code>AWS</code> 的 <code>EC2</code> 实例时如果添加了额外的磁盘则需要手动挂载到系统中。</p>
<p>首先运行 <code>lsblk</code> 来查看可用的块设备：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0          7:0    0 22.2M  1 loop /snap/amazon-ssm-agent/5657</span><br><span class="line">loop1          7:1    0   49M  1 loop /snap/core18/2406</span><br><span class="line">loop2          7:2    0 57.8M  1 loop /snap/core20/1498</span><br><span class="line">loop3          7:3    0 38.7M  1 loop /snap/snapd/15909</span><br><span class="line">loop4          7:4    0 71.8M  1 loop /snap/lxd/22927</span><br><span class="line">nvme1n1      259:0    0    8G  0 disk</span><br><span class="line">nvme0n1      259:1    0    8G  0 disk</span><br><span class="line">├─nvme0n1p1  259:2    0  7.9G  0 part /</span><br><span class="line">└─nvme0n1p15 259:3    0   99M  0 part /boot/efi</span><br></pre></td></tr></table></figure>
<p>其中的 <code>nvme1n1</code> 是本次新添加的磁盘，目前还未挂载到系统中，而 <code>nvme0n1</code> 则是根设备并且有两个分区。</p>
<blockquote>
<p><code>lsblk</code> 的输出结果会移除设备路径中的 <code>/dev/</code> 前缀，所以设备 <code>nvme1n1</code> 的完整路径为 <code>/dev/nvme1n1</code>。</p>
</blockquote>
<p>然后，我们需要在 <code>nvme1n1</code> 之上创建文件系统才能使用，执行 <code>sudo file -s /dev/nvme1n1</code> 显示 <code>nvme1n1</code> 还没有文件系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme1n1: data</span><br></pre></td></tr></table></figure>
<p>而如果我们查看 <code>sudo file -s /dev/nvme0n1</code> 则会显示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 16777215 sectors, extended partition table (last)</span><br></pre></td></tr></table></figure>
<p>执行 <code>sudo mkfs -t xfs /dev/nvme1n1</code> 来为 <code>nvme1n1</code> 创建文件系统，其中 <code>xfs</code> 表示文件系统的类型：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meta-data=/dev/nvme1n1           isize=512    agcount=8, agsize=262144 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                       reflink=1    bigtime=0 inobtcount=0</span><br><span class="line">data     =                       bsize=4096   blocks=2097152, imaxpct=25</span><br><span class="line">         =                       sunit=1      swidth=1 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0, ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=1 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>
<p>接着，我们就可以创建一个文件夹用来挂载磁盘，例如 <code>sudo mkdir /data</code>。最后将 <code>/dev/nvme1n1</code> 挂载到 <code>/data</code> 上：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/nvme1n1 /data</span><br></pre></td></tr></table></figure>
<p>此时如果查看 <code>df -h</code> 就会包含 <code>/dev/nvme1n1</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filesystem       Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        7.6G  1.6G  6.1G  21% /</span><br><span class="line">tmpfs            926M     0  926M   0% /dev/shm</span><br><span class="line">tmpfs            371M 1000K  370M   1% /run</span><br><span class="line">tmpfs            5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/nvme0n1p15   98M  5.1M   93M   6% /boot/efi</span><br><span class="line">tmpfs            186M  4.0K  186M   1% /run/user/1000</span><br><span class="line">/dev/nvme1n1     8.0G   90M  8.0G   2% /data</span><br></pre></td></tr></table></figure>
<h2 id="系统启动自动挂载磁盘"><a class="markdownIt-Anchor" href="#系统启动自动挂载磁盘"></a> 系统启动自动挂载磁盘</h2>
<p>当前的磁盘挂载信息会在系统启动后丢失，如果希望系统启动后自动挂载磁盘则需要向 <code>/etc/fstab</code> 中添加一条记录。</p>
<p>安全起见先备份下 <code>/etc/fstab</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/fstab /etc/fstab.orig</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>sudo blkid</code> 来查看设备 <code>/dev/nvme1n1</code> 的 <code>UUID</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1p1: LABEL=<span class="string">&quot;cloudimg-rootfs&quot;</span> UUID=<span class="string">&quot;15ea47e1-ef7d-4928-9dbe-ffaf0e743653&quot;</span> BLOCK_SIZE=<span class="string">&quot;4096&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;1957f80e-a338-441c-a0e0-ed1575eefda3&quot;</span></span><br><span class="line">/dev/nvme0n1p15: LABEL_FATBOOT=<span class="string">&quot;UEFI&quot;</span> LABEL=<span class="string">&quot;UEFI&quot;</span> UUID=<span class="string">&quot;68E7-1A63&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;vfat&quot;</span> PARTUUID=<span class="string">&quot;1eeb08ab-0afd-4477-bd53-4389a42db8f6&quot;</span></span><br><span class="line">/dev/loop1: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop4: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop2: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop0: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/nvme1n1: UUID=<span class="string">&quot;aa81c000-325c-40b7-ba4c-598ec2c824e0&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line">/dev/loop3: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后向 <code>/etc/fstab</code> 添加一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=aa81c000-325c-40b7-ba4c-598ec2c824e0  /data  xfs  defaults,nofail  0  2</span><br></pre></td></tr></table></figure>
<p>可以通过先取消挂载 <code>/data</code> 即 <code>sudo umount /data</code> 然后再挂载 <code>sudo mount -a</code> 来验证自动挂载是否生效。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html">Make an Amazon EBS volume available for use on Linux</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/09/11/setup-eks-cluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/setup-eks-cluster/" class="post-title-link" itemprop="url">创建 EKS 集群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-11T00:00:00+08:00">2022-09-11</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>EKS</code>（<code>Amazon Elastic Kubernetes Service</code>）是 <code>AWS</code> 提供的 <code>Kubernetes</code> 服务，它能大大减轻创建和维护 <code>Kubernetes</code> 集群的负担。</p>
<h2 id="创建-eks-集群"><a class="markdownIt-Anchor" href="#创建-eks-集群"></a> 创建 EKS 集群</h2>
<p>有两种方式来创建 <code>EKS</code> 集群，一种是使用本地的 <code>eksctl</code> 程序；另一种是通过 <code>AWS</code> 的管理后台（<code>AWS Management Console</code>），这里选择通过 <code>AWS</code> 的管理后台来创建 <code>EKS</code> 集群。</p>
<h3 id="创建-cluster-service-role"><a class="markdownIt-Anchor" href="#创建-cluster-service-role"></a> 创建 Cluster service role</h3>
<p>创建 <code>EKS</code> 集群时需要绑定一个 <code>IAM</code> 角色，因为 <code>Kubernetes</code> 的 <code>control plane</code> 需要管理集群内的资源，所以需要有相应的操作权限。</p>
<p>首先进入 <a target="_blank" rel="noopener" href="https://console.aws.amazon.com/iam/">IAM 控制台</a>，选择左侧 <code>Access management</code> 下的 <code>Roles</code>，点击 <code>Create role</code>。在 <code>Trusted entity type</code> 下选择 <code>AWS service</code>，然后在 <code>Use cases for other AWS services</code> 下选择 <code>EKS</code>，接着选择 <code>EKS - Cluster</code> 并点击 <code>Next</code>。在 <code>Add permissions</code> 这步直接点击 <code>Next</code>。在最后一步设置所创建的角色的名字，如 <code>eksClusterRole</code>，最后点击 <code>Create role</code> 创建角色。</p>
<h3 id="创建集群"><a class="markdownIt-Anchor" href="#创建集群"></a> 创建集群</h3>
<p>我们通过 <code>AWS</code> 管理后台中的 <code>Amazon Elastic Kubernetes Service</code> 界面来创建集群，第一步的 <code>Configure cluster</code> 主要设置集群的名称，如 <code>my-cluster</code>，以及绑定在之前步骤中所创建的 <code>Cluster service role</code>。第二步的 <code>Specify networking</code> 这里基本都保持默认，只是将 <code>Cluster endpoint access</code> 设置为 <code>Public and private</code>。第三步的 <code>Configure logging</code> 可以暂时不开启日志监控。最后在第四步的 <code>Review and create</code> 点击 <code>Create</code> 创建集群。</p>
<h2 id="创建-node-group"><a class="markdownIt-Anchor" href="#创建-node-group"></a> 创建 Node group</h2>
<p>当集群的状态变为 <code>Active</code> 后就表示集群创建成功，不过此时集群中还没有任何 <code>Node</code>，所以系统级别的 <code>Pod</code> 还无法正常工作，比如在集群详情的 <code>Resources</code> 下查看某个 <code>coredns</code> 的 <code>Pod</code> 会显示 <code>FailedScheduling</code>，因为 <code>no nodes available to schedule pods</code>。</p>
<p>我们需要创建 <code>Node group</code> 来为系统添加可用的 <code>Node</code>。</p>
<h3 id="创建-node-iam-role"><a class="markdownIt-Anchor" href="#创建-node-iam-role"></a> 创建 Node IAM role</h3>
<p>在创建 <code>Node group</code> 前，需要创建一个 <code>Node IAM role</code>。因为集群中的 <code>Node</code> 内部会运行着一个叫做 <code>kubelet</code> 的程序，它负责和集群的 <code>control plane</code> 进行通信，例如将当前 <code>Node</code> 注册到集群中，而某些操作需要调用 <code>AWS</code> 的接口，所以和 <code>Cluster service role</code> 类似，也需要绑定相应的权限。</p>
<p>这里同样也是通过 <a target="_blank" rel="noopener" href="https://console.aws.amazon.com/iam/">IAM 控制台</a> 来创建角色，在 <code>Trusted entity type</code> 下选择 <code>AWS service</code>，在 <code>Use case</code> 下选择 <code>EC2</code>，然后点击 <code>Next</code>。在第二步的 <code>Add permissions</code> 需要添加 <code>AmazonEKSWorkerNodePolicy</code>，<code>AmazonEC2ContainerRegistryReadOnly</code> 和 <code>AmazonEKS_CNI_Policy</code> 三个权限，虽然文档中说不建议将 <code>AmazonEKS_CNI_Policy</code> 权限添加到 <code>Node IAM role</code> 上，不过这里作为示例教程将三个权限都绑定在了 <code>Node IAM role</code> 上。最后也是点击 <code>Create role</code> 创建角色。</p>
<h3 id="创建-node-group-2"><a class="markdownIt-Anchor" href="#创建-node-group-2"></a> 创建 Node group</h3>
<p>在集群详情的 <code>Compute</code> 下点击 <code>Add node group</code> 来创建 <code>Node group</code>，在第一步 <code>Configure node group</code> 中设置 <code>node group</code> 的名称及绑定在之前步骤中所创建的 <code>Node IAM role</code>。在第二步 <code>Set compute and scaling configuration</code> 里配置节点的类型和数量等信息，作为教程都采用默认配置。第三步 <code>Specify networking</code> 同样采用默认配置。最后在第四步的 <code>Review and create</code> 点击 <code>Create</code> 完成创建。</p>
<p>最后当所创建的 <code>Node group</code> 的状态变为 <code>Active</code> 以及该 <code>Node group</code> 下的 <code>Node</code> 的状态变为 <code>Ready</code> 时说明节点创建成功。此时再查看集群详情下 <code>Resources</code> 的 <code>coredns</code> 的 <code>Pod</code> 已成功分配了 <code>Node</code> 运行。</p>
<h2 id="连接-eks-集群"><a class="markdownIt-Anchor" href="#连接-eks-集群"></a> 连接 EKS 集群</h2>
<p>日常需要通过 <code>kubectl</code> 管理集群，所以需要先在本地配置访问 <code>EKS</code> 集群的权限。<code>kubectl</code> 本质上是和 <code>Kubernetes API server</code> 打交道，而创建集群时 <code>Cluster endpoint access</code> 部分选择的是 <code>Public and private</code>，所以在这个场景下能够从公网管理 <code>EKS</code> 集群。</p>
<p>首先需要安装 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">AWS CLI</a> 和 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html">kubectl</a>。然后在本地通过 <code>aws configure</code> 来设置 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>。根据 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html">Enabling IAM user and role access to your cluster</a> 的描述，创建集群的账户会自动授予集群的 <code>system:masters</code> 权限，本文是通过 <code>AWS</code> 的管理后台创建集群，当前登录的账户为 <code>root</code>，所以 <code>aws configure</code> 需要设置为 <code>root</code> 的 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>：</p>
<blockquote>
<p>When you create an Amazon EKS cluster, the AWS Identity and Access Management (IAM) entity user or role, such as a federated user that creates the cluster, is automatically granted system:masters permissions in the cluster’s role-based access control (RBAC) configuration in the Amazon EKS control plane.</p>
</blockquote>
<p>一般公司生产环境中的 <code>AWS</code> 是不会直接使用 <code>root</code> 账户登录的，而是创建 <code>IAM</code> 用户，由于这里是个人的 <code>AWS</code> 账户所以直接使用了 <code>root</code>，反之就需要使用 <code>IAM</code> 用户的 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>。设置完成之后可以通过 <code>aws sts get-caller-identity</code> 来验证当前用户是否设置正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;UserId&quot;: &quot;123&quot;,</span><br><span class="line">    &quot;Account&quot;: &quot;123&quot;,</span><br><span class="line">    &quot;Arn&quot;: &quot;arn:aws:iam::123:user&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>aws eks update-kubeconfig --region us-west-2 --name my-cluster</code> 来更新本地的 <code>kubeconfig</code>，其中 <code>us-west-2</code> 需要修改为实际的 <code>AWS Region</code>，<code>my-cluster</code> 需要修改为实际的集群名称。最后就可以通过 <code>kubectl get all</code> 来验证能否访问集群，如果没有问题就会输出如下类似内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service&#x2F;kubernetes   ClusterIP   10.100.0.1   &lt;none&gt;        443&#x2F;TCP   175m</span><br></pre></td></tr></table></figure>
<h2 id="设置其他用户的集群访问权限"><a class="markdownIt-Anchor" href="#设置其他用户的集群访问权限"></a> 设置其他用户的集群访问权限</h2>
<p>创建集群的账户可能权限较高，所以需要单独给某些账户开通集群的访问权限。可以通过 <code>kubectl describe -n kube-system configmap/aws-auth</code> 查看当前的权限分配情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name:         aws-auth</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">mapRoles:</span><br><span class="line">----</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers</span><br><span class="line">  - system:nodes</span><br><span class="line">  rolearn: arn:aws:iam::123:role&#x2F;AmazonEKSNodeRole</span><br><span class="line">  username: system:node:&#123;&#123;EC2PrivateDNSName&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryData</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>假设我们需要授予某个 <code>IAM</code> 用户 <code>eks</code> <code>system:masters</code> 的角色，首先运行 <code>kubectl edit -n kube-system configmap/aws-auth</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><br><span class="line"># and an empty file will abort the edit. If an error occurs while saving this file will be</span><br><span class="line"># reopened with the relevant failures.</span><br><span class="line">#</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  mapRoles: |</span><br><span class="line">    - groups:</span><br><span class="line">      - system:bootstrappers</span><br><span class="line">      - system:nodes</span><br><span class="line">      rolearn: arn:aws:iam::123:role&#x2F;AmazonEKSNodeRole</span><br><span class="line">      username: system:node:&#123;&#123;EC2PrivateDNSName&#125;&#125;</span><br><span class="line">  mapUsers: |</span><br><span class="line">    - groups:</span><br><span class="line">      - system:masters</span><br><span class="line">      userarn: arn:aws:iam::123:user&#x2F;eks</span><br><span class="line">      username: eks</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-09-11T06:33:38Z&quot;</span><br><span class="line">  name: aws-auth</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  resourceVersion: &quot;33231&quot;</span><br><span class="line">  uid: 6b186686-548c-4c99-9f65-0381da1366a4</span><br></pre></td></tr></table></figure>
<p>这里在 <code>data</code> 下新增了 <code>mapUsers</code>，授予用户 <code>eks</code> <code>system:masters</code> 的角色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapUsers: |</span><br><span class="line">  - groups:</span><br><span class="line">    - system:masters</span><br><span class="line">    userarn: arn:aws:iam::123:user&#x2F;eks</span><br><span class="line">    username: eks</span><br></pre></td></tr></table></figure>
<p>保存后可以通过 <code>kubectl describe configmap -n kube-system aws-auth</code> 验证改动是否生效。然后下载 <code>aws-auth-cm.yaml</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o aws-auth-cm.yaml https:&#x2F;&#x2F;s3.us-west-2.amazonaws.com&#x2F;amazon-eks&#x2F;cloudformation&#x2F;2020-10-29&#x2F;aws-auth-cm.yaml</span><br></pre></td></tr></table></figure>
<p>将其中的 <code>&lt;ARN of instance role (not instance profile)&gt;</code> 替换为之前创建的 <code>Node IAM role</code>，然后执行 <code>kubectl apply -f aws-auth-cm.yaml</code> 应用修改，执行 <code>kubectl get nodes --watch</code> 观察是否所有的节点的状态都变为了 <code>Ready</code>。</p>
<p>接着删除本地的 <code>~/.kube/config</code> 来验证权限是否生效。重新运行 <code>aws configure</code> 来设置某个 <code>IAM</code> 用户的信息，因为我们要重新执行 <code>aws eks update-kubeconfig --region us-west-2 --name my-cluster</code> 来生成新的 <code>~/.kube/config</code>，这里要求当前 <code>IAM</code> 用户拥有 <code>DescribeCluster</code> 的权限，这个权限是 <code>AWS</code> 层面的资源访问权限，而不是 <code>EKS</code> 集群的权限，添加权限后可能需要等待几分钟才会生效。当重新生成了 <code>~/.kube/config</code> 文件之后，就可以继续通过 <code>kubectl get all</code> 验证访问权限是否生效。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role">Creating the Amazon EKS cluster role</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html#create-worker-node-role">Creating the Amazon EKS node IAM role</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html">Enabling IAM user and role access to your cluster</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50791303/kubectl-error-you-must-be-logged-in-to-the-server-unauthorized-when-accessing">kubectl error You must be logged in to the server (Unauthorized) when accessing EKS cluster</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/09/01/hello-minikube-connection-reset-on-apple-m1-max/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/01/hello-minikube-connection-reset-on-apple-m1-max/" class="post-title-link" itemprop="url">Hello Minikube - Apple M1 Max connection reset</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-01T00:00:00+08:00">2022-09-01</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>297</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 <code>Apple M1 Max</code> 处理器上按照 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/hello-minikube/">Hello Minikube</a> 进行 <code>minikube</code> 的入门教程，不过最后通过本地链接访问的时候出现了 <code>connection reset</code>。按照 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/minikube/issues/12036">这里</a> 的描述需要将镜像由 <code>echoserver:1.4</code> 换成适用于 <code>Apple M1 Max</code> 的 <code>echoserver-arm:1.8</code>，即：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment hello-arm --image=registry.k8s.io/echoserver-arm:1.8</span><br></pre></td></tr></table></figure>
<p>不过帖子中也有人提到换了镜像之后依然无效，所以也不一定对所有人有用。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/minikube/issues/12036">Cannot connect to service from localhost on M1 Mac</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/07/03/buddy-memory-allocation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/03/buddy-memory-allocation/" class="post-title-link" itemprop="url">Buddy Memory Allocation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-03T00:00:00+08:00">2022-07-03</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>Buddy Memory Allocation</code> 是内存分配算法的一种，它假定内存的大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>（<code>N</code> 为整数），并且总是以2的幂次方为单位分配或者释放内存。</p>
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2>
<p>假设某个线程需要申请 <code>m</code> 字节内存，<code>Buddy Memory Allocation</code> 会先在当前所有的空闲空间中找到最小的空间满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">2^k \geq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的一半依然大于等于 <code>m</code>，说明当前分配的空间过大，则继续将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>对半分（分裂后的这两块内存区域就成为了互为兄弟关系（<code>buddies</code>）），不断重复上述操作，直到找到最小的 <code>p</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">p \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>）满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>m</mi><mo>≤</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">2^{p - 1} &lt; m \leq 2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>下图描述了从16字节中分配3字节的过程（假设系统总共只有16字节内存）：</p>
<ol>
<li>初始状态整个内存只有16字节，是可分配的最小空间；不过由于16字节的一半大于3字节，所以将16字节拆分为两个8字节</li>
<li>同理一个8字节的一半依然大于3字节，继续将其中一个8字节拆分为两个4字节</li>
<li>4字节的一半比3字节小，所以4字节就是可分配的最小内存空间</li>
</ol>
<p><img src="/images/buddy-1.png" alt="alt" /></p>
<p>当某个线程需要释放<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的内存时，<code>Buddy Memory Allocation</code> 会尝试将这个内存空间及其相邻的兄弟空间一起合并得到一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>大小的空间，然后一直重复此操作，直到某块内存空间无法和其兄弟空间合并，无法合并的情况有三种：</p>
<ol>
<li>当前分配的内存空间大小为整个内存空间的大小，所以也就没有兄弟空间</li>
<li>兄弟空间已全部分配</li>
<li>兄弟空间已局部分配</li>
</ol>
<p>下图描述了从16字节中释放3字节的过程（假设系统总共只有16字节内存）：</p>
<ol>
<li>当前系统分配了一个2字节的空间和一个4字节的空间</li>
<li>此时需要回收被占用的2字节，由于它的兄弟空间没有被占用，所以两个2字节的空间合并为一个4字节的空间</li>
<li>合并后的4字节的空间的兄弟空间同样没有被占用，两个4字节的空间继续合并为1个8字节的空间</li>
<li>合并后的8字节的空间的兄弟空间存在部分占用，无法继续合并</li>
</ol>
<p><img src="/images/buddy-2.png" alt="alt" /></p>
<h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2>
<h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3>
<p>首先定义一个 <code>Memory</code> 类来表示内存，其内部使用一个 <code>byte</code> 数组来存储数据，数组的索引就是内存地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memory</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;size should be greater than zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.memory = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，<code>Memory</code> 类还支持 <code>bool</code> 和 <code>int32</code> 类型的数据读写，从实现的简化考虑，<code>bool</code> 值的读写以一个 <code>byte</code> 为单位；而 <code>int32</code> 的读写以4个 <code>byte</code> 为单位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定的地址设置布尔值，占据一字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">int</span> address, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.memory[address] = value ? (<span class="keyword">byte</span>) <span class="number">1</span> : (<span class="keyword">byte</span>) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的地址读取布尔值，读取一字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBool</span><span class="params">(<span class="keyword">int</span> address)</span> </span>&#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.memory[address] == (<span class="keyword">byte</span>) <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给定的地址设置 int32，占据4字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInt32</span><span class="params">(<span class="keyword">int</span> address, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = ByteBuffer.allocate(Constant.INT32_SIZE).putInt(value).array();</span><br><span class="line">    setByteArray(address, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的地址读取 int32，读取4字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt32</span><span class="params">(<span class="keyword">int</span> address)</span> </span>&#123;</span><br><span class="line">    checkAddress(address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (address + Constant.INT32_SIZE &gt; <span class="keyword">this</span>.memory.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;address overflow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[Constant.INT32_SIZE];</span><br><span class="line"></span><br><span class="line">    System.arraycopy(<span class="keyword">this</span>.memory, address, bytes, <span class="number">0</span>, Constant.INT32_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(bytes).getInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="block"><a class="markdownIt-Anchor" href="#block"></a> Block</h3>
<p>定义 <code>Block</code> 表示系统所分配的内存块，其中 <code>address</code> 表示该 <code>Block</code> 的起始内存地址，同时 <code>Block</code> 借助 <code>Memory</code> 对内存实现读写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Block</span><span class="params">(<span class="keyword">int</span> address, Memory memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address &lt; <span class="number">0</span> || address &gt;= memory.getSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(memory, <span class="string">&quot;memory should not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图展示了一个 <code>Block</code> 在内存中的布局：</p>
<p><img src="/images/buddy-3.png" alt="alt" /></p>
<p>一个 <code>Block</code> 除了包含用户数据外还需要保存元数据，所以每个 <code>Block</code> 占据的内存会大于用户实际申请的内存；元数据中的第一个字节表示当前内存块是否被使用；第2到5字节表示 <code>sizeClass</code>，用来计算当前内存块所占据的内存的大小，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{sizeClass}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span></span>；第6到9字节表示前一个空闲内存块的地址；第10到13字节表示后一个空闲内存块的地址；从第14字节开始就是用户数据。当然，这只是一种很粗犷的布局方式，实际应用中的布局必然比这个精炼。</p>
<p>这里需要前一个/后一个空闲内存块的地址是因为将相同大小的内存块通过双向链表的方式串联在一起，从而能快速找到以及删除某个指定大小的内存块。因为 <code>Buddy Memory Allocation</code> 始终以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>大小分配内存，假设系统的最大内存为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>，则可以建立 <code>N</code> 个双向链表，每个双向链表表示当前大小下可用的内存块，如下图所示：</p>
<p><img src="/images/buddy-4.png" alt="alt" /></p>
<p><code>Block</code> 通过 <code>Memory</code> 类提供的 <code>bool</code>，<code>int32</code> 数据的读写功能来实现对元数据的读写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 block 标记为已使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memory.setBool(<span class="keyword">this</span>.address, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 block 是否已使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.memory.getBool(<span class="keyword">this</span>.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放当前 block</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memory.setBool(<span class="keyword">this</span>.address, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 sizeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSizeClass</span><span class="params">(<span class="keyword">int</span> sizeClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memory.setInt32(<span class="keyword">this</span>.address + Constant.OFFSET_SIZE_CLASS, sizeClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前 block 的 sizeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSizeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.memory.getInt32(<span class="keyword">this</span>.address + Constant.OFFSET_SIZE_CLASS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置前一个空闲的 block</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrev</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memory.setInt32(<span class="keyword">this</span>.address + Constant.OFFSET_PREV, block.getAddress());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前一个空闲的 block</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Block <span class="title">getPrev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> address = <span class="keyword">this</span>.memory.getInt32(<span class="keyword">this</span>.address + Constant.OFFSET_PREV);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> address == -<span class="number">1</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Block(address, <span class="keyword">this</span>.memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置后一个空闲的 block</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memory.setInt32(<span class="keyword">this</span>.address + Constant.OFFSET_NEXT, block.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后一个空闲的 block</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Block <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> address = <span class="keyword">this</span>.memory.getInt32(<span class="keyword">this</span>.address + Constant.OFFSET_NEXT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> address == -<span class="number">1</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Block(address, <span class="keyword">this</span>.memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="blocklist"><a class="markdownIt-Anchor" href="#blocklist"></a> BlockList</h3>
<p><code>BlockList</code> 表示一个双向链表，用于存储某个 <code>sizeClass</code> 下的所有空闲内存块，为了实现方便，内部使用了一个哨兵头节点来作为双向链表的头节点，新节点的插入采用头插法的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> buddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Block head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sizeClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockList</span><span class="params">(<span class="keyword">int</span> address, Memory memory, <span class="keyword">int</span> sizeClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address &lt; <span class="number">0</span> || address &gt;= memory.getSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(memory, <span class="string">&quot;memory cannot be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sizeClass &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid sizeClass&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Block(address, memory);</span><br><span class="line">        <span class="keyword">this</span>.head.setSizeClass(sizeClass);</span><br><span class="line">        <span class="keyword">this</span>.sizeClass = sizeClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空列表，将头节点指向自身</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">this</span>.head);</span><br><span class="line">        <span class="keyword">this</span>.head.setPrev(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getNext().equals(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头节点的后一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Block <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;list must not be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头插法插入一个 block</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFront</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head.insertAfter(block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前列表是否有空闲的内存块，以及该内存块是否能容纳 size 大小的数据（减去元数据占用的内存大小后）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAvailableBlock</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.isEmpty() &amp;&amp; Block.getActualSize(<span class="keyword">this</span>.sizeClass) &gt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有空闲内存块的数量，不包含哨兵头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Block block = <span class="keyword">this</span>.head.getNext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!block.equals(<span class="keyword">this</span>.head)) &#123;</span><br><span class="line">            length += <span class="number">1</span>;</span><br><span class="line">            block = block.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于需要通过哨兵头节点访问下一个可用的内存块，所以每个哨兵头节点就需要知道下一个 <code>Block</code> 的内存起始地址，因此同样需要将哨兵头节点的信息保存在内存中，对于内存大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>的系统来说，一共需要保存 <code>N</code> 个哨兵头节点的信息，这里将内存分为两部分，前一部分保存所有的哨兵头节点，后一部分保存所有的 <code>Block</code>：</p>
<p><img src="/images/buddy-5.png" alt="alt" /></p>
<p>因此第一个 <code>Block</code> 的内存起始位置也就等于所有哨兵节点的大小之和。</p>
<h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<p>定义 <code>Allocator</code> 负责内存的分配和回收，本质上是对 <code>Block</code> 的管理，即 <code>Block</code> 的分裂和合并：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockList[] blockLists;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SIZE_CLASS = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE_CLASS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Allocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> allHeadSentinelSize = <span class="keyword">this</span>.getMemoryOffset();</span><br><span class="line">        <span class="keyword">int</span> maxMemorySize = (<span class="number">1</span> &lt;&lt; MAX_SIZE_CLASS) + allHeadSentinelSize;</span><br><span class="line">        <span class="keyword">this</span>.memory = <span class="keyword">new</span> Memory(maxMemorySize);</span><br><span class="line">        <span class="keyword">this</span>.blockLists = <span class="keyword">new</span> BlockList[MAX_SIZE_CLASS];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化空闲列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE_CLASS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sizeClass = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> headSentinelAddress = Constant.HEAD_SENTINEL_SIZE * i;</span><br><span class="line">            <span class="keyword">this</span>.blockLists[i] = <span class="keyword">new</span> BlockList(headSentinelAddress, <span class="keyword">this</span>.memory, sizeClass);</span><br><span class="line">            <span class="keyword">this</span>.blockLists[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The single full block</span></span><br><span class="line">        Block block = <span class="keyword">new</span> Block(allHeadSentinelSize, <span class="keyword">this</span>.memory);</span><br><span class="line">        block.setSizeClass(MAX_SIZE_CLASS);</span><br><span class="line">        block.setFree();</span><br><span class="line">        <span class="keyword">this</span>.blockLists[MAX_SIZE_CLASS - <span class="number">1</span>].insertFront(block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们假设系统最大能支持的内存大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>个字节，由于哨兵节点也需要占用一部分内存，所以在构造函数中初始化 <code>Memory</code> 的大小为所有哨兵节点占用的内存大小加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> 个字节。同时，系统可分配的 <code>Block</code> 的大小分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，…，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding="application/x-tex">2^{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，对应需要初始化16个双向链表，这里简单的使用数组来保存这16个双向链表，并初始化对应哨兵头节点的内存起始地址。同时，整个系统在初始状态只有一个 <code>Block</code>，大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<h4 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h4>
<p>如前面所述，内存分配的第一步是找到满足用户内存需求的最小的 <code>Block</code>，然后如果 <code>Block</code> 过大则继续将 <code>Block</code> 进行分裂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Block block = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE_CLASS; i++) &#123;</span><br><span class="line">        BlockList blockList = <span class="keyword">this</span>.blockLists[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到满足用户内存需求的最小的 Block</span></span><br><span class="line">        <span class="keyword">if</span> (!blockList.hasAvailableBlock(size)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        block = blockList.getFirst();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试将 block 分裂</span></span><br><span class="line">        block = <span class="keyword">this</span>.split(block, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 block 标记为已使用</span></span><br><span class="line">        block.setUsed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;memory is full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有返回 block 的起始地址，因为 block 的起始地址指向的是元数据，实际需要返回用户数据的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> block.getUserAddress();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Block 分裂（如果能分裂的话），返回分裂后的左兄弟</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Block <span class="title">split</span><span class="params">(Block block, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sizeClass = block.getSizeClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 block 的一半（减去元数据占据的空间后）仍能容纳 size，则持续将 block 分裂</span></span><br><span class="line">    <span class="comment">// 由于 block 本身需要存储元数据，每个 block 至少需要 2^MIN_SIZE_CLASS 字节</span></span><br><span class="line">    <span class="keyword">while</span> (sizeClass &gt; MIN_SIZE_CLASS &amp;&amp; Block.getActualSize(sizeClass - <span class="number">1</span>) &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">int</span> newSizeClass = sizeClass - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 block 分裂为两个，取第一个继续分裂</span></span><br><span class="line">        Block[] buddies = <span class="keyword">this</span>.splitToBuddies(block, newSizeClass);</span><br><span class="line">        block = buddies[<span class="number">0</span>];</span><br><span class="line">        sizeClass = newSizeClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 block 从空闲链表中删除</span></span><br><span class="line">    block.removeFromList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Block[] splitToBuddies(Block block, <span class="keyword">int</span> sizeClass) &#123;</span><br><span class="line">    block.removeFromList();</span><br><span class="line">    Block[] buddies = <span class="keyword">new</span> Block[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新分裂后的 block 的起始地址和 sizeClass，并标记为可用</span></span><br><span class="line">        <span class="keyword">int</span> address = block.getAddress() + (<span class="number">1</span> &lt;&lt; sizeClass) * i;</span><br><span class="line">        buddies[i] = <span class="keyword">new</span> Block(address, <span class="keyword">this</span>.memory);</span><br><span class="line">        buddies[i].setFree();</span><br><span class="line">        buddies[i].setSizeClass(sizeClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里从后往前遍历 buddies 插入到双链表中是因为最后返回给用户的是第一个 buddy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.blockLists[sizeClass - <span class="number">1</span>].insertFront(buddies[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buddies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h4>
<p>应用程序要求释放内存时，提交的是用户数据的起始地址，需要先将其转为 <code>Block</code> 的起始地址（减去 <code>Block</code> 元数据的占用空间大小即可），然后尝试将 <code>Block</code> 和其兄弟合并，并将合并后的 <code>Block</code> 加入到空闲列表中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">int</span> userAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据用户数据地址得到 Block 的起始地址</span></span><br><span class="line">    Block block = Block.fromUserAddress(userAddress, <span class="keyword">this</span>.memory);</span><br><span class="line">    block.setFree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将 block 和其兄弟合并</span></span><br><span class="line">    <span class="keyword">this</span>.merge(block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sizeClass = block.getSizeClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多只能合并到 MAX_SIZE_CLASS - 1</span></span><br><span class="line">    <span class="keyword">while</span> (sizeClass &lt; MAX_SIZE_CLASS) &#123;</span><br><span class="line">        <span class="comment">// 得到兄弟 block</span></span><br><span class="line">        Block buddy = <span class="keyword">this</span>.getBuddy(block, sizeClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟 block 正在被使用或者已分裂为更小的 block，则不能合并</span></span><br><span class="line">        <span class="keyword">if</span> (buddy.isUsed() || buddy.getSizeClass() != sizeClass) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将兄弟 block 从空闲链表中删除</span></span><br><span class="line">        buddy.removeFromList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果兄弟 block 的起始地址比 block 的起始地址小，说明当前的 block 是右兄弟，由于合并后需要得到整个 block 的起始地址，因此将 block 指向 buddy</span></span><br><span class="line">        <span class="keyword">if</span> (block.getAddress() &gt; buddy.getAddress()) &#123;</span><br><span class="line">            block = buddy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sizeClass += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置合并后的 sizeClass</span></span><br><span class="line">    block.setSizeClass(sizeClass);</span><br><span class="line">    <span class="keyword">this</span>.blockLists[sizeClass - <span class="number">1</span>].insertFront(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个关键的问题在于如何根据 <code>block</code> 的地址知道其兄弟 <code>block</code> 的地址？因为一个 <code>block</code> 会被分为左兄弟和右兄弟两个内存块，如果当前 <code>block</code> 是左兄弟，则右兄弟的地址为 <code>block.getAddress() + 1 &lt;&lt; sizeClass</code>，如果当前 <code>block</code> 是右兄弟，则左兄弟的地址为 <code>block.getAddress() - 1 &lt;&lt; sizeClass</code>。然而由于缺失位置信息我们并不能知道一个 <code>block</code> 是左兄弟还是右兄弟。</p>
<p>原作者在这里巧妙的在不引入额外的元数据的情况下解决了这个问题。首先，对于某个 <code>sizeClass</code> 为 <code>k</code> 的内存块来说，它的起始地址一定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，其中 <code>C</code> 为整数。这里使用数学归纳法来证明，假设系统内存最多支持<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>个字节，则初始状态下整个系统只有一个内存块，<code>k</code> 就等于 <code>N</code>，该内存块的起始地址为0，满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，取 <code>C = 0</code> 即可。假设某个 <code>sizeClass</code> 为 <code>k</code> 的内存块的起始地址满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则需要进一步证明分裂后的两个内存块的起始地址为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>C</mi><mo mathvariant="normal">′</mo></msup><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C&#x27;2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。而分裂后的内存块的起始地址分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C2^k + 2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，又<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>C</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C2^k = (2C)2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>C</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C2^k + 2^{k - 1} = (2C+ 1)2^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，证明完毕。同时，由这些公式可以发现，对于左兄弟内存块来说，<code>C</code> 是偶数，而对于右兄弟内存块来说 <code>C</code> 是奇数。更进一步来说，左右兄弟内存块的地址差异仅在于从低位往高位数的第 <code>k + 1</code> 位不同。</p>
<p>因此，根据某个内存块的地址推算出兄弟内存块的地址只需要将当前内存块的地址从低位往高位数第 <code>k + 1</code> 位反转即可。这种涉及反转比特位的操作就可以使用异或运算，我们可以将内存块的地址和 <code>1 &lt;&lt; sizeClass</code>（也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>）进行异或运算，得到的地址就是对应兄弟内存块的地址。</p>
<p>另外，由于哨兵头节点的存在，<code>Memory</code> 内部的数组大小不是严格的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，在计算兄弟内存块的地址时，可以先将当前内存块的地址减去哨兵头节点的大小之和，计算出兄弟内存块的地址之后，再加回偏移量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Block <span class="title">getBuddy</span><span class="params">(Block block, <span class="keyword">int</span> sizeClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> virtualAddress = block.getAddress() - <span class="keyword">this</span>.getMemoryOffset();</span><br><span class="line">    <span class="keyword">int</span> buddyVirtualAddress = virtualAddress ^ (<span class="number">1</span> &lt;&lt; sizeClass);</span><br><span class="line">    <span class="keyword">int</span> buddyAddress = buddyVirtualAddress + <span class="keyword">this</span>.getMemoryOffset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Block(buddyAddress, <span class="keyword">this</span>.memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>以上仅作为 <code>Buddy Memory Allocation</code> 算法的示例，不具有实际应用意义，例如完全没有考虑线程安全。完整的代码可参考原作者的 <a target="_blank" rel="noopener" href="https://github.com/kunigami/blog-examples/blob/master/buddy-algorithm/buddy_algorithm.py">代码</a> 及 <code>Java</code> 版本的 <a target="_blank" rel="noopener" href="https://github.com/Frederick-S/buddy-memory-allocation">buddy-memory-allocation</a>。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.kuniga.me/blog/2020/07/31/buddy-memory-allocation.html">Buddy Memory Allocation</a></li>
<li><a target="_blank" rel="noopener" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/Buddy.html#buddy-methods">Buddy Methods</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/06/25/simple-template-engine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/simple-template-engine/" class="post-title-link" itemprop="url">A Template Engine - 简易模板引擎实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-25T00:00:00+08:00">2022-06-25</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文内容主要来源于 <a target="_blank" rel="noopener" href="https://aosabook.org/en/500L/a-template-engine.html">A Template Engine</a>。</p>
</blockquote>
<h2 id="支持的语法"><a class="markdownIt-Anchor" href="#支持的语法"></a> 支持的语法</h2>
<p>首先来看一下这个模板引擎所支持的语法。</p>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<p>使用 <code>&#123;&#123; variable &#125;&#125;</code> 来表示变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>如果 <code>user_name</code> 是 <code>Tom</code>，则最后渲染的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Welcome, Tom!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="对象属性和方法"><a class="markdownIt-Anchor" href="#对象属性和方法"></a> 对象属性和方法</h3>
<p>除了字面量外，模板引擎的变量还支持复杂对象，可以通过点操作符来访问对象的属性或方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;The price is: &#123;&#123;product.price&#125;&#125;, with a &#123;&#123;product.discount&#125;&#125;% discount.&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>注意如果访问的是对象的方法，则不需要在方法名后添加 <code>()</code>，模板引擎会自动解析并调用方法。</p>
<p>同时，还可以使用管道操作符来链式调用过滤器，从而改变所渲染的变量值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Short name: &#123;&#123;story.subject|slugify|lower&#125;&#125;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h3>
<p>使用 <code>&#123;% if condition %&#125; body &#123;% endif %&#125;</code> 来表示条件判断，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user.is_logged_in %&#125;</span><br><span class="line">    &lt;p&gt;Welcome, &#123;&#123; user.name &#125;&#125;!&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<p>使用 <code>&#123;% for item in list %&#125; body &#123;% endfor %&#125;</code> 来表示循环，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Products:&lt;&#x2F;p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for product in product_list %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; product.name &#125;&#125;: &#123;&#123; product.price|format_price &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<p>使用 <code>&#123;# comment #&#125;</code> 来表示注释，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;# This is the best template ever! #&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2>
<p>一般来说，一个模板引擎主要做两件事：模板解析和渲染。这里要实现的模板引擎的渲染包括：</p>
<ul>
<li>管理动态数据</li>
<li>执行逻辑语句，例如 <code>if</code>，<code>for</code></li>
<li>实现点操作符访问和过滤器执行</li>
</ul>
<p>类似于编程语言的实现，模板引擎的解析也可以分为解释型和编译型两种。对于解释型来说，模板解析阶段需要生成某个特定的数据结构，然后在渲染阶段遍历该数据结构并执行所遇到的每一条指令；而对于编译型来说，模板解析阶段直接生成可执行代码，而渲染阶段则大大简化，直接执行代码即可。</p>
<p>本文描述的模板引擎采用编译型的方式，原文的作者将模板编译为了 <code>Python</code> 代码，这里为了进一步加深理解，实现了 <code>.NET Core</code> 版本的简单编译。</p>
<h2 id="编译为-c-代码"><a class="markdownIt-Anchor" href="#编译为-c-代码"></a> 编译为 C# 代码</h2>
<p>在介绍模板引擎实现之前，先来看一下模板引擎编译出的 <code>C#</code> 代码示例，对于如下的模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Welcome, &#123;&#123;userName&#125;&#125;!&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;Products:&lt;&#x2F;p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for product in productList %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; product.Name &#125;&#125;:</span><br><span class="line">        &#123;&#123; product.Price|FormatPrice &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>模板引擎会生成类似于下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Render</span>(<span class="params">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; Context Context, Func&lt;<span class="built_in">object</span>, <span class="built_in">string</span>[], <span class="built_in">object</span>&gt; ResolveDots</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> userName = Context[<span class="string">&quot;userName&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> productList = Context[<span class="string">&quot;productList&quot;</span>];</span><br><span class="line">    result.AddRange(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123;<span class="string">&quot;&lt;p&gt;Welcome, &quot;</span>, Convert.ToString(userName), <span class="string">&quot;!&lt;/p&gt;&lt;p&gt;Products:&lt;/p&gt;&lt;ul&gt;&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> product <span class="keyword">in</span> <span class="title">ConvertToEnumerable</span>(<span class="params">productList</span>))</span> &#123;</span><br><span class="line">        result.AddRange(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123;<span class="string">&quot;&lt;li&gt;&quot;</span>, Convert.ToString(ResolveDots(product, <span class="keyword">new</span> [] &#123; <span class="string">&quot;Name&quot;</span> &#125;)), <span class="string">&quot;:&quot;</span>, Convert.ToString(FormatPrice(ResolveDots(product, <span class="keyword">new</span> [] &#123; <span class="string">&quot;Price&quot;</span> &#125;))), <span class="string">&quot;&lt;/li&gt;&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    result.Add(<span class="string">&quot;&lt;/ul&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="built_in">string</span>.Empty, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Context</code> 表示全局上下文，用于获取渲染需要的动态数据，例如例子中的 <code>userName</code>，<code>Render</code> 方法会先从 <code>Context</code> 中提取出模板中所有需要的变量；<code>ResolveDots</code> 是一个函数指针，用于执行点操作符调用；而变量的值都会通过 <code>Convert.ToString</code> 转为字符串。</p>
<p>模板引擎的最终产物是一个字符串，所以在 <code>Render</code> 中先使用一个 <code>List</code> 保存每一行的渲染结果，最后再将 <code>List</code> 转换为字符串。</p>
<p><code>.NET</code> 编译器提供了 <code>Microsoft.CodeAnalysis.CSharp.Scripting</code> 包来将某段字符串当做 <code>C#</code> 代码执行，所以最终模板引擎生成的代码将通过如下方式执行：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> code = <span class="string">&quot;some code&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> scriptOptions = ScriptOptions.Default.WithImports(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;System.Collections.Generic&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> script = CSharpScript.RunAsync(code, scriptOptions, yourCustomGlobals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script.Result.ReturnValue.ToString();</span><br></pre></td></tr></table></figure>
<h2 id="模板引擎编写"><a class="markdownIt-Anchor" href="#模板引擎编写"></a> 模板引擎编写</h2>
<h3 id="template"><a class="markdownIt-Anchor" href="#template"></a> Template</h3>
<p><code>Template</code> 是整个模板引擎的核心类，它首先通过模板和全局上下文初始化一个实例，然后调用 <code>Render</code> 方法来渲染模板：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;numbers&quot;</span>, <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> text = <span class="string">@&quot;&lt;ol&gt;&#123;% for number in numbers %&#125;&lt;li&gt;&#123;&#123; number &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ol&gt;&quot;</span>;</span><br><span class="line">Template template = <span class="keyword">new</span> Template(text, context);</span><br><span class="line"><span class="built_in">string</span> result = template.Render();</span><br></pre></td></tr></table></figure>
<p>这里将 <code>text</code> 传入 <code>Template</code> 的构造函数后，会在构造函数中完成模板解析，后续的 <code>Render</code> 调用都不需要再执行模板解析。</p>
<h3 id="codebuilder"><a class="markdownIt-Anchor" href="#codebuilder"></a> CodeBuilder</h3>
<p>在介绍 <code>Template</code> 的实现之前，需要先了解下 <code>CodeBuilder</code>，<code>CodeBuilder</code> 用于辅助生成 <code>C#</code> 代码，<code>Template</code> 通过 <code>CodeBuilder</code> 添加代码行，以及管理缩进（原文的作者使用 <code>Python</code> 作为编译的目标语言所以这里需要维护正确的缩进，<code>C#</code> 则不需要），并最终通过 <code>CodeBuilder</code> 得到可执行代码。</p>
<p><code>CodeBuilder</code> 内部维护了一个类型为 <code>List&lt;object&gt;</code> 的变量 <code>Codes</code> 来表示代码行，这里的 <code>List</code> 容器类型不是字符串是因为 <code>CodeBuilder</code> 间可以嵌套，一个 <code>CodeBuilder</code> 可以作为一个完整的逻辑单元添加到另一个 <code>CodeBuilder</code> 中，并最终通过自定义的 <code>ToString</code> 方法来生成可执行代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CodeBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> IndentStep = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        : <span class="title">this</span>(<span class="params"><span class="number">0</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBuilder</span>(<span class="params"><span class="built_in">int</span> indentLevel</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Codes = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">        <span class="keyword">this</span>.IndentLevel = indentLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="built_in">object</span>&gt; Codes</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> IndentLevel</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CodeBuilder</code> 的 <code>AddLine</code> 方法非常简单，即根据缩进层级补齐空格后添加一行代码（这里 <code>C#</code> 版本保留了 <code>Python</code> 版本缩进的功能）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddLine</span>(<span class="params"><span class="built_in">string</span> line</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.Codes.AddRange(<span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt; &#123; <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27; &#x27;</span>, <span class="keyword">this</span>.IndentLevel), line, <span class="string">&quot;\n&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Indent</code> 和 <code>Dedent</code> 用于管理 <code>Python</code> 代码的缩进层级：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Indent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IndentLevel += IndentStep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dedent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.IndentLevel -= IndentStep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AddSection</code> 用于创建一个新的 <code>CodeBuilder</code> 对象，并将其添加到当前 <code>CodeBuilder</code> 的代码行中，后续对子 <code>CodeBuilder</code> 的修改都会反应到父 <code>CodeBuilder</code> 中：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CodeBuilder <span class="title">AddSection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CodeBuilder section = <span class="keyword">new</span> CodeBuilder(<span class="keyword">this</span>.IndentLevel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.Codes.Add(section);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后重写了 <code>ToString()</code> 方法来生成可执行代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="built_in">string</span>.Empty, <span class="keyword">this</span>.Codes.Select(code =&gt; code.ToString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="template-实现"><a class="markdownIt-Anchor" href="#template-实现"></a> Template 实现</h3>
<h4 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h4>
<p>模板引擎的模板解析阶段发生在 <code>Template</code> 的构造函数中：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Template</span>(<span class="params"><span class="built_in">string</span> text, Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.Context = context;</span><br><span class="line">    <span class="keyword">this</span>.CodeBuilder = <span class="keyword">new</span> CodeBuilder();</span><br><span class="line">    <span class="keyword">this</span>.AllVariables = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">this</span>.LoopVariables = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.Initialize(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Python</code> 版本的代码支持多个 <code>context</code>，会由构造函数统一合并为一个上下文对象，这里只简单实现仅支持一个 <code>context</code>；<code>AllVariables</code> 用于记录模板 <code>text</code> 中需要用到的变量名，例如 <code>userName</code>，然后在代码生成阶段就可以遍历 <code>AllVariables</code> 并通过 <code>var someName = Context[someName];</code> 生成局部变量；不过由于模板中的变量可能还会有循环语句用到的临时变量，这些变量会记录到 <code>LoopVariables</code> 中，最终代码生成阶段用到的变量为 <code>AllVariables - LoopVariables</code>。</p>
<p>接着我们再来看 <code>Initialize</code> 方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">string</span> text</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="string">&quot;var result = new List&lt;string&gt;();&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> variablesSection = <span class="keyword">this</span>.CodeBuilder.AddSection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 text</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="built_in">string</span> variableName <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">HashSet</span>&lt;<span class="title">string</span>&gt;(<span class="params"><span class="keyword">this</span>.AllVariables.Except(<span class="keyword">this</span>.LoopVariables</span>)))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        variablesSection.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;var &#123;0&#125; = Context[&#123;1&#125;];&quot;</span>, variableName, <span class="keyword">this</span>.ConvertToStringLiteral(variableName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="string">&quot;return string.Join(string.Empty, result);&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Initialize</code> 首先会通过 <code>CodeBuilder</code> 分配一个 <code>List</code> 保存所有的代码行，然后新建一个子 <code>CodeBuilder</code> 来保存所有的局部变量，接着解析 <code>text</code>，在完成 <code>text</code> 的解析后就能知道模板中使用了哪些变量，从而根据 <code>AllVariables - LoopVariables</code> 生成局部变量，最后将所有的代码行转成字符串。</p>
<p>同时，原文作者在这里有一个优化，相比于在生成的代码中不断的调用 <code>result.Add(xxx)</code>，从性能上考虑可以将多个操作合并为一个即 <code>result.AddRange(new List&lt;string&gt; &#123; xxx &#125;)</code>，从而引出了辅助变量 <code>buffered</code> 和辅助方法 <code>FlushOutput</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffered = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlushOutput</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; buffered</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffered.Count == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;result.Add(&#123;0&#125;);&quot;</span>, buffered[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (buffered.Count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;result.AddRange(new List&lt;string&gt; &#123;&#123;&#123;0&#125;&#125;&#125;);&quot;</span>, <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, buffered)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffered.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析 <code>text</code> 时，并不会处理完一个 <code>token</code> 就执行一次 <code>this.CodeBuilder.AddLine</code>，而是将多个 <code>token</code> 的处理结果批量的追加到最终的可执行代码中。</p>
<p>接着，再回到 <code>Initialize</code> 方法中，由于模板中 <code>if</code>，<code>for</code> 可能存在嵌套，为了正确处理嵌套语句，这里引入一个栈 <code>var operationStack = new Stack&lt;string&gt;();</code> 来处理嵌套关系。例如，假设模板中存在 <code>&#123;% if xxx %&#125; &#123;% if xxx %&#125; &#123;% endif %&#125; &#123;% endif %&#125;</code>，每次遇到 <code>if</code> 时则执行入栈，遇到 <code>endif</code> 时则执行出栈，如果出栈时栈为空则说明 <code>if</code> 语句不完整，并抛出语法错误。</p>
<p>那么，如何解析 <code>text</code> 呢？这里使用正则表达式来将 <code>text</code> 分割为 <code>token</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Regex tokenPattern = <span class="keyword">new</span> Regex(<span class="string">&quot;(?s)(&#123;&#123;.*?&#125;&#125;|&#123;%.*?%&#125;|&#123;#.*?#&#125;)&quot;</span>, RegexOptions.Compiled);</span><br><span class="line"><span class="keyword">var</span> tokens = tokenPattern.Split(text);</span><br></pre></td></tr></table></figure>
<p>其中正则表达式中的 <code>(?s)</code> 使得 <code>.</code> 能够匹配换行符。</p>
<p>例如对于模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;&#123;% for number in numbers %&#125;&lt;li&gt;&#123;&#123; number &#125;&#125;&lt;&#x2F;li&gt;&#123;% endfor %&#125;&lt;&#x2F;ol&gt;</span><br></pre></td></tr></table></figure>
<p>分割后的 <code>tokens</code> 为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#39;&lt;ol&gt;&#39;,</span><br><span class="line">    &#39;&#123;% for number in numbers %&#125;&#39;,</span><br><span class="line">    &#39;&lt;li&gt;&#39;,</span><br><span class="line">    &#39;&#123;&#123; number &#125;&#125;&#39;,</span><br><span class="line">    &#39;&lt;&#x2F;li&gt;&#39;,</span><br><span class="line">    &#39;&#123;% endfor %&#125;&#39;,</span><br><span class="line">    &#39;&lt;&#x2F;ol&gt;&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后我们就可以遍历 <code>tokens</code> 处理了，每种 <code>token</code> 对应一种策略，如果是注释，则忽略：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (token.StartsWith(<span class="string">&quot;&#123;#&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是变量，则解析变量的表达式（表达式解析会在后面介绍）的值，然后再将其转为字符串：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token.StartsWith(<span class="string">&quot;&#123;&#123;&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> expression = <span class="keyword">this</span>.EvaluateExpression(token.Substring(<span class="number">2</span>, token.Length - <span class="number">4</span>).Trim());</span><br><span class="line"></span><br><span class="line">    buffered.Add(<span class="built_in">string</span>.Format(<span class="string">&quot;Convert.ToString(&#123;0&#125;)&quot;</span>, expression));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果是 <code>&#123;%</code> 则是最复杂的场景，需要对 <code>if</code> 和 <code>for</code> 分别处理，并结合 <code>operationStack</code> 判断是否存在语法错误：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token.StartsWith(<span class="string">&quot;&#123;%&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行 if，for 语句前先将 buffered 中的语句写到 CodeBuilder 中</span></span><br><span class="line">    <span class="keyword">this</span>.FlushOutput(buffered);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 &#123;% %&#125; 间的内容首尾去除空格后按照空格分割</span></span><br><span class="line">    <span class="keyword">var</span> words = token.Substring(<span class="number">2</span>, token.Length - <span class="number">4</span>).Trim().Split();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (words[<span class="number">0</span>] == <span class="string">&quot;if&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只支持 if xxx 的形式</span></span><br><span class="line">        <span class="keyword">if</span> (words.Length != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SyntaxError(<span class="built_in">string</span>.Format(<span class="string">&quot;Don&#x27;t understand if, token: &#123;0&#125;&quot;</span>, token));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈，表示 if 语句的开始，需要有对应的出栈</span></span><br><span class="line">        operationStack.Push(<span class="string">&quot;if&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if 条件也需要对表达式求值，C# 的 if 没有 Python 那么灵活，所以这里定义了一个 IsTure 方法来将表达式转为 bool 值</span></span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;if (IsTrue(&#123;0&#125;)) &#123;&#123;&quot;</span>, <span class="keyword">this</span>.EvaluateExpression(words[<span class="number">1</span>])));</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.Indent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (words[<span class="number">0</span>] == <span class="string">&quot;for&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只支持 for xxx in xxx 的形式</span></span><br><span class="line">        <span class="keyword">if</span> (words.Length != <span class="number">4</span> || words[<span class="number">2</span>] != <span class="string">&quot;in&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SyntaxError(<span class="built_in">string</span>.Format(<span class="string">&quot;Don&#x27;t understand for, token: &#123;0&#125;&quot;</span>, token));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈，表示 for 语句的开始，需要有对应的出栈</span></span><br><span class="line">        operationStack.Push(<span class="string">&quot;for&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录遇到的循环变量</span></span><br><span class="line">        <span class="keyword">this</span>.AddVariable(words[<span class="number">1</span>], <span class="keyword">this</span>.LoopVariables);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里定义了 ConvertToEnumerable 方法将循环的对象转为可迭代的对象，同时也需要对表达式求值</span></span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="built_in">string</span>.Format(<span class="string">&quot;foreach (var &#123;0&#125; in ConvertToEnumerable(&#123;1&#125;)) &#123;&#123;&quot;</span>, words[<span class="number">1</span>], <span class="keyword">this</span>.EvaluateExpression(words[<span class="number">3</span>])));</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.Indent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (words[<span class="number">0</span>].StartsWith(<span class="string">&quot;end&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (words.Length != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SyntaxError(<span class="built_in">string</span>.Format(<span class="string">&quot;Don&#x27;t understand end, token: &#123;0&#125;&quot;</span>, token));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> endWhat = words[<span class="number">0</span>].Substring(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有配对的开始语句</span></span><br><span class="line">        <span class="keyword">if</span> (operationStack.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SyntaxError(<span class="built_in">string</span>.Format(<span class="string">&quot;Too many ends, token: &#123;0&#125;&quot;</span>, token));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> startWhat = operationStack.Pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始和结束的语句不匹配，例如 if 以 endfor 结束</span></span><br><span class="line">        <span class="keyword">if</span> (startWhat != endWhat)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SyntaxError(<span class="built_in">string</span>.Format(<span class="string">&quot;Mismatched end tag, token: &#123;0&#125;&quot;</span>, token));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.AddLine(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.CodeBuilder.Dedent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后剩下的情况就按照单纯的字符串处理：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(token))</span><br><span class="line">    &#123;</span><br><span class="line">        buffered.Add(<span class="keyword">this</span>.ConvertToStringLiteral(token));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译表达式"><a class="markdownIt-Anchor" href="#编译表达式"></a> 编译表达式</h4>
<p>前面提到处理 <code>token</code> 时有时候需要对表达式求值，表达式分三种情况，第一种是管道流：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression.Contains(<span class="string">&quot;|&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pipes = expression.Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> code = <span class="keyword">this</span>.EvaluateExpression(pipes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> function <span class="keyword">in</span> pipes.ToList().GetRange(<span class="number">1</span>, pipes.Length - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        code = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;(&#123;1&#125;)&quot;</span>, function, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先根据 <code>|</code> 切分，数组的第一个元素是一个子表达式，递归调用即可；数组后面的元素表示的是要调用哪一个预定义的函数（要支持这些函数需要在最终生成的代码中有定义），例如 <code>FormatPrice</code>，本质上是个函数调用，直接拼接即可。</p>
<p>第二种是点操作符：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (expression.Contains(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> dots = expression.Split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> code = <span class="keyword">this</span>.EvaluateExpression(dots[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">var</span> arguments = dots.ToList().GetRange(<span class="number">1</span>, dots.Length - <span class="number">1</span>).Select(x =&gt; <span class="keyword">this</span>.ConvertToStringLiteral(x)).ToArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;ResolveDots(&#123;0&#125;, &#123;1&#125;)&quot;</span>, code, <span class="built_in">string</span>.Format(<span class="string">&quot;new [] &#123;&#123; &#123;0&#125; &#125;&#125;&quot;</span>, <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, arguments)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先按照 <code>.</code> 进行分割，数组的第一个元素是一个子表达式，递归调用即可；数组后面的元素作为一系列的链式点操作符调用的参数，交由辅助函数 <code>ResolveDots</code> 处理：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">object</span> <span class="title">ResolveDots</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, <span class="built_in">string</span>[] arguments</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> argument <span class="keyword">in</span> arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> members = <span class="keyword">value</span>.GetType().GetMember(argument);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Suppose there is only one member</span></span><br><span class="line">        <span class="keyword">var</span> member = members[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (member.MemberType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> MemberTypes.Property:</span><br><span class="line">                <span class="keyword">value</span> = ((PropertyInfo)member).GetValue(<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MemberTypes.Field:</span><br><span class="line">                <span class="keyword">value</span> = ((FieldInfo)member).GetValue(<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MemberTypes.Method:</span><br><span class="line">                <span class="keyword">value</span> = ((MethodInfo)member).Invoke(<span class="keyword">value</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TemplateRuntimeException(<span class="built_in">string</span>.Format(<span class="string">&quot;Unsupported member type &#123;0&#125;&quot;</span>, member.MemberType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResolveDots</code> 通过反射判断点操作符对应的是属性还是方法，继而执行相应的调用。</p>
<p>第三种就是单纯的变量，直接输出即可：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.AddVariable(expression, <span class="keyword">this</span>.AllVariables);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>以上就实现了一个简易的模板引擎，虽然还有很多高级的功能没有实现，但已足够作为一个引导式的教程。</p>
<p>完整的代码可参考原作者的 <a target="_blank" rel="noopener" href="https://github.com/aosabook/500lines/tree/master/template-engine/code">代码</a> 及 <code>C#</code> 版的 <a target="_blank" rel="noopener" href="https://github.com/read-and-code/SimpleTemplate">SimpleTemplate</a>。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://aosabook.org/en/500L/a-template-engine.html">A Template Engine</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/06/19/mit-6.824-spanner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/19/mit-6.824-spanner/" class="post-title-link" itemprop="url">MIT 6.824 - Spanner: Google’s Globally-Distributed Database</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-19T00:00:00+08:00">2022-06-19</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>32 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>Spanner</code> 是一个由 <code>Google</code> 设计，构建和部署的可扩展的全球分布式数据库。从高层次的抽象来看，作为一个数据库，<code>Spanner</code> 会将数据进行分片，每个分片构建在一组 <code>Paxos</code> 状态机之上，同时所有的数据存储在世界各地的各个数据中心内。<code>Spanner</code> 使用副本来保证数据库的全球可用性和客户端读取数据的就近访问性；客户端也能自动的在各个副本之间实现故障转移。当数据量或者服务器数量发生变化时，<code>Spanner</code> 能自动的跨服务器对数据进行重分区；同时，<code>Spanner</code> 也能自动的跨服务器（甚至是跨数据中心）迁移数据来应对负载均衡或者异常。<code>Spanner</code> 的扩展性能够支持上百个数据中心内的几百万台服务器，以及几万亿的数据行。</p>
<p>应用程序可以借助 <code>Spanner</code> 来确保高可用，即使是面对大面积的自然灾害，也可以通过将数据存储在单个大洲或者跨大洲的多个数据中心来保证容错。<code>Spanner</code> 的第一个客户是 <code>F1</code>，<code>F1</code> 是 <code>Google</code> 广告后端的一个重构项目。<code>F1</code> 的每份数据在美国境内存有5个副本。大部分其他的应用程序一般会将数据备份在同一个地理区域内的3到5个数据中心中，不过这在应对极端灾害时的容错性要略差一些。因为在能够容忍1到2个数据中心异常的情况下，大多数的应用程序相比于更进一步的高可用来说更看重低延迟。</p>
<p><code>Spanner</code> 设计的首要关注点是管理跨数据中心的数据副本，不过设计者依然在 <code>Google</code> 已有的分布式系统设施之上花了大量的时间来设计和实现某些重要的数据库特性。虽然 <code>Bigtable</code> 能满足很多项目的需求，不过依然有很多 <code>Bigtable</code> 的用户反馈在某些场景下 <code>Bigtable</code> 难以胜任：例如涉及复杂、不断改变的数据库模式；或者要求在大范围数据复制场景下保证强一致性。由于半关系型数据模型以及同步复制的特性，很多 <code>Google</code> 的应用选择使用 <code>Megastore</code> 来存储数据，尽管 <code>Megastore</code> 的写性能不是很好。因此，<code>Spanner</code> 从一个类似 <code>Bigtable</code> 的带版本号的键值存储演化为了一个基于时间戳的多版本数据库。<code>Spanner</code> 中的数据保存在半关系型的表中；每个数据存有多个版本，每个版本的数据都自动标记着提交时的时间戳；旧版本的数据可以根据可配置的垃圾回收策略进行回收；应用程序可以读取某个旧的时间戳下的数据。<code>Spanner</code> 支持通用的事务，以及提供了一个基于 <code>SQL</code> 的查询语言。</p>
<p>作为一个全球分布式数据库，<code>Spanner</code> 提供了几个有趣的特性。首先，应用程序能以合适的粒度动态的调控数据复制的配置。应用程序可以通过配置指定哪个数据中心保存什么样的数据，数据存储的位置距离终端用户有多远（控制读延迟），数据的各个副本间距离有多远（控制写延迟），每个数据要保存几个副本（控制持久性，可用性和读性能）。同时，系统可以动态和透明的在各个数据中心间迁移数据，从而在各数据中心间实现资源的均衡使用。第二，<code>Spanner</code> 实现了两个在分布式数据库中难以实现的功能：提供了外部一致性的读和写，以及在某个时间戳上跨全球数据库的一致性读。这些特性使得 <code>Spanner</code> 能够在全球多数据中心级别支持一致性备份，一致性的 <code>MapReduce</code> 任务执行，以及原子的数据库模式更新，即使执行这些操作时存在进行中的事务也没有关系。</p>
<p><code>Spanner</code> 通过对事务记录全球提交时间戳来实现上述特性，即使事务可能会被分布式的执行。事务的时间戳体现了串行顺序性。另外，这个串行顺序性满足外部一致性（或者相当于线性一致性）：如果某个事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在另一个事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>开始执行前完成提交，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳。<code>Spanner</code> 是第一个在全球数据中心级别保证这一特性的系统。</p>
<p>实现上述特性的关键点是一个全新的 <code>TrueTime</code> <code>API</code> 及其实现。这个 <code>API</code> 直接将时间的不确定性暴露给了使用方，而 <code>Spanner</code> 基于 <code>TrueTime</code> 提供的不确定性时间的范围（后面会提到 <code>TrueTime</code> 返回当前时间时不是返回一个单独的值，而是一个范围，<code>TrueTime</code> 会确保当前时间落在这个范围内）实现了事务的时间戳先后顺序保证。如果这个时间的不确定性范围太大，<code>Spanner</code> 会减缓操作来等待不确定性范围变小。<code>Google</code> 的集群管理软件提供了 <code>TrueTime</code> <code>API</code> 的一种实现。这个实现利用多个现代的基准时钟（<code>GPS</code> 和原子钟）能将时间不确定性控制在很小的一个范围内（一般来说小于10毫秒）。</p>
<h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2>
<p>本节描述了 <code>Spanner</code> 的结构及其底层实现。然后会再介绍目录（<code>directory</code>），和文件系统中的目录不同，<code>Spanner</code> 中的目录是一个抽象的概念，用于管理数据副本和访问局部性，同时也是数据迁移的最小单元。最后会介绍 <code>Spanner</code> 的数据模型，相比于键值数据库 <code>Spanner</code> 更像是个关系型数据库，以及描述了应用程序如何控制数据的存储位置来实现访问局部性。</p>
<p>一个 <code>Spanner</code> 的完整部署被称之为 <code>universe</code>。因为 <code>Spanner</code> 在全球级别的数据中心管理数据，所以一共只会有几个运行中的 <code>universe</code>。<code>Google</code> 目前运行了一个测试/体验环境的 <code>universe</code>，一个开发/生产环境的 <code>universe</code>，以及一个仅生产环境的 <code>universe</code>。</p>
<p>一个 <code>Spanner</code> 实例以一组 <code>zone</code> 的形式来组织，每个 <code>zone</code> 差不多等同于部署了一批 <code>Bigtable</code> 服务器。每个 <code>zone</code> 是一个可管理的部署单元。系统在各个 <code>zone</code> 之间进行数据复制。当上线或者下线数据中心时，可以向运行中的系统添加或者删除 <code>zone</code>。<code>zone</code> 也是物理隔离的单位：一个数据中心内可能有1个或者多个 <code>zone</code>，例如不同应用程序的数据需要分片到同一个数据中心内的不同服务器上。</p>
<p><img src="/images/spanner-1.png" alt="alt" /></p>
<p>上图展示了 <code>Spanner</code> 的一个 <code>universe</code> 中各服务器的职责。每个 <code>zone</code> 有一个 <code>zonemaster</code> 和成百上千台 <code>spanserver</code>。<code>zonemaster</code> 向 <code>spanserver</code> 分发数据，<code>spanserver</code> 向客户端提供数据服务。同时，客户端通过每个 <code>zone</code> 内的 <code>location proxy</code> 来确定需要访问哪台 <code>spanserver</code> 获取数据。<code>universe master</code> 和 <code>placement driver</code> 目前是单点的。<code>universe master</code> 主要是一个控制台，用于展示所有 <code>zone</code> 的状态信息，从而方便调试。<code>placement driver</code> 负责自动的在各个 <code>zone</code> 之前进行数据迁移，这个的操作耗时一般是分钟级。出于满足数据副本数量的要求以及实现数据访问的负载均衡，<code>placement driver</code> 会周期性的和 <code>spanserver</code> 通信从而确认哪些数据需要迁移。出于篇幅考虑，论文只会描述 <code>spanserver</code> 的实现细节。</p>
<h3 id="spanserver-软件栈"><a class="markdownIt-Anchor" href="#spanserver-软件栈"></a> Spanserver 软件栈</h3>
<p><img src="/images/spanner-2.png" alt="alt" /></p>
<p>本节主要关注 <code>spanserver</code> 的实现并展示了如何在 <code>Bigtable</code> 的实现之上构建数据复制和分布式事务。上图展示了 <code>spanserver</code> 的软件栈。在底部，每个 <code>spanserver</code> 负责管理100到1000个被称之为 <code>tablet</code> 的数据结构实例。<code>tablet</code> 类似于 <code>Bigtable</code> 中表的抽象，其内部维护了如下的映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key:string, timestamp:int64) -&gt; string</span><br></pre></td></tr></table></figure>
<p>和 <code>Bigtable</code> 不同的是，<code>Spanner</code> 给每一个数据都标记了时间戳，从而使得 <code>Spanner</code> 更像是一个多版本数据库而不是键值存储。每个 <code>tablet</code> 的状态会保存在一组类似 <code>B</code> 树的文件以及一个预写日志中，所有的文件都会保存在一个称之为 <code>Colossus</code>（<code>Google File System</code> 的后继者）的分布式文件系统中。</p>
<p>为了支持数据复制，每个 <code>spanserver</code> 在每个 <code>tablet</code> 之上构建了一个单 <code>Paxos</code> 状态机（<code>Spanner</code> 的早期设计支持每个 <code>tablet</code> 对应多个 <code>Paxos</code> 状态机，这能支持更灵活的复制配置。不过由于这种设计的复杂性作者最终放弃了）。每个状态机将其元数据和日志保存到对应的 <code>tablet</code> 中。<code>Spanner</code> 的 <code>Paxos</code> 实现支持长期存活的主节点，每个主节点会分配一个基于时间的租约，租期的默认长度是10秒。当前 <code>Spanner</code> 的实现会记录两次 <code>Paxos</code> 的写操作，一次是在 <code>tablet</code> 的日志中，另一次是在 <code>Paxos</code> 的日志中。不过这个目前只是权宜之计，可能会在未来修复。<code>Spanner</code> 的 <code>Paxos</code> 实现能以管道的方式执行，因此在 <code>WAN</code> 环境的延迟下能提高 <code>Spanner</code> 的吞吐；不过提交到 <code>Paxos</code> 的写操作会按照顺序执行。</p>
<p><code>Spanner</code> 借助 <code>Paxos</code> 状态机实现了一致性的数据映射复制。每个副本的键值映射状态都会保存在相应的 <code>tablet</code> 中。客户端的写操作必须由主节点发起 <code>Paxos</code> 协议；而读操作可以由任意一个有着最新数据的副本执行。这些副本构成了一个 <code>Paxos group</code>。</p>
<p>对于身为主节点的副本来说，每个 <code>spanserver</code> 实现了一个锁表（<code>lock table</code>）来实现并发控制。锁表包含了两阶段锁的状态：它会将某个范围内的键和锁的状态建立映射（长期存活的主节点是高效管理锁表的关键）。在 <code>Bigtable</code> 和 <code>Spanner</code> 中，锁表都是专门为长时间运行的事务设计的（例如，对于报表生成这样的事务可能需要花费分钟级的时间才能完成），但在锁竞争激烈的情况下使用乐观并发控制策略会造成性能不佳。诸如事务读这样需要同步的操作需要先从锁表中获取锁；其他不涉及同步的操作则无需操作锁表。</p>
<p>对于身为主节点的副本来说，每个 <code>spanserver</code> 实现了一个事务管理器（<code>transaction manager</code>）来支持分布式事务。事务管理器被用来实现 <code>participant leader</code>；而其他同 <code>Paxos</code> 组内的副本则被称为 <code>participant slaves</code>。如果一个事务只涉及一个 <code>Paxos</code> 组（对于大多数的事务来说），则无需事务管理器介入，因为锁表和 <code>Paxos</code> 一起已经提供了事务功能。如果一个事务涉及多个 <code>Paxos</code> 组，则每个组的主节点需要协同完成两阶段提交。其中某个 <code>Paxos</code> 组会被选为协调者：该组的 <code>participant leader</code> 则会担任 <code>coordinator leader</code>，该组内其他的从节点则担任 <code>coordinator slaves</code>。事务管理器的状态会保存在底层的 <code>Paxos</code> 组中（因此这个状态数据也会存有多个副本）。</p>
<h3 id="目录和数据放置"><a class="markdownIt-Anchor" href="#目录和数据放置"></a> 目录和数据放置</h3>
<p>在键值映射之上，<code>Spanner</code> 的实现支持被称为目录（<code>directory</code>）的桶的抽象，目录是一组有着公共前缀的连续键的集合（命名为目录是由于历史的偶然；一个更好的命名可能是桶（<code>bucket</code>））。目录的支持使得应用程序可以通过设置合适的键来控制数据访问的局部性。</p>
<p>一个目录是数据放置的最小单元。每个目录下的所有数据有着相同的复制配置。数据以目录的形式从一个 <code>Paxos</code> 组迁移到另一个 <code>Paxos</code> 组，下图描述了这个过程。<code>Spanner</code> 可能会移动一个目录来减轻某个 <code>Paxos</code> 组的负载；或者将经常被同时访问的多个目录移动到同一个 <code>Paxos</code> 组中；或者将某个目录移动到距离客户端更近的 <code>Paxos</code> 组中。目录的移动可以和客户端的操作同时进行。一个 <code>50 MB</code> 大小的目录可以在几秒内完成。</p>
<p><img src="/images/spanner-3.png" alt="alt" /></p>
<p>一个 <code>Paxos</code> 组可能会包含多个目录说明 <code>Spanner</code> 的 <code>tablet</code> 和 <code>Bigtable</code> 的 <code>tablet</code> 不同：<code>Spanner</code> 的 <code>tablet</code> 没有必要是行空间（<code>row space</code>）内按照字典顺序的连续分区。相反，一个 <code>Spanner</code> 的 <code>tablet</code> 可能包含了行空间的多个分区。正是基于此特性才使得多个同时被访问的目录可以被移动到同一个 <code>Paxos</code> 组中。下图展示了各组成部分间的关系：</p>
<p><img src="/images/spanner-4.png" alt="alt" /></p>
<p><code>Spanner</code> 使用 <code>Movedir</code> 这样的后台任务在多个 <code>Paxos</code> 组之间移动目录。<code>Movedir</code> 也被用来向 <code>Paxos</code> 组中添加或者删除副本，因为目前 <code>Spanner</code> 还不支持在 <code>Paxos</code> 内部实现配置变更。<code>Movedir</code> 没有被设计为一个独立的事务，这主要是为了避免在进行大量数据移动时阻塞读写请求。相反，<code>movedir</code> 会在后台开始迁移数据。当 <code>movedir</code> 完成数据迁移，但还剩下一小部分数据未迁移时，则会发起一个事务自动的完成数据的迁移，然后更新涉及的两个 <code>Paxos</code> 组的元数据。</p>
<p>目录是应用程序能够控制副本的地理位置属性（或者简单来说，数据放置）的最小单位。在 <code>Spanner</code> 的设计中，数据放置规范语言（<code>placement-specification language</code>）和管理副本配置的职责相解耦。管理员可以控制两个维度：副本的数量和类型，以及副本所在的地理位置属性。<code>Spanner</code> 为这两个维度提供了可选的选项（例如，<code>North America, replicated 5 ways with 1 witness</code>）。应用程序通过标记每个数据库和/或者单个目录的复制选项组合来控制数据的复制。例如，某个应用程序可能会将每个终端用户的数据保存在自己的目录中，从而使得用户 <code>A</code> 的数据在欧洲有三个副本，用户 <code>B</code> 的数据在北美有5个副本。</p>
<p>出于表达清晰的考虑作者简化了这块的描述。实际上，如果某个目录包含的数据过多，<code>Spanner</code> 会将其拆分为多个段（<code>fragment</code>）。不同的段会由不同的 <code>Paxos</code> 组提供服务（也对应了不同的服务器）。<code>Movedir</code> 实际上是在各个 <code>Paxos</code> 组之间移动段，而不是整个目录。</p>
<h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3>
<p><code>Spanner</code> 为应用程序提供了如下的数据特性：一个基于模式化半关系型表的数据模型，一个查询语言，以及通用型事务。之所以要支持这些特性是受几方面的驱动。支持模式化半关系型表和同步复制的需求来自于 <code>Megastore</code> 的流行。至少有300个 <code>Google</code> 内部的应用程序选择使用 <code>Megastore</code>（尽管它的性能不是很好），因为它的数据模型比 <code>Bigtable</code> 更简单，而且它也支持跨数据中心的同步数据复制（<code>Bigtable</code> 只支持跨数据中心数据复制的最终一致性）。使用 <code>Megastore</code> 的 <code>Google</code> 应用程序中比较有名的有 <code>Gmail</code>，<code>Picasa</code>，<code>Calendar</code>，<code>Android Market</code> 和 <code>AppEngine</code>。在 <code>Spanner</code> 中支持类似 <code>SQL</code> 的查询语言的需求同样很明确，因为交互式数据分析工具 <code>Dremel</code> 也很流行。最后，希望 <code>Bigtable</code> 支持跨行的事务的呼声也很强烈；开发 <code>Percolator</code> 的部分原因就是为了解决这个问题。某些作者认为通用的两阶段提交的支持成本太大，因为它存在性能和可用性问题。不过，<code>Spanner</code> 的作者认为最好交给应用开发人员来处理由于过度使用事务而产生的性能瓶颈，而不是始终在缺少事务的环境下编程。而在 <code>Paxos</code> 之上实现两阶段提交则减缓了可用性问题。</p>
<p>应用程序的数据模型构建在目录式的键值数据映射之上。一个应用程序会在一个 <code>universe</code> 中创建一个或者多个数据库。每个数据库可以包含不限制数量的模式化表。<code>Spanner</code> 的表类似于关系型数据库中的表，它同样有行，列，以及带版本的值。本文不会深入探讨 <code>Spanner</code> 的查询语言。它和 <code>SQL</code> 很像不过在这基础之上多了些扩展来支持 <code>protocol-buffer</code> 类型的字段。</p>
<p><code>Spanner</code> 的数据模型不是纯关系型的，它的行必须有名称。更准确的来说，每张表需要有一个或者多个主键列组成的有序集合。这个要求使得 <code>Spanner</code> 看起来像一个键值存储：主键定义了每行的名称，每个表定义了主键列到非主键列的映射。只有某个主键对应有值（即使值是 <code>NULL</code>）才能被认为某一行存在。采用这个结构使得应用程序能通过选择键来控制数据访问的局部性。</p>
<p><img src="/images/spanner-5.png" alt="alt" /></p>
<p>上图展示了 <code>Spanner</code> 数据模式的一个示例，在这个例子中，我们创建了两张表来存储每个用户和每张照片的元数据。<code>Spanner</code> 的模式语言和 <code>Megastore</code> 类似，不过 <code>Spanner</code> 有额外的要求，<code>Spanner</code> 的每个数据库必须由客户端分区为一个或者多个层次化的表。客户端程序通过 <code>INTERLEAVE IN</code> 来声明数据库模式的层次化结构。位于层次化结构顶端的表被称之为 <code>directory table</code>。<code>directory table</code> 中以 <code>K</code> 为键的数据，和关联的子孙表中所有键以 <code>K</code> 为起始的行按照字典顺序组成了一个目录。<code>ON DELETE CASCADE</code> 表明如果删除了 <code>directory table</code> 中的一条数据，则需要一并删除关联的子孙表中的数据。上图也展示了示例数据库的交错结构（<code>interleaved layout</code>）：例如，<code>Albums(2, 1)</code> 表示 <code>Albums</code> 表中 <code>user_id</code> 为2，<code>album_id</code> 为1的数据。这种由交错的表组成的目录对于客户端来说非常重要，因为它使得客户端能够描述不同的表之间的局部性关联，这对于分片、分布式的数据库的高性能来说非常重要。如果缺少这个特性，<code>Spanner</code> 将无从知晓最重要的局部性关联。</p>
<h2 id="truetime"><a class="markdownIt-Anchor" href="#truetime"></a> TrueTime</h2>
<p>本节主要描述 <code>TrueTime</code> 的 <code>API</code> 及概述其实现。<code>TrueTime</code> 大部分的细节会在另一篇论文中描述，本文主要是展示它对于 <code>Spanner</code> 的重要性。下表列举了 <code>TrueTime</code> 的 <code>API</code>。<code>TrueTime</code> 以 <code>TTinterval</code> 的形式表示时间，<code>TTinterval</code> 是一段表示非确定性时间的有界区间（而标准时间接口并不会将时间的不确定性暴露给客户端）。<code>TTinterval</code> 两个端点值的类型为 <code>TTstamp</code>。<code>TT.now()</code> 会返回一个 <code>TTinterval</code>，并且保证 <code>TTinterval</code> 所表示的时间区间一定包含 <code>TT.now()</code> 被调用时的绝对时间。这个时间类似于带闰秒的 <code>UNIX</code> 时间。定义时间的瞬时误差上限为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>，其值为 <code>TTinterval</code> 区间长度的一半，以及定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">ˉ</span></span></span></span></span></span></span></span></span>为平均误差上限。<code>TT.after()</code> 和 <code>TT.before()</code> 是基于 <code>TT.now()</code> 的更易用的封装。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td>TT.now()</td>
<td>TTinterval: [earliest, latest]</td>
</tr>
<tr>
<td>TT.after(t)</td>
<td>true if t has definitely passed</td>
</tr>
<tr>
<td>TT.before(t)</td>
<td>true if t has definitely not arrived</td>
</tr>
</tbody>
</table>
<p>记某个事件 <code>e</code> 发生的绝对时间为函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{abs}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span>。那么以更正式的术语来说，<code>TrueTime</code> 保证对于某次调用 <code>tt = TT.now()</code>，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo>≤</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>e</mi><mrow><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msub><mo stretchy="false">)</mo><mo>≤</mo><mi>t</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">tt.earliest \leq t_{abs}(e_{now}) \leq tt.latest</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mrow><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">e_{now}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是调用 <code>TT.now()</code> 的事件。</p>
<p><code>TrueTime</code> 底层使用的时间参照是 <code>GPS</code> 和原子钟。<code>TrueTime</code> 使用两种形式的时间参照是因为它们有着不同的异常模式。<code>GPS</code> 发生异常可能是由于天线或者接收器异常，本地电磁波干扰，某些关联异常（例如设计的缺陷造成无法正确处理闰秒和电子欺骗），以及 <code>GPS</code> 系统瘫痪。原子钟的异常模式和 <code>GPS</code> 无关，不过在经过很长一段时间后可能会因为频率误差造成严重的精度缺失。</p>
<p><code>TrueTime</code> 的实现由每个数据中心中的一组 <code>time master</code> 机器完成，每个机器上存在一个 <code>timeslave</code> 守护进程。大多数的 <code>time master</code> 安装了具有专用天线的 <code>GPS</code> 接收器；这些机器在物理上相互隔离，从而降低天线异常，电磁波干扰和电子欺骗的影响。剩下的 <code>time master</code>（被称之为 <code>Armageddon masters</code>）则配有原子钟。一个原子钟并不是太昂贵；一个 <code>Armageddon master</code> 的成本和一个 <code>GPS master</code> 的成本相当。各个 <code>time master</code> 会定期的互相对比各自的参照时间。每个 <code>time master</code> 也会对比自己的参照时间和本地时钟，如果两者相差过大则该 <code>time master</code> 会退出集群。在时钟同步期间，<code>Armageddon masters</code> 会保守的根据最差情况的时钟漂移来逐渐增加时间的不确定性。<code>GPS masters</code> 的时间不确定性误差一般接近于0。</p>
<p>每个 <code>timeslave</code> 守护进程会拉取多个 <code>time master</code> 的参照时间来减少单个 <code>time master</code> 异常造成的时间误差。<code>timeslave</code> 轮询的 <code>time master</code> 一部分来自于就近数据中心的 <code>GPS master</code>；剩下的来自于更远的数据中心的 <code>GPS master</code> 以及一些 <code>Armageddon master</code>。获取到其他 <code>time master</code> 的参照时间后，<code>timeslave</code> 守护进程会通过一种 <code>Marzullo</code> 算法的变种来识别出不可信的值，然后根据可信的值同步本地时钟。为了避免异常的本地时钟造成影响，如果某个机器的时钟误差频繁超过组件规范和工作环境下的误差上限，则该机器会从集群中剔除。</p>
<p>在时钟同步期间，<code>timeslave</code> 守护进程也会逐渐增加时间的不确定性。记<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>表示保守最差情况下的本地时钟偏移。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>的值同时也依赖 <code>time master</code> 的不确定性以及和 <code>time master</code> 的通信延迟。在 <code>Google</code> 的生产环境中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>呈现出随时间变化的锯齿形函数，在每次轮询 <code>time master</code> 间隔间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>的值在1到7毫秒内浮动。因此在大多数时间里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">ˉ</span></span></span></span></span></span></span></span></span>的值为4毫秒。当前 <code>timeslave</code> 守护进程轮询 <code>time master</code> 的时间间隔为30秒，以及时钟漂移速率为200微妙/秒，最后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>的浮动范围为0到6毫秒。而剩下的1毫秒则来源于和 <code>time master</code> 的通信延迟。当发生异常时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>的偏移范围超过7毫秒也是有可能的。例如，有时候 <code>time master</code> 的不可用会造成数据中心范围内<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>值的增加。类似的，服务器过载以及网络链路异常也有可能造成局部范围内<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>的值产生毛刺。</p>
<h2 id="并发控制"><a class="markdownIt-Anchor" href="#并发控制"></a> 并发控制</h2>
<p>本节描述了 <code>Spanner</code> 如何使用 <code>TrueTime</code> 来保证并发控制下的正确性特性，以及如何利用这些正确性特性来实现诸如外部一致性事务，无锁只读事务以及非阻塞式的读取旧数据。例如要在某个时间戳 <code>t</code> 对整个数据库做一次审计读取操作，则借助这些特性可以保证这次操作一定能够读取到在时间戳 <code>t</code> 之前已经提交的事务修改。</p>
<p>另外，将 <code>Paxos</code> 的写操作（除非上下文明确的情况下，后续此操作都被称之为 <code>Paxos writes</code>）和 <code>Spanner</code> 的客户端的写操作区分开非常重要。例如，两阶段提交场景下 <code>Paxos</code> 会在准备阶段执行写操作，这个写操作没有任何相关联的客户端写操作。</p>
<h3 id="时间戳管理"><a class="markdownIt-Anchor" href="#时间戳管理"></a> 时间戳管理</h3>
<p>下表列举了 <code>Spanner</code> 支持的操作类型。<code>Spanner</code> 支持读写事务（<code>read-write transactions</code>），只读事务（<code>read-only transactions</code>）（预先声明的快照隔离事务（<code>snapshot-isolation transactions</code>）），和快照读（<code>snapshot reads</code>）。单独的写事务由读写事务实现；单独的非快照读由只读事务实现。两者都会在实现内部执行重试（因此客户端无需编写自己的重试逻辑）。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Timestamp Discussion</th>
<th>Concurrency Control</th>
<th>Replica Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read-Write Transaction</td>
<td>Section 4.1.2</td>
<td>pessimistic</td>
<td>leader</td>
</tr>
<tr>
<td>Read-Only Transaction</td>
<td>Section 4.1.4</td>
<td>lock-free</td>
<td>leader for timestamp; any for read, subject to section 4.1.3</td>
</tr>
<tr>
<td>Snapshot Read, client-provided timestamp</td>
<td>——</td>
<td>lock-free</td>
<td>any, subject to section 4.1.3</td>
</tr>
<tr>
<td>Snapshot Read, client-provided bound</td>
<td>Section 4.1.3</td>
<td>lock-free</td>
<td>any, subject to section 4.1.3</td>
</tr>
</tbody>
</table>
<p>只读事务借助了快照隔离从而有着较好的性能。一个只读事务必须事先声明为不包含任何写操作；它并不简单是一个没有写操作的读写事务。系统会为只读事务选择一个时间戳从而能够以无锁的方式读取以该时间戳为基准的数据，因此也不会阻塞接下来的写操作。只读事务中的读操作可以由任何有着足够新的数据的副本执行。</p>
<p>快照读指的是读取过去的数据因此也无需加锁。客户端可以为快照读指定一个时间戳或者指定一个期望时间戳的上限，然后由 <code>Spanner</code> 选择一个时间戳。不管在哪种情况下，快照读可以由任何有着足够新的数据的副本执行。</p>
<p>对于只读事务和快照读来说，一旦确定了时间戳事务的提交就不可避免了，除非该时间戳对应的数据已经被垃圾回收了。因此，客户端可以避免在重试循环中缓冲结果。当某个服务器异常时，客户端可以在另一台服务器上重新以期望的时间戳和当前的数据读取位置继续执行查询操作。</p>
<h4 id="paxos-主节点租约"><a class="markdownIt-Anchor" href="#paxos-主节点租约"></a> Paxos 主节点租约</h4>
<p><code>Spanner</code> 的 <code>Paxos</code> 实现使用了基于时间的租约来确保某个主节点长期存活（租期默认是10秒）。主节点的候选者会向其他节点发送请求来获取基于时间的租约投票（<code>lease votes</code>）；当该候选者收到大多数的选票后就知道自己持有了租约。当某个副本成功的执行写入后会同时延长租约选票，而对于主节点来说则会在租期快过期前发起延长租约选票的请求。定义某个主节点的租期区间（<code>lease interval</code>）始于获取了大多数的选票，终于不再持有大多数的选票（因为某些选票已过期）。<code>Spanner</code> 依赖如下的不相交不变式（<code>disjointness invariant</code>）：对于每个 <code>Paxos</code> 组来说，每个 <code>Paxos</code> 主节点的租期区间都和任意其他主节点的租期区间不相交。</p>
<p><code>Spanner</code> 的实现允许某个 <code>Paxos</code> 主节点通过释放从节点的选票来主动发起主节点退位。为了维持不相交不变式（<code>disjointness invariant</code>），<code>Spanner</code> 会限制在什么情况下才能发起主节点退位。定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示某个主节点使用的最大时间戳。后面章节会描述什么时候<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>会增加。因此，某个主节点只有等到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>T</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TT.after(s_{max})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为真时才能发起退位。</p>
<h4 id="为读写事务分配时间戳"><a class="markdownIt-Anchor" href="#为读写事务分配时间戳"></a> 为读写事务分配时间戳</h4>
<p>读写事务需要用到两阶段锁。因此，<code>Spanner</code> 可以在获取所有锁之后，释放任意锁之前为事务分配时间戳。对于某个给定的事务来说，<code>Spanner</code> 会以 <code>Paxos</code> 的写操作的时间戳作为事务的提交时间戳。</p>
<p><code>Spanner</code> 依赖如下的单调不变式（<code>monotonicity invariant</code>）：在每个 <code>Paxos</code> 组内，即使是多个不同的主节点之间，<code>Spanner</code> 分配给 <code>Paxos</code> 写操作的时间戳都是单调递增的。对于单个主节点来说，分配单调递增的时间戳没有什么困难。<code>Spanner</code> 通过不相交不变式（<code>disjointness invariant</code>）确保了在多个不同的主节点之间也能保证单调不变式（<code>monotonicity invariant</code>）：每个主节点只能分配位于任期区间内的时间戳。每当主节点分配了一个时间戳 <code>s</code>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（某个主节点使用的最大时间戳）都会更新为 <code>s</code> 来确保不相交不变式（<code>disjointness invariant</code>）。</p>
<p><code>Spanner</code> 同时也保证了如下的外部一致性不变式（<code>external-consistency invariant</code>）：如果某个事务 <code>T2</code> 的开始时间晚于事务 <code>T1</code> 的提交时间，则 <code>T2</code> 的提交时间戳一定大于 <code>T</code> 的提交时间戳。定义事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的开始和提交事件为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05222em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{commit}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0833279999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>；事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则有不变式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>1</mn><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>s</mi><mn>1</mn><mo>&lt;</mo><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t_{abs}(e_1^{commit}) &lt; t_{abs}(e_2^{start}) \implies s1 &lt; s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043556em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>。<code>Spanner</code> 中执行事务和分配时间戳的协议遵循了如下的两条规则，从而确保了上述的不变式。定义两阶段提交协议的 <code>coordinator leader</code> 针对某个写操作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发起提交请求对应的事件为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{server}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>。则 <code>Spanner</code> 遵循的两条规则为：</p>
<ul>
<li>开始（<code>Start</code>）：在事件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">e_i^{server}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>之后，两阶段提交协议的 <code>coordinator leader</code> 分配给某个写事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的提交时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不会小于 <code>TT.now().latest</code>。注意 <code>participant leaders</code> 在这一阶段不会参与；4.2.1节会介绍在实现提交等待（<code>Commit Wait</code>）规则时 <code>participant leaders</code> 的职责。</li>
<li>提交等待（<code>Commit Wait</code>）：两阶段提交协议的 <code>coordinator leader</code> 会确保在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>T</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>f</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TT.after(s_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>返回真之前客户端不会读取到事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>提交的数据。提交等待（<code>Commit wait</code>）确保了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一定小于事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>提交的绝对时间，或者说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mi>i</mi><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s_i &lt; t_{abs}(e_i^{commit})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0833279999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。4.2.1节会描述提交等待（<code>Commit wait</code>）的实现。其证明如下：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>s</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>1</mn><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi><mtext> </mtext><mi>w</mi><mi>a</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>1</mn><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo stretchy="false">)</mo><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>t</mi><mrow><mi>a</mi><mi>b</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>e</mi><mn>2</mn><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><msub><mi>s</mi><mn>2</mn></msub><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>s</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&lt;</mo><msub><mi>s</mi><mn>2</mn></msub><mspace width="2em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
s_1 &amp;&lt; t_{abs}(e_1^{commit}) \qquad&amp; (commit \, wait) \\
t_{abs}(e_1^{commit}) &amp;&lt; t_{abs}(e_2^{start}) \qquad&amp; (assumption) \\
t_{abs}(e_2^{start}) &amp;\le t_{abs}(e_2^{server}) \qquad&amp; (causality) \\
t_{abs}(e_2^{server}) &amp;\le s_2 \qquad&amp; (start) \\
s_1 &amp;&lt; s_2 \qquad&amp; (transitivity)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.572883999999999em;vertical-align:-3.536441999999999em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.036442em;"><span style="top:-6.161778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.627114000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.123558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435559999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-1.623558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-0.12355800000000094em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.536441999999999em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.036442em;"><span style="top:-6.161778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-4.627114000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435559999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-3.123558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-1.623558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span></span></span><span style="top:-0.12355800000000094em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.536441999999999em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.036442em;"><span style="top:-6.161778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span><span style="top:-4.627114000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.123558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-1.623558000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span><span style="top:-0.12355800000000094em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.536441999999999em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="根据某个时间戳读"><a class="markdownIt-Anchor" href="#根据某个时间戳读"></a> 根据某个时间戳读</h4>
<p>4.1.2节描述的单调不变式（<code>monotonicity invariant</code>）使得 <code>Spanner</code> 能正确的判断某个副本的状态是否足够满足某个客户端的读请求。每个副本都会记录一个称之为安全时间（<code>safe time</code>）的变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，这表示当前副本拥有到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为止所有已提交事务的修改。因此，只要客户端希望读取的数据的时间戳 <code>t</code> 满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>≤</mo><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t \leq t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，则当前副本就能够提供读操作。</p>
<p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{safe} = min(t_{safe}^{Paxos}, t_{safe}^{TM})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>表示每个 <code>Paxos</code> 状态机的安全时间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>表示每个事务管理器的安全时间。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的实现很简单：它的值等于最近一次提交的 <code>Paxos</code> 的写操作的时间戳。因为 <code>Spanner</code> 会以单调递增的顺序分配时间戳，加上 <code>Paxos</code> 会按顺序应用写操作，因此某个写入操作一定不会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>或其之前发生。</p>
<p>当不存在完成了准备阶段（但事务还未提交）的事务时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>——即两阶段提交协议中已完成准备阶段，但还未完成提交阶段的场景（对于 <code>participant slave</code> 来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>指向的是该副本所属主节点的事务管理器的安全时间，从节点可根据主节点下发的写请求中的元数据推断而来）。如果存在这样的事务，则受这些事务影响的状态是不确定的：因为对于 <code>participant replica</code> 来说并不知道这些事务最终是否会被提交。在4.2.1节会介绍，<code>Spanner</code> 的提交协议确保了每个 <code>participant</code> 能知道某个已准备完成的事务的时间戳的下界。每个 <code>participant leader</code>（对应某个 <code>Paxos</code> 组 <code>g</code>）会为某个事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在准备阶段的日志中记录一个时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">s_{i, g}^{prepare}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>。<code>coordinator leader</code> 会确保对于组 <code>g</code> 中的每一个事务的参与者来说，事务的提交时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>≥</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">s_i \geq s_{i, g}^{prepare}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>。因此，对于组 <code>g</code> 中的每个副本来说，在组 <code>g</code> 内完成准备阶段的所有事务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_{safe}^{TM} = min_i(s_{i, g}^{prepare}) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<h4 id="为只读事务分配时间戳"><a class="markdownIt-Anchor" href="#为只读事务分配时间戳"></a> 为只读事务分配时间戳</h4>
<p>只读事务会有两阶段来执行：首先会分配一个时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后以快照读的方式来执行读取时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>处的数据。快照读可以由任何有着足够新的数据的副本执行。</p>
<p>可以简单的选取 <code>TT.now().latest</code> 作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值，则类似于4.1.2节中关于写事务的描述，就一定能读取到在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之前提交的事务修改。然而，如果客户端读取的副本的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>还没有更新（从系统层面来看，某个在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之前提交的事务已执行成功，但当前副本并不一定知道这个信息），为了不破坏外部一致性，避免客户端读取到旧的数据，则可能需要阻塞客户端的读取直到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>更新完成（另外，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的选取也会导致<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的更新来确保不相交不变式（<code>disjointness invariant</code>））。为了减少阻塞的可能，<code>Spanner</code> 需要选取满足外部一致性前提下最老的时间戳。4.2.2节会介绍如何选取这个时间戳。</p>
<h3 id="细节"><a class="markdownIt-Anchor" href="#细节"></a> 细节</h3>
<p>本节会描述读写事务和之前介绍只读事务时省略的实现细节，以及某种特殊的事务类型实现用来支持原子的模式修改。然后会再描述某些对基础方案的改进。</p>
<h4 id="读写事务"><a class="markdownIt-Anchor" href="#读写事务"></a> 读写事务</h4>
<p>类似于 <code>Bigtable</code>，在某个事务提交前，其写操作会在客户端中缓冲。因此，某个事务中的读操作不会读取到同一个事务中的写操作。这个设计能很好的适配 <code>Spanner</code>，因为读取操作会返回被读取数据的时间戳，而未提交的写操作还未被分配时间戳。</p>
<p>读写事务中的读操作会使用 <code>wound-wait</code> 来避免死锁。客户端向主节点发起读操作，主节点会获取相应的锁然后读取最新的数据。当客户端的事务还在进行中时，它会定期的发送消息来避免 <code>participant leaders</code> 将其事务超时。当客户端完成所有的读操作以及缓冲了所有的写操作时，它就会开始执行两阶段提交。客户端会首先选择一个协调者组（<code>coordinator group</code>），然后给每一个 <code>participant leader</code> 发送一条提交消息，这个提交消息中包含了协调者的标识符以及所有客户端缓冲的写操作。由客户端发起两阶段提交避免了在广域链路下发送两次数据（如果两阶段提交不由客户端发起，可能的一种情况是客户端先将缓冲的写操作发给某个 <code>participant leader</code>，不管是这个 <code>participant leader</code> 自己成为 <code>coordinator leader</code> 还是让其他的 <code>participant leader</code> 成为 <code>coordinator leader</code>，都需要将客户端缓冲的写操作发送给其他的节点，这就造成发了两次数据）。</p>
<p>非协调者的 <code>participant leader</code> 会先获取写锁。然后它会选取一个比之前所有的事务的时间戳都大的时间戳作为准备阶段的时间戳（为了确保单调不变式（<code>monotonicity invariant</code>）），然后通过 <code>Paxos</code> 记录一条准备阶段的日志。然后每个 <code>participant leader</code> 会通知协调者自己所分配的时间戳。</p>
<p>协调者同样会先获取写锁，但是会跳过准备阶段。在收到所有 <code>participant leader</code> 的时间戳后，它会基于这些时间戳选择一个时间戳作为整个事务的时间戳。所选择的事务提交的时间戳 <code>s</code> 必须大于等于任意一个 <code>participant leader</code> 的准备阶段的时间戳（为了满足4.1.3节的限制约束），同时也要大于协调者收到提交消息时的时间戳 <code>TT.now().latest</code>，以及大于 <code>coordinator leader</code> 所有分配给之前的事务的时间戳（同样是为了确保单调不变式（<code>monotonicity invariant</code>））。然后 <code>coordinator leader</code> 也会通过 <code>Paxos</code> 记录一条提交的日志（或者在等待其他参与者时超时从而放弃当次事务）。</p>
<p>在允许参与事务的副本执行提交命令前，<code>coordinator leader</code> 会先进行等待直到 <code>TT.after(s)</code> 返回真，这就满足了4.1.2节描述的提交等待（<code>commit-wait</code>）规则。因为 <code>coordinator leader</code> 会基于 <code>TT.now().latest</code> 选择时间戳 <code>s</code>（<code>TT.now().latest</code> 只是其中的一个参考基准，但是实际的时间戳也必然会大于 <code>TT.now().latest</code>），然后现在需要等待直到当前的时间戳大于 <code>s</code>，则等待的时间至少是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">2 * \bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">ˉ</span></span></span></span></span></span></span></span></span>（时间的瞬时误差上限记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>，其值为 <code>TTinterval</code> 区间长度的一半，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>ϵ</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">ˉ</span></span></span></span></span></span></span></span></span>表示平均误差上限。因为最差的情况下当前的绝对时间可能正好是 <code>TTinterval</code> 区间的起始位置，从而需要等待整个区间长度）。不过这个等待时间基本上是和 <code>Paxos</code> 的通信重合的。在提交等待（<code>commit-wait</code>）结束后，协调者将事务的时间戳发送给客户端以及其他的 <code>participant leader</code>。每个 <code>participant leader</code> 通过 <code>Paxos</code> 记录事务的结果。每个参与者也同样在相同的时间戳下应用日志然后释放锁。</p>
<h4 id="只读事务"><a class="markdownIt-Anchor" href="#只读事务"></a> 只读事务</h4>
<p>给只读事务分配时间戳需要所有涉及的 <code>Paxos</code> 组进行协商。因此，<code>Spanner</code> 要求每个只读事务需要声明一个 <code>scope</code> 表达式，这个表达式汇总了整个只读事务会读取的键。<code>Spanner</code> 会自动的为独立的查询推导出 <code>scope</code>。</p>
<p>如果某个 <code>scope</code> 的值只涉及单个 <code>Paxos</code> 组，则客户端会向该 <code>Paxos</code> 组的主节点发起只读事务（当前 <code>Spanner</code> 的实现中只会由主节点为只读事务选取时间戳）。主节点选取时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后开始执行读操作。对于单点（<code>single-site</code>）读操作，<code>Spanner</code> 通常能选取一个比 <code>TT.now().latest</code> 更好的时间戳。定义 <code>LastTS()</code> 表示该 <code>Paxos</code> 组中最后一次提交的写操作的时间戳。如果当前没有任何已完成准备阶段的事务，那么选取 <code>LastTS()</code> 作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值就已经能满足外部一致性：当前的只读事务能读取到上一次写操作的结果，因此该只读事务也发生在这之后。</p>
<p>如果 <code>scope</code> 的值涉及了多个 <code>Paxos</code> 组，这就有几种选择。其中最复杂的选择就是和每一个 <code>Paxos</code> 组的主节点通信，然后基于每个 <code>Paxos</code> 组的 <code>LastTS()</code> 来选取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<code>Spanner</code> 目前选取了更简单的实现。客户端省略了和所有涉及的 <code>Paxos</code> 组的协商阶段，直接选取 <code>TT.now().latest</code> 作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值（当然前面说过这会造成阻塞，需要等待副本的安全时间满足大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。因此该事务中所有的读操作都可以发送给有着足够新的数据的副本处理。</p>
<h4 id="模式变更事务"><a class="markdownIt-Anchor" href="#模式变更事务"></a> 模式变更事务</h4>
<p><code>TrueTime</code> 使得 <code>Spanner</code> 能够支持原子的模式变更。使用标准的事务来处理模式变更是不切实际的，因为涉及的参与者数量（数据库中 <code>Paxos</code> 组的数量）可能有百万级别。<code>Bigtable</code> 支持单个数据中心内的原子模式变更，不过执行模式变更时会阻塞所有的其他操作。</p>
<p><code>Spanner</code> 的模式变更事务基本上是标准事务的一个非阻塞式的变种。首先，它会被分配一个未来的时间戳，这个时间戳是在准备阶段生成的。因此，涉及几千台服务器的模式变更能够在尽可能少的影响到并发进行的事务的前提下完成。第二，依赖需要变更的模式的读写操作会和分配了时间戳 <code>t</code> 的模式变更事务保持同步：如果读写操作的时间戳小于 <code>t</code>，则这些操作可以继续进行；但是如果读写操作的时间戳大于 <code>t</code>，则需要阻塞等待模式变更事务完成。如果没有 <code>TrueTiime</code>，则定义模式修改发生在时间戳 <code>t</code> 就没有意义。</p>
<h4 id="改进"><a class="markdownIt-Anchor" href="#改进"></a> 改进</h4>
<p>上述定义的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>T</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">T_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>存在一个缺陷，某个已完成准备阶段的事务会阻止<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>更新（因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{safe} = min(t_{safe}^{Paxos}, t_{safe}^{TM})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在4.1.3节有描述，当存在完成准备阶段的事务时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>g</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msubsup><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_{safe}^{TM} = min_i(s_{i, g}^{prepare}) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，需要依赖各参与者所分配的准备阶段的时间戳）。因此，需要读取后面的时间戳的读操作都无法完成，即使该读操作和当前的事务没有冲突。一种解决方案是建立某个范围内的键到已完成准备阶段的事务的时间戳的映射。这部分的信息可以保存在锁表中，因为锁表本身已经保存了某个范围内的键到锁的元数据的映射。当 <code>Spanner</code> 收到一个读操作时，会先判断要读取的键是否存在已完成准备阶段但还未完成提交的事务，如果不存在这样的事务，则如4.1.3节所述<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值就只取决于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><code>LastTS()</code> 也有类似的问题：如果某个事务刚刚提交，一个无冲突的只读事务所分配的时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>依然要在刚提交的事务的时间戳之后。因此，由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{safe}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的存在，该只读事务也有可能延迟。这个问题的解决方案也类似于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>T</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>T</mi><mi>M</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">T_{safe}^{TM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>，同样是建立某个范围内的键到 <code>LastTS()</code> 的映射（不过目前 <code>Spanner</code> 还未实现这个优化）。当 <code>Spanner</code> 收到某个只读事务时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{read}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值取决于读操作涉及的键所对应的 <code>LastTS()</code> 的最大值，除非同时还存在已完成准备阶段但还未完成提交的事务（则又回到上面一种情况）。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的问题在于如果没有写操作，则这个值始终得不到更新。因此，如果某个期望读取时间戳 <code>t</code> 的快照读落在了某个最近一次写操作的时间戳小于 <code>t</code> 的 <code>Paxos</code> 组中，那么在没有新的写操作的情况下，这个快照读始终无法被执行。<code>Spanner</code> 通过主节点租约区间的不相交不变式（<code>disjointness invariant</code>）来解决这个问题。每个主节点维护了一个 <code>Paxos</code> 序号 <code>n</code> 到可能分配给下一个序号 <code>n + 1</code> 的最小时间戳的映射，即 <code>MinNextTS(n)</code>。当某个副本应用了序号 <code>n</code> 的指令后，则可以将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>t</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi></mrow><mrow><mi>P</mi><mi>a</mi><mi>x</mi><mi>o</mi><mi>s</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">t_{safe}^{Paxos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span></span></span></span>的值更新为 <code>MinNextTS(n) - 1</code>，因为下一个被分配的最小时间戳为 <code>MinNextTS(n)</code>，减1就保证了不会超过这个值。</p>
<p>对于单个主节点来说可以很轻易的保证 <code>MinNextTS()</code> 的值的正确性（这里有一种可能的粗暴的方案，例如主节点设定10毫秒后才能提交下一个事务，如果10毫秒内来了一个事务，则直接等待到10毫秒后）。因为 <code>MinNextTS()</code> 的值必然落在当前主节点的租期内，又由于各个主节点租期之间的不相交不变式（<code>disjointness invariant</code>）的存在，使得 <code>Spanner</code> 能够在跨主节点时依然保证 <code>MinNextTS()</code> 的值的正确性（如果 <code>MinNextTS()</code> 的值超过了当前主节点的任期，则 <code>MinNextTS()</code> 的值的正确性就交由下一个主节点保证，从而转为了单主节点问题）。如果某个主节点在当前租期快过期时想要增加 <code>MinNextTS()</code> 的值，那么这个主节点就必须先延长租期。注意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（某个主节点使用的最大时间戳）始终会更新为 <code>MinNextTS()</code> 的最大值来确保不相交不变式（<code>disjointness invariant</code>）。</p>
<p>主节点默认每8秒增加一次 <code>MinNextTS()</code> 的值（因为如果一直没有写操作，则需要不断更新 <code>MinNextTS()</code> 来确保后续的读请求不会阻塞）。因此，在不存在已完成准备阶段的事务的情况下，某个空闲的 <code>Paxos</code> 组中健康的副本在最差情况下需要等待8秒才能返回数据给客户端。主节点可能也会根据从节点的要求来更新 <code>MinNextTS()</code> 的值。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/spanner.pdf">Spanner: Google’s Globally-Distributed Database</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/spanner/docs/replication#benefits_of_cloud_spanner_replication">Benefits of Cloud Spanner replication</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/06/11/mit-6.824-frangipani/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/11/mit-6.824-frangipani/" class="post-title-link" itemprop="url">MIT 6.824 - Frangipani: A Scalable Distributed File System</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-11T00:00:00+08:00">2022-06-11</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>28 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>这是一篇上世纪九十年代的论文，在当时的环境下，安装新工作站的需求与日俱增，而针对大量工作站的文件系统管理却费时费力。为了保存更多的文件和服务更多的用户，就需要更多的磁盘，并挂载到更多的机器上。某一组文件经常会被手动分配给某些特定的磁盘，当磁盘空间不足，异常或者成为性能热点时，就需要手动移动或者复制文件到其他磁盘上。使用 <code>RAID</code> 技术管理多个磁盘只能解决部分问题；当系统增长到需要多个磁盘阵列和多台服务器时，系统管理问题也随之而来。</p>
<p><code>Frangipani</code> 是一个可扩展的分布式文件系统，它能统一管理挂载在不同机器上的磁盘，对外来说，这些磁盘构成了一个独立的共享存储池。组成 <code>Frangipani</code> 的机器默认能够被统一管理而且相互间能安全的通信。在 <code>Frangipani</code> 之前已经有了一些分布式文件系统的实现，并且在吞吐和容量上有很好的扩展性。<code>Frangipani</code> 的一个显著特性是它的内部结构非常简单——各台协作的机器共同访问一个通用的存储，并使用锁来保证访问的同步性。这种简单的结构使得只需要少量的机器就能处理系统恢复，重配置和负载均衡。<code>Frangipani</code> 的另一个关键特性是相比于已知的分布式文件系统，它结合了一系列功能使得 <code>Frangipani</code> 更易于使用和管理：</p>
<ol>
<li>所有用户读取到的文件内容都相同。</li>
<li>可以轻易的向 <code>Frangipani</code> 添加更多的服务器来增加存储容量和吞吐，而无需修改已有服务器的配置，或者中断其操作。这些服务器可以像积木一样根据需要搭建来构建更大的文件系统。</li>
<li>系统管理员添加新用户时无需关心新用户的数据会由哪台服务器管理或者保存在哪个磁盘上。</li>
<li>系统管理员可以对整个文件系统进行完整和一致的备份，而无需停止服务。备份可以在线进行，使得用户可以快速访问被意外删除的文件。</li>
<li>文件系统可以在无需人工干预的情况下容忍机器、网络、磁盘异常并自行恢复。</li>
</ol>
<p><code>Frangipani</code> 构建于 <code>Petal</code> 之上，<code>Petal</code> 是一个易于管理的分布式存储系统，为客户端提供了虚拟磁盘。和物理磁盘一样，<code>Petal</code> 的虚拟磁盘也是以块（<code>block</code>）的方式来读取和写入。和物理磁盘不同的是，一个 <code>Petal</code> 虚拟磁盘提供了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>字节的稀疏地址空间，并且只在需要的时候才会分配物理存储。<code>Petal</code> 也支持数据备份来保证高可用。<code>Petal</code> 同时提供了高效的快照功能来支持一致性备份。<code>Frangipani</code> 从下层存储系统继承了扩展性，容错和易于管理的特性，不过将这些特性扩展到文件系统还需要些细致的设计。下一节将会详细描述 <code>Frangipani</code> 的结构以及和 <code>Petal</code> 的关系。</p>
<p><img src="/images/frangipani-1.png" alt="alt" /></p>
<p>上图展示了 <code>Frangipani</code> 的层级设计。多个可替换的 <code>Frangipani</code> 服务器运行于一个共享的 <code>Petal</code> 虚拟磁盘之上，不同的用户程序可以各自通过连接的 <code>Frangipani</code> 服务器来访问相同的文件，而各 <code>Frangipani</code> 服务器间通过分布式锁服务来保证数据的一致性。通过添加 <code>Frangipani</code> 服务器可以实现对文件系统层的扩展。<code>Frangipani</code> 通过异常服务器的自动恢复和借助依然存活的服务器来提供服务实现了容错。相比于中心化的网络文件服务器，<code>Frangipani</code> 通过将负载分摊到各个正在使用文件的机器上来提供更好的负载均衡。出于扩展性，容错和负载均衡的考虑，<code>Petal</code> 和 <code>Frangipani</code> 用到的锁服务也是分布式的。</p>
<p><code>Frangipani</code> 服务器默认信任 <code>Petal</code> 服务器和锁服务。<code>Frangipani</code> 的最佳使用场景是在同一个管理域下的工作站集群，虽然它也可以扩展到其他管理域下。因此，<code>Frangipani</code> 可以被看做是一个集群文件系统。</p>
<p>论文的作者在 <code>DIGITAL Unix 4.0</code> 之上实现了 <code>Frangipani</code>。得益于 <code>Frangipani</code> 在 <code>Petal</code> 之上构建的简洁的层级设计，使得在几个月内实现了一个可用的系统。</p>
<p><code>Frangipani</code> 的目标运行环境的场景是程序开发和工程。测试表明在这样的负载下，<code>Frangipani</code> 有着优秀的性能并且能很好的扩展，而最终的性能上限则受限于网络能力。</p>
<h2 id="系统结构"><a class="markdownIt-Anchor" href="#系统结构"></a> 系统结构</h2>
<p><img src="/images/frangipani-2.png" alt="alt" /></p>
<p>上图展示了 <code>Frangipani</code> 系统下各机器的一种典型职责分配。最上方的机器运行着用户程序和 <code>Frangipani</code> 的文件服务模块，这些机器无需挂载磁盘。最下方的机器运行着 <code>Petal</code> 和分布式锁服务。</p>
<p>不过在实际场景中，组成 <code>Frangipani</code> 的机器无需严格按照上图中的描述承担职责。<code>Petal</code> 和 <code>Frangipani</code> 文件服务不一定要运行在不同的机器上；每台运行着 <code>Petal</code> 的机器也可以同时运行着 <code>Frangipani</code> 文件服务，特别是当 <code>Petal</code> 的机器负载不高时。分布式锁服务独立于系统中的其他服务，上图中描述了每个 <code>Petal</code> 机器上运行着一个锁服务，不过它们也可以运行在 <code>Frangipani</code> 或者其他可用的机器上。</p>
<h3 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h3>
<p>如前面的图中所示，用户程序通过标准的系统调用接口来访问 <code>Frangipani</code>。运行在不同机器上的应用程序能访问到相同的文件，而且看到的文件内容也是相同的；也就是说，如果在某台机器上修改了某个文件或者文件夹，那么运行在其他机器上的程序也能马上看到这个修改。对于使用 <code>Frangipani</code> 的程序来说，<code>Frangipani</code> 提供的文件操作语义保证和本地 <code>Unix</code> 文件系统提供的文件操作语义保证相同：程序对文件的修改会先暂存在内核的缓冲区中，在下一次的 <code>fsync</code> 或者 <code>sync</code> 系统调用之前，系统不保证对文件的修改会保存到非易失存储上，不过系统会记录对文件元数据的修改并且可选的保证当系统调用返回时，文件的元数据修改已经保存到了非易失存储上。和本地文件系统的文件操作语义有点小小的不同，<code>Frangipani</code> 中文件的最后访问时间是一个近似值，从而避免了每次读取文件时都需要写元数据。</p>
<p>每台机器上的 <code>Frangipani</code> 文件服务模块运行在操作系统内核中。通过内核的 <code>file system switch</code> <code>Frangipani</code> 将自己注册为一个可用的文件系统实现。<code>Frangipani</code> 的文件服务模块使用了内核的缓冲区来缓存最近使用的文件数据。它通过本地的 <code>Petal</code> 设备驱动来实现对 <code>Petal</code> 虚拟磁盘的读写。每个文件服务器使用相同的数据结构来读取和写入文件到共享的 <code>Petal</code> 磁盘上，不过各服务器会在 <code>Petal</code> 磁盘的不同区域上针对进行中的修改维护各自的重做日志。因为 <code>Frangipani</code> 的重做日志保存在 <code>Petal</code> 中，所以当某个 <code>Frangipani</code> 服务器异常时，其他的服务器可以通过 <code>Petal</code> 访问日志并进行数据恢复。各 <code>Frangipani</code> 服务器之间无需通信；它们只会和 <code>Petal</code> 和分布式锁通信。这就简化了服务器的添加，删除和恢复。</p>
<p><code>Petal</code> 的设备驱动程序掩盖了 <code>Petal</code> 分布式的特性，对操作系统的上层应用来说，<code>Petal</code> 就等同于是一块本地磁盘。驱动程序负责和正确的 <code>Petal</code> 服务器通信，以及如果当前的服务器发生异常，能切换到另一台可用的服务器。类似 <code>Digital Unix</code>  的文件系统都可以运行在 <code>Petal</code> 之上，不过只有 <code>Frangipani</code> 提供了多客户端下访问同一文件的数据一致性特性。</p>
<p><code>Petal</code> 的各服务器基于本地挂载的物理磁盘并通过协作来向 <code>Frangipani</code> 提供大型，可扩展，容错的虚拟磁盘。<code>Petal</code> 可以容忍一个或多个磁盘或者服务器异常，只要大多数的 <code>Petal</code> 服务器依然存活并且相互之间可以通信，以及每个数据块都至少有一个副本保存在物理存储上并且能够被访问。</p>
<p><code>Frangipani</code> 用到的锁服务能够为网络中的客户端提供通用的读写锁服务。出于容错和扩展性考虑，它的实现是分布式的。<code>Frangipani</code> 使用锁服务来协调对虚拟磁盘的访问，以及保证各服务器内文件缓存的一致性。</p>
<h3 id="安全和客户端服务器配置"><a class="markdownIt-Anchor" href="#安全和客户端服务器配置"></a> 安全和客户端/服务器配置</h3>
<p>如 <code>Fugure 2</code> 所示，每台运行着用户程序的机器同时运行着 <code>Frangipani</code> 的文件服务模块。虽然这种配置有利于负载均衡和扩展，不过存在安全隐患。每个 <code>Frangipani</code> 机器都可以对共享的 <code>Petal</code> 虚拟磁盘上的数据块进行任意读写，所以 <code>Frangipani</code> 必须运行在受信任的操作系统上；类似于 <code>NFS</code> 的远程文件访问协议中的身份认证还不足以保证安全性。完整的安全性也要求 <code>Petal</code> 和锁服务运行在受信任的操作系统上，并且 <code>Frangipani</code>、<code>Petal</code>、锁服务这三个组件都需要能够互相认证。最后，为了保证文件数据的私有性，也需要保证没有人能够窃听 <code>Petal</code> 和 <code>Frangipani</code> 机器间的网络通信。</p>
<p>一种解决方案是运行用户程序的机器被设置为不允许运行自定义修改的操作系统，同时这些机器间通过一个私有网络连接并且用户程序没有权限访问。不过这并不是说需要将所有的机器放在同一个机房中并通过私有的物理网络相连；可以借助某些加密技术来实现系统的安全启动，以及某些认证技术和加密链路来保证通信安全性。另外，对于某些应用程序来说，一个不完整的解决方案也是可以接受的；典型的如 <code>NFS</code> 就不能防止网络窃听以及杜绝用户在自己的工作站上运行修改后的操作系统。论文的作者并没有实现所有的安全措施，不过 <code>Frangipani</code> 基本也可以达到 <code>NFS</code> 的安全级别，<code>Petal</code> 服务器只会接受来自已知网络地址的 <code>Frangipani</code> 服务器的请求。</p>
<p><img src="/images/frangipani-3.png" alt="alt" /></p>
<p>如上图所示，<code>Frangipani</code> 文件系统可以扩展到外部非受信的管理域中。图中区分开了 <code>Frangipani</code> 客户端和服务端。只有受信的 <code>Frangipani</code> 服务端可以和 <code>Petal</code> 以及锁服务通信。这三个组件可以放置在一个受限制的环境中并且通过私有的网络连接。而外部的非受信远程客户端只能和 <code>Frangipani</code> 服务端通信，而不能直接访问 <code>Petal</code> 服务器。</p>
<p>客户端可以和 <code>Frangipani</code> 服务端以任何操作系统支持的文件访问协议通信，例如 <code>DCE/DFS</code>，<code>NFS</code>，<code>SMB</code>，因为对于运行着 <code>Frangipani</code> 服务端的机器来说，<code>Frangipani</code> 就类似于是个本地文件系统。当然，如果访问协议本身支持一致性访问是最好的（例如 <code>DCE/DFS</code>），从而使得 <code>Frangipani</code> 的多服务器间的一致性不会在上一层丢失。理想情况下，客户端的访问协议需要支持故障转移。上述提到的协议并不直接支持故障转移，不过在其他系统中如果某台服务器发生异常，会有另一台服务器接管并复用异常服务器的 <code>IP</code> 地址，因此可以在这里应用同样的手段。</p>
<p>除了安全之外，还有第二个原因要使用上述的客户端/服务端配置。因为 <code>Frangipani</code> 运行在操作系统内核，不能快速的适配不同的操作系统甚至是不同版本的 <code>Unix</code>。所以通过远程客户端的方式就能使得运行不支持的操作系统的客户端也能够使用 <code>Frangipani</code>。</p>
<h3 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h3>
<p>构建文件系统的分层思想——低层提供存储服务，高层提供命名，文件夹和文件服务，并不是 <code>Frangipani</code> 独有的。最早应用这个思想的是 <code>Universal File Server</code>。不过，<code>Petal</code> 提供的存储功能和早先的系统大有不同，从而引申出不同的上层结构设计。</p>
<p><code>Frangipani</code> 的设计是基于 <code>Petal</code> 提供的抽象存储服务，作者还未充分考虑为了适配其他的存储服务（例如 <code>NASD</code>）需要对 <code>Frangipani</code> 做出哪些修改。</p>
<p><code>Petal</code> 提供了高可用的存储服务并且能够通过添加资源来实现对吞吐和容量的扩展。不过，<code>Petal</code> 不提供协同功能或者在多个客户端间共享存储。另外，大部分的应用程序不能直接使用 <code>Petal</code> 的接口因为 <code>Petal</code> 面向的是磁盘而不是文件。<code>Frangipani</code> 在 <code>Petal</code> 之上构建了文件系统层使得在保留和扩展了 <code>Petal</code> 有用的特性的同时对应用程序更加易用。</p>
<p><code>Frangipani</code> 的一个优势是能够透明的添加服务器，删除服务器以及实现故障恢复。通过将预写日志、锁和提供一致性访问、高可用的存储结合使用，<code>Frangipani</code> 能轻易的实现这个特性。</p>
<p><code>Frangipani</code> 的另一个特性是能在文件系统运行时生成一致性的备份。这个机制会在后面介绍。</p>
<p>不过 <code>Frangipani</code> 的设计可能在三个方面上存在问题。基于启用了副本的 <code>Petal</code> 虚拟磁盘构建的 <code>Frangipani</code> 有时候会记录重复的日志，一次是 <code>Frangipani</code> 自己写入的日志，这里是 <code>Frangipani</code> 为客户端提供服务；另一次是 <code>Petal</code>记录的日志，这里以 <code>Petal</code> 的视角来说 <code>Frangipani</code> 成为了客户端。第二，<code>Frangipani</code> 无法根据磁盘的位置来选择在哪里保存数据，因为 <code>Petal</code> 提供的是虚拟的磁盘，之所以有这个需求可能是因为类似于 <code>GFS</code> 选择在哪里放置副本一样，如果 <code>Frangipani</code> 能知道具体磁盘的位置，它就能选择一个距离客户端近的磁盘保存文件。最后，<code>Frangipani</code> 会对整个文件或者文件夹加锁而不是对某个数据块加锁。不过作者还没有足够的使用经历来评估这三个问题的影响，不过撇开它们不谈，在作者所处环境下测试出的 <code>Frangipani</code> 的性能还是不错的。</p>
<h2 id="磁盘布局"><a class="markdownIt-Anchor" href="#磁盘布局"></a> 磁盘布局</h2>
<p><code>Frangipani</code> 使用 <code>Petal</code> 提供的巨大、稀疏的磁盘地址空间来简化其数据结构。这个想法是受之前有着巨大内存空间的计算机上的相关工作所启发。因为有着如此巨大的地址空间所以可以将其任意切分。</p>
<p>一个 <code>Petal</code> 虚拟磁盘有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>字节的地址空间。<code>Petal</code> 只会在物理磁盘空间写入后才会将其提交到虚拟地址中。<code>Petal</code> 同时提供了 <code>decommit</code> 原语用来释放某个范围内的虚拟地址所关联的物理磁盘空间。</p>
<p>为了使内部的数据结构足够小，<code>Petal</code> 会以较大的数据块来提交（<code>commit</code>）和回收（<code>decommit</code>）虚拟地址，目前的数据块大小是 <code>64 KB</code>。也就是说，对于每个 <code>64 KB</code> 的虚拟地址空间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>∗</mo><msup><mn>2</mn><mn>16</mn></msup><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><msup><mn>2</mn><mn>16</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[a * 2^{16}, (a + 1) * 2^{16})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，如果有数据写入且没有被回收，那么同时就需要分配 <code>64 KB</code> 的物理磁盘地址空间。因此 <code>Petal</code> 客户端写入的数据不能太稀疏，否则可能由于碎片化造成物理磁盘空间浪费。下图展示了 <code>Frangipani</code> 如何切分 <code>Petal</code> 的虚拟磁盘空间：</p>
<p><img src="/images/frangipani-4.png" alt="alt" /></p>
<p>图中的第一个区域用于保存共享的配置参数和其他信息。这个区域的最大大小是 <code>1 T</code>，不过目前实际上只用了几 <code>K</code>。</p>
<p>第二个区域用于保存日志。每个 <code>Frangipani</code> 服务器会在这块区域中选择一部分来保存自己的私有日志。这里总共预留了 <code>1 T</code> 的空间，并切分为256个分区，所以可以保存256份日志。这就限制了一个 <code>Petal</code> 虚拟磁盘最多支持256个 <code>Frangipani</code> 服务器，不过这可以轻易的通过调整分区个数来扩展。</p>
<p>第三个区域用于保存分配位图，从而知道余下的虚拟空间中哪些是可用的。每个 <code>Frangipani</code> 服务器会独占式的锁住这块区域中的某一部分。当某台 <code>Frangipani</code> 服务器的分配位图空间不够时，它会再次找到可用的区域然后加锁使用。整个区域的大小是 <code>3 T</code>。</p>
<p>第四个区域用于保存 <code>inode</code>。每个文件需要一个 <code>inode</code> 来保存元数据，例如访问的时间戳和指向文件数据位置的指针。对于符号链接来说它们的数据直接保存在了 <code>inode</code> 中。每个 <code>inode</code> 的大小为512字节，和磁盘块的大小相同，从而避免了两个服务器同时访问同一个磁盘块上保存的不同 <code>inode</code> 所带来的竞争（也就是 <code>false sharing</code>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/frangipani-faq.txt">FAQ for Frangipani, Thekkath, Mann, Lee, SOSP 1997</a> 中对这个问题有所解释，磁盘数据的读取以块为单位，如果 <code>inode</code> 小于512字节，某个 <code>Frangipani</code> 服务器先读取了磁盘数据块并缓存，此时另一个服务器需要读取和修改同一个磁盘数据块上的 <code>inode</code>，那么为了保证缓存一致性，第一个服务器再次读取 <code>inode</code> 时就需要重新读取磁盘数据块并刷新缓存，造成两个服务器交替的读取修改同一个数据块的内容，缓存也就失去了意义，而本质上两个服务器之间并不应该有竞争。）。整个区域的大小是 <code>1 TB</code>，所以可以保存<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个 <code>inode</code>。在位图分配区域中的比特位和 <code>inode</code> 的映射是固定的，也就是说根据位图分配区域中的比特位地址就能推算出对应 <code>inode</code> 的地址，所以每个 <code>Frangipani</code> 为新文件所创建的 <code>inode</code> 地址在第四个区域中的偏移比例和该 <code>inode</code> 对应位图分配区域中的比特位的偏移比例是一致的。不过任何一个 <code>Frangipani</code> 都可能读写或释放某个已经存在的文件的 <code>inode</code>。</p>
<p>第五个区域用于保存小数据块，每个数据块大小为 <code>4 KB</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>字节）。一个文件的前 <code>64 KB</code>（16个数据块） 的内容会保存在小数据块中。如果某个文件的大小超过 <code>64 KB</code>，则超过的部分会保存在一个大数据块中。<code>Frangipani</code> 在一个 <code>Fetal</code> 虚拟磁盘上最多可以分配<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>47</mn></msup></mrow><annotation encoding="application/x-tex">2^{47}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>字节（<code>128 T</code>）的小数据块，共计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>35</mn></msup></mrow><annotation encoding="application/x-tex">2^{35}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>块，是 <code>inode</code> 最大数量的16倍。</p>
<p><code>Petal</code> 虚拟磁盘剩下的地址空间用于保存大数据块。每个大数据块有 <code>1 TB</code> 空间。</p>
<p>选择 <code>4 KB</code> 作为数据块大小会比更小的数据块的策略更容易产生磁盘碎片。同时，一个 <code>inode</code> 512字节在某种程度上也是空间浪费。可以将小文件直接保存在 <code>inode</code> 中来缓解这个问题。虽然存在碎片和空间浪费的问题，不过出于设计简洁性的考虑，作者认为这是一种合理的折中选择。</p>
<p>在当前的设计下，<code>Frangipani</code> 能保存的大文件个数小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>（1600万，大文件需要保存在大数据块中，一个大数据块 <code>1 T</code>，而虚拟空间最大地址<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mi>T</mi></mrow><annotation encoding="application/x-tex">2^{24} T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，又因为不是整个空间都用来保存大文件，所以实际个数小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>），大文件是指大于 <code>64 KB</code> 的文件。另外，<code>Frangipani</code> 能保存文件的最大大小是16个小数据块加上一个大数据块（<code>64 KB</code> 加 <code>1 TB</code>）。如果需要保存更多的文件，可以通过减小大数据块的大小来解决；以及允许一个大文件可以保存在多个大数据块中，这样就可以提高最大能保存文件的大小。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>字节的地址空间不够，则一个 <code>Frangipani</code> 服务器可以支持扩展为多个 <code>Petal</code> 虚拟磁盘组成的 <code>Frangipani</code> 文件系统。</p>
<p>作者基于之前文件系统的使用经验设定了上述的系统参数。作者认为这种配置已经足够满足需求，不过还是需要时间和实际使用来检验。<code>Frangipani</code> 的设计足够灵活所以可以通过备份和恢复来验证合适的磁盘布局。</p>
<h2 id="日志和恢复"><a class="markdownIt-Anchor" href="#日志和恢复"></a> 日志和恢复</h2>
<p><code>Frangipani</code> 通过元数据的预写重做日志来简化异常恢复和提高性能；不过用户的数据并不会记录到日志中。每个 <code>Frangipani</code> 服务器会将自己的日志保存在 <code>Petal</code> 中。当某个 <code>Frangipani</code> 服务器需要修改某个元数据时，它会首先生成一条日志来描述具体的修改内容并将其添加到内存日志中。这些内存中的日志会周期性的按照修改请求发起的顺序写入到 <code>Petal</code> 中（<code>Frangipani</code> 同时也支持将日志同步的写入到 <code>Petal</code> 中，这会稍微提高容错性不过会增加元数据更新操作的延迟。）。只有当某条日志写入 <code>Petal</code> 之后，系统才会真正修改对应文件的元数据。实际文件的元数据更新会交由一个 <code>Unix</code> 的 <code>update</code> 守护进程来周期性（大概每隔30秒）的更新。</p>
<p>在当前的实现中，<code>Frangipani</code> 写到 <code>Petal</code> 的日志的最大大小为 <code>128 KB</code>。根据 <code>Petal</code> 的空间分配策略，一份日志会拆分到两个不同的物理磁盘上，每个磁盘上的大小为 <code>64 KB</code>。<code>Frangipani</code> 会以环形缓冲（<code>circular buffer</code>）的方式来管理所分配的日志空间。当日志空间满时，<code>Frangipani</code> 会回收25%的最老的日志空间来存放新的日志。一般来说，被回收的日志所对应的元数据修改都应该已经写入到了 <code>Petal</code> 中（通过之前的 <code>sync</code> 操作），因此回收日志时不需要额外的写操作。如果回收日志时发现存在某些待回收的日志所对应的元数据修改还没有写入到 <code>Petal</code>，则需要先执行元数据的写入操作再回收日志。根据日志缓冲区和单条 <code>Frangipani</code> 日志的大小（80-128字节），如果在两个 <code>sync</code> 周期内存在1000-1600个元数据修改操作就能写满整个日志缓冲区。</p>
<p>如果某个 <code>Frangipani</code> 服务器发生异常，系统最终能检测到异常并根据该 <code>Frangipani</code> 服务器的日志进行恢复。<code>Frangipani</code> 服务器异常可以被所访问的客户端发现，或者当锁服务向持有锁的 <code>Frangipani</code> 服务器要求返回锁而没有响应时发现。当异常发生时，负责恢复的守护进程会临时拥有异常的 <code>Frangipani</code> 服务器的日志和锁的所有权。异常恢复进程会先找到异常服务器日志的起始位置和结束位置，然后逐条检查每一条日志，判断哪些日志所对应的元数据更新还没有被执行。当日志处理完成后，异常恢复进程就会释放所持有的锁并清空日志。其他的 <code>Frangipani</code> 服务器就可以在不受异常服务器影响的情况下继续工作，而异常的服务器可以在稍后被重启（对应的日志为空）。只要底层的 <code>Petal</code> 磁盘依然可用，系统就能容忍任意数量的 <code>Frangipani</code> 服务器异常。</p>
<p>为了确保异常恢复进程能找到异常服务器的日志的结束位置（即使磁盘控制器没有按照顺序写数据），系统为每512字节的日志数据块分配了一个递增的序号。只要发现某个数据块的序号小于前一个数据块的序号，那就说明前一个数据块就是日志的结束位置。</p>
<p><code>Frangipani</code> 确保了日志和异常恢复能正确的处理多条日志。不过这在细节上有几点要注意。</p>
<p>首先，在下一节会介绍到 <code>Frangipani</code> 的锁协议保证了多个服务器对同一个数据的更新请求会被串行执行。某个持有写锁且修改了数据的服务器需要先将修改的数据写回到 <code>Petal</code> 后才能释放锁，所以要么是该服务器在正常情况下数据更新完成后主动释放锁，要么是服务器异常后由异常恢复进程在数据更新完成后释放锁。这说明对于任意的数据块来说，整个系统中最多只可能有一条数据修改的日志还未完成。</p>
<p>第二，<code>Frangipani</code> 确保了异常恢复进程只会处理异常服务器在持有锁之后但还未释放锁期间记录的日志。这是为了确保锁协议保证的更新串行化不会被破坏。<code>Frangipani</code> 使用了更强的条件限制来实现这一保证：异常恢复进程永远不会重新执行一个已经执行完成的数据更新。为了保证这一点，<code>Frangipani</code> 给每512字节的元数据块分配了一个版本号。而类似于文件夹的元数据有可能会跨多个数据块，所以也会有多个版本号。对于每个日志要修改的数据块，日志会记录修改的内容及新的版本号。在异常恢复时，恢复进程会比较当前元数据块最新的版本号和日志中记录的版本号，只有当日志中的版本号大于当前最新的版本号时，恢复进程才会执行重做日志。</p>
<p>由于 <code>Frangipani</code> 记录更新日志时不会记录用户数据，而只有元数据块给版本号预留了空间。这就带来了一个潜在问题。如果某个数据块一开始被用于保存元数据，后来空间被释放，然后又被用来保存用户数据，那么恢复进程就不能正确的跳过依然引用了这个元数据块（现在的用户数据块）的日志，因为原来保存元数据块中的版本号信息已经被用户数据所覆盖，所以恢复进程就无法比较日志中的版本号的大小。<code>Frangipani</code> 通过要求被释放的元数据块只能用于保存新的元数据来避免这个问题。</p>
<p>最后，<code>Frangipani</code> 保证在任一时刻只会有一个异常恢复进程在恢复重做某个异常服务器的日志。<code>Frangipani</code> 通过对日志文件的互斥锁来实现这一保证。</p>
<p><code>Frangipani</code> 的日志和异常恢复机制假定当出现磁盘写异常时，单个扇区中的内容要么都是旧的，要么都是新的，而不会是两者的混合。如果某个磁盘扇区已损坏并且在读操作时返回 <code>CRC</code> 异常，那么 <code>Petal</code> 内置的副本机制通常能恢复对应的数据。如果某个扇区的副本都损坏了，或者 <code>Frangipani</code> 内部的数据结构由于软件 <code>bug</code> 造成损坏，则需要对元数据进行一致性检查以及需要一个恢复工具（例如 <code>Unix</code> 的 <code>fsck</code>）进行数据恢复。不过论文的作者写论文时还未实现这个工具。</p>
<p><code>Frangipani</code> 的日志并不是为了给用户提供高层次的执行语义保证。它的目的是为了提高元数据更新的性能以及发生服务器异常时通过避免执行 <code>fsck</code> 这样的恢复工具来加快异常恢复速度。因为 <code>Frangipani</code> 的日志只会记录元数据的更新，不会记录用户数据，所以站在用户的视角来说，当系统发生异常时，文件系统的状态和异常发生前并不能保证一致。论文的作者并不是声明这样的语义是理想的，不过这个行为和标准的本地 <code>Unix</code> 文件系统的行为是一样的。在本地 <code>Unix</code> 文件系统和 <code>Frangipani</code> 中，用户都可以在合适的时间点调用 <code>fsync</code> 来确保更好的数据一致性保证。</p>
<p><code>Frangipani</code> 所使用的日志技术最早被应用于数据库，并在之后应用到其他某些基于日志的系统中。<code>Frangipani</code> 本身不是个日志结构（<code>log-structured</code>）的文件系统；它不会将所有的数据都保存在日志中，而是将数据按约定维护在磁盘中，通过较少的日志 <code>Frangipani</code> 实现了较好的性能和异常恢复的原子性。和其他基于日志的文件系统不同，但是和例如 <code>Zebra</code> 这样的日志结构文件系统相同，<code>Frangipani</code> 也会保存多份日志。</p>
<h2 id="同步和缓存一致性"><a class="markdownIt-Anchor" href="#同步和缓存一致性"></a> 同步和缓存一致性</h2>
<p>由于会有多个 <code>Frangipani</code> 服务器修改 <code>Petal</code> 的共享数据，所以需要一个细致化的同步手段来确保各服务器读取到的数据是一致的，以及当系统负载增加或者添加新的服务器时能通过有效的并发手段来提高性能。<code>Frangipani</code> 使用多读一写的读写锁来实现必要的同步。当锁服务侦测到冲突的锁请求时，它会要求锁的持有者释放锁或者进行锁降级（写锁降级为读锁）来消除冲突。</p>
<p>读锁允许一个 <code>Frangipani</code> 服务器从磁盘中读取相应的数据并缓存。如果该服务器被要求释放锁，则在释放锁前必须先清空缓存。写锁允许一个 <code>Frangipani</code> 服务器读取或者修改数据并将其缓存。只有当某个服务器持有写锁时，它所缓存的数据才有可能和磁盘上保存的数据不同。因此，如果持有写锁的服务器被要求释放写锁或者降级为读锁，则必须先将修改的数据写回到磁盘。如果该服务器降级为了读锁，则依然可以保留缓存，不过如果释放了锁则必须清空缓存。</p>
<p>相比于释放写锁或者降级为读锁时将缓存中的数据写回到磁盘，还可以选择直接将缓存中的数据发送给请求方。不过出于简洁性考虑 <code>Frangipani</code> 并没有这么做。首先，在 <code>Frangipani</code> 的设计中，<code>Frangipani</code> 服务器之间无需通信。它们只会和 <code>Petal</code> 以及锁服务通信。第二，当某台服务器异常时，<code>Frangipani</code> 的设计保证了系统只需要处理异常服务器的日志即可。如果选择将未写入到磁盘中的数据直接发送给请求方，而接收方发生异常时，指向未持久化的数据的日志可能分散在了多台服务器中。这就给系统恢复和日志空间回收都带来了问题。</p>
<p><code>Frangipani</code> 将磁盘数据结构拆分为了一个个逻辑段，每个逻辑段都对应一把锁。为了避免 <code>false-sharing</code>，<code>Frangipani</code> 确保了一个磁盘扇区不会保存超过1个可共享的数据结构。将磁盘数据结构拆分为可加锁的段是为了将锁的数量控制的足够小，同时又能避免正常情况下的锁竞争，从而使得锁服务不会成为系统的瓶颈。</p>
<p>每个 <code>Frangipani</code> 服务器的日志都是一个可加锁的段，因为这些日志都是私有的。磁盘布局中的位图区域也切分为了一个个段，并且相互之间加了互斥锁，所以分配新文件时不会发生竞争，因为每个服务器都在自己持有的段内分配。还未分配给文件的数据块或者 <code>inode</code> 也同时被位图中的同一把锁保护，只是该位置的空间当前被标记为可用状态。最后，每个文件，文件夹，或者符号链接都是一个段；也就是说，<code>inode</code> 和其指向的数据都被同一把锁保护。这种每个文件一把锁的锁粒度对于作者所在的工作负载来说已经足够了，因为文件几乎很少会被并发的修改。而对于其他的工作负载来说则可能需要更细粒度的锁。</p>
<p>有些操作会要求原子的更新被多把锁保护的磁盘数据结构。<code>Frangipani</code> 通过对锁全局排序以及使用两阶段获取锁来避免死锁。首先，某台服务器先确定需要获取哪些锁。这个过程中会涉及获取或者释放某些锁，例如查找文件夹中的某些文件名。然后，服务器对锁按照 <code>inode</code> 的地址排序然后依次获取锁。同时服务器会检查在第一阶段中读取的对象是否在第二阶段发生了修改，如果发生了修改，那么该服务器会释放所有的锁然后重新执行第一阶段。否则，该服务器就可以开始执行具体的操作，在缓存中修改某些数据并记录一条日志。在缓存中的数据写回到磁盘前，该服务器都会持有相关的锁。</p>
<p>上述描述的缓存一致性协议类似于 <code>Echo</code>、<code>Andrew File System</code>、<code>DCE/DFS</code> 和 <code>Sprite</code> 中的客户端文件缓存协议。这里使用的避免死锁的技术和 <code>Echo</code> 类似。和 <code>Frangipani</code> 一样，<code>Oracle Parallel Server</code> 同样是将缓存中的数据写回到磁盘，而不是直接将缓存中的数据发送给下一个写锁的持有者。</p>
<h2 id="锁服务"><a class="markdownIt-Anchor" href="#锁服务"></a> 锁服务</h2>
<p><code>Frangipani</code> 只需要一小部分，通用的锁功能，并且不希望锁服务在日常操作中成为性能瓶颈，有很多种实现可以满足这些需求。在 <code>Frangipani</code> 项目中，一共尝试了三种不同的锁服务的实现，其他已有的锁服务也可以提供需要的功能，只是在其之上可能需要编写额外的代码来适配。</p>
<p>锁服务提供了多读一写的读写锁。这里的锁不会用完就马上释放，只要没有其他客户端请求相同的锁，这把锁就会一直被某个客户端持有（这里锁服务的客户端指的是 <code>Frangipani</code> 服务器）。</p>
<p>锁服务通过租约来处理客户端异常。当某个客户端请求锁服务时，它会先获取一个租约。该客户端获取的所有锁都和这个租约绑定。每个租约有一个过期时间，目前是锁创建或者延期后30秒过期。客户端在租约过期前必须先延期，否则锁服务会认为客户端发生了异常。</p>
<p>网络异常会妨碍 <code>Frangipani</code> 服务器延长租约，即使 <code>Frangipani</code> 服务器没有发生异常。当某个 <code>Frangipani</code> 服务器无法延长租约时，它会释放所有的锁并清空缓存。如果缓存中的数据被修改了，那么该服务器会打开某个内部标记使得后续的客户端请求都返回一个错误。相应的文件系统必须取消挂载才能删除这个异常。<code>Frangipani</code> 使用这种粗暴的方式来报告异常从而避免了异常被忽略。</p>
<p>第一版的锁服务实现使用了单节点中心化的服务器，所有的锁状态都保存在了内存中。这种设计对于 <code>Frangipani</code> 来说是足够的，因为 <code>Frangipani</code> 的日志中记录了足够的信息，所以即使锁服务发生异常丢失了所有的状态系统也能够恢复。不过，锁服务异常会导致严重的性能问题。</p>
<p>第二版的锁服务将锁的状态保存在 <code>Petal</code> 中，每个对锁状态的修改都会先写到 <code>Petal</code> 中，然后才会返回给客户端。如果锁服务的主节点异常，那么会由某个备份节点读取 <code>Petal</code> 中的锁状态然后接管异常的主节点并继续提供服务。在这个设计下，异常恢复更加透明，不过日常操作的性能会低于第一种锁实现。作者还未完全实现所有异常的自动恢复就开始了第三种锁服务的实现。</p>
<p>第三版的锁服务是分布式的，并且能很好的支持容错和性能。它由一组相互间协作的锁节点组成，同时每个 <code>Frangipani</code> 服务器内嵌了一个 <code>clerk</code> 模块。</p>
<p>锁服务将锁以表（<code>tables</code>）的形式组织，每个表以 <code>ASCII</code> 字符串的形式命名。每个表中的锁以64位的整型命名。一个 <code>Frangipani</code> 文件系统只使用一个 <code>Petal</code> 虚拟磁盘，虽然多个 <code>Frangipani</code> 文件系统可以挂载到同一个机器上。每个文件系统都绑定了一个关于锁的表。当一个 <code>Frangipani</code> 文件系统挂载时，<code>Frangipani</code> 服务器会请求内嵌的 <code>clerk</code>，然后 <code>clerk</code> 就会打开绑定的锁表。当 <code>clerk</code> 成功打开锁表时，锁服务会返回一个租约标识符，这个租约标识符会在后续通信中使用。当文件系统取消挂载时，<code>clerk</code> 就会关闭锁表。</p>
<p><code>clerk</code> 和锁节点间使用异步消息而不是 <code>RPC</code> 来通信，这样做能减少内存的使用并同时有着足够好的灵活性和性能。和锁相关的基础消息类型是 <code>request</code>，<code>grant</code>，<code>revoke</code> 和 <code>release</code>。<code>request</code> 和 <code>release</code> 消息是由 <code>clerk</code> 发送给锁节点，而 <code>grant</code> 和 <code>revoke</code> 消息则是由锁节点发送给 <code>clerk</code>。锁的升级和降级同样由这四种消息类型来处理。</p>
<p>锁服务使用了支持容错，分布式的异常监测机制来检测锁节点的异常。这个机制同时也被用于 <code>Petal</code>。该机制基于各节点间定期的心跳交换，同时使用了共识算法来容忍网络分区。</p>
<p>一把锁会在服务端和 <code>clerk</code> 侧都需要消耗内存。在当前的实现中，服务端会为每个锁分配112字节，每个 <code>clerk</code> 如果有进行中或者已分配的锁请求则额外还需要104字节。所以每个客户端每个锁最多使用232字节。为了避免长时间持有锁带来的内存消耗，<code>clerk</code> 会丢弃长时间（1小时）未使用的锁。</p>
<p>一小部分全局且不经常修改的状态信息会由 <code>Lamport</code> 的 <code>Paxos</code> 算法复制到所有的锁服务器上。锁服务复用了为 <code>Petal</code> 实现的 <code>Paxos</code> 算法。全局的状态信息包括锁服务器列表，每个锁服务器负责的锁列表，以及打开还未关闭锁表的 <code>clerk</code> 列表。这些信息用于达成共识，即在各个锁服务器间重新分配锁，当某个锁服务器发生异常时能恢复某个锁的状态，以及协助 <code>Frangipani</code> 服务器的异常恢复。从效率考虑，所有的锁被划分到100个不同的锁组中（<code>lock groups</code>），然后以组的形式分配给锁服务器，而不是以单个锁的形式。</p>
<p>有时候一把锁会被重新分配给其他的锁服务器，一方面是为了故障转移，另一方面是为了充分利用刚异常恢复的锁服务器，避免流量集中。当某个锁服务器被永久的添加到集群或者从集群中删除时，会发生类似的锁重分配。在这种情况下，所有的锁始终会被重分配，因为需要保证每台锁服务器持有的锁的数量是均衡的，锁重分配的次数要尽可能的少，以及每个锁都只会分配给一台锁服务器。锁的重分配也是由两阶段进行。在第一阶段，各个锁服务器丢弃保存在内部状态中的锁。第二阶段，锁服务器会和 <code>clerk</code> 通信，根据其所打开的锁表来重新分配锁。锁服务器根据 <code>clerk</code> 的锁表来重新生成锁的状态，同时通知 <code>clerk</code> 每把锁在重新分配后对应的锁服务器。</p>
<p>当某个 <code>Frangipani</code> 服务器异常时，在正确的恢复操作执行前，它所持有的锁不能被释放。特别的，系统需要先处理异常 <code>Frangipani</code> 服务器的日志并将未持久化的元数据更新写入到 <code>Petal</code>。当 <code>Frangipani</code> 服务器的租约到期时，锁服务会通知另一台 <code>Frangipani</code> 服务器上的 <code>clerk</code> 来执行恢复操作，并撤销原来异常服务器持有的全部锁。负责恢复的 <code>clerk</code> 会获取一把异常服务器的日志的互斥锁。这把锁同样分配了一个租约，所以当负责恢复的服务器异常时锁服务会再找一台服务器重新开始恢复任务。</p>
<p>一般来说，<code>Frangipani</code> 系统能够容忍网络分区，并在可能的情况下继续运行，否则就停止服务。特别的，<code>Petal</code> 可以在网络分区的情况下继续运行，只要大多数的 <code>Petal</code> 服务器依然存活并且相互之间可以通信，不过如果某些 <code>Petal</code> 虚拟磁盘在大多数的 <code>Petal</code> 服务器上没有备份的话，那么这些磁盘无法被继续访问。同样的，只要大多数的锁服务器依然存活并且相互之间可以通信，整个锁服务也依然可用。如果某个 <code>Frangipani</code> 服务器无法和锁服务通信，那么它将再也不能延长租约。此时锁服务会认为这个 <code>Frangipani</code> 服务器发生异常，然后会基于它的日志挑选一个新的 <code>Frangipani</code> 服务器发起恢复流程。如果某个 <code>Frangipani</code> 服务器无法和 <code>Petal</code> 通信，那么它将无法读取和写入虚拟磁盘。不管在哪种情况下，<code>Frangipani</code> 服务器都会拒绝后续受影响的文件系统的用户请求，直到网络分区恢复以及文件系统被重新挂载。</p>
<p>当 <code>Frangipani</code> 服务器的租约过期时存在一个潜在的问题。如果服务器依然存活而只是由于网络原因造成无法和锁服务通信，那么这台服务器可能依然会在租约过期后访问 <code>Petal</code>。<code>Frangipani</code> 服务器会在写入 <code>Petal</code> 前检查租约是否依然有效（并确保在未来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>秒内依然有效）。不过，<code>Petal</code> 并不会校验某个写入请求是否还在租约有效期内。所以，如果 <code>Frangipani</code> 服务器检查租约和写请求到达 <code>Petal</code> 的时间大于剩余租约的时间，那就会带来一个问题：当 <code>Petal</code> 收到写请求时，租约已经过期，该服务器持有的写锁已经分配给了其他服务器。<code>Frangipani</code> 为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>选择了一个足够大的值（15秒）来确保在正常情况下上述问题不会发生，不过依然不能确保一定不会发生。</p>
<p>在未来 <code>Frangipani</code> 会尝试解决这个问题，论文给出了一个可能的解决方案。<code>Frangipani</code> 会给每一个 <code>Petal</code> 的写请求附加一个过期的时间戳。这个时间戳的值为生成写请求时的租约过期时间减去<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。这样 <code>Petal</code> 就可以忽略任何时间戳小于当前时间的写请求。只要 <code>Petal</code> 和 <code>Frangipani</code> 服务器的时钟在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{margin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>内保持同步，<code>Petal</code> 就能够可靠的拒绝租约过期的写请求。</p>
<p>另一种解决方案则不依赖时钟同步，但是需要将锁服务和 <code>Petal</code> 集成，并且将 <code>Frangipani</code> 服务器获取的租约标识符附加到写请求中，<code>Petal</code> 收到写请求后就可以根据租约标识符校验租约是否过期，从而拒绝过期的写请求。</p>
<h2 id="添加和删除服务器"><a class="markdownIt-Anchor" href="#添加和删除服务器"></a> 添加和删除服务器</h2>
<p>系统管理员有时需要添加或者删除 <code>Frangipani</code> 服务器。<code>Frangipani</code> 被设计成能够轻易的处理这些场景。</p>
<p>添加一台服务器到运行中的系统只需要一点点的系统管理工作。新添加的服务器只需要知道使用哪块 <code>Petal</code> 虚拟磁盘以及锁服务的地址即可。新添加的服务器会和锁服务通信来获取租约，然后根据租约标识符决定使用哪部分的日志空间，然后就开始提供服务。系统管理员不需要修改其他服务器的配置，其他服务器能自动适配新服务器的上线。</p>
<p>删除一台 <code>Frangipani</code> 服务器则更简单。可以直接关闭这台服务器。不过更可取的方式是让这台服务器先将未持久化的数据写入到 <code>Petal</code>，然后释放持有的锁，最后再停机，不过这不是强制要求的。当服务器异常停机时，如果后续该服务器持有的锁需要被使用，则系统会自动发起恢复流程，并最终使得共享磁盘的数据达成一致。同样的，系统管理员也不需要修改其他服务器的配置。</p>
<p>如 <code>Petal</code> 的论文所描述，<code>Petal</code> 服务器同样可以无缝的添加和删除，锁服务器也同理。</p>
<h2 id="备份"><a class="markdownIt-Anchor" href="#备份"></a> 备份</h2>
<p><code>Petal</code> 的快照功能提供了一个简便的方法来备份一份完整的 <code>Frangipani</code> 文件系统快照。<code>Petal</code> 的客户端可以在任意时刻创建一个虚拟磁盘的快照。所创建的快照的虚拟磁盘和普通的虚拟磁盘一样，只不过它是只读的。实际快照实现时采用了写时复制（<code>copy-on-write</code>）技术来提高效率。<code>Petal</code> 创建的快照是崩溃一致的（<code>crash-consistent</code>）：也就是说，快照中保存的是在 <code>Petal</code> 虚拟磁盘中的数据，<code>Frangipani</code> 服务器内存中的数据不会记录到快照中。</p>
<p>因此，我们可以简单的通过创建 <code>Petal</code> 快照并将其拷贝到磁带中来备份一个 <code>Frangipani</code> 文件系统。快照会包含所有的日志，所以可以将其复制到一个新的 <code>Petal</code> 虚拟磁盘中然后根据日志运行恢复程序来恢复一个 <code>Frangipani</code> 文件系统。归功于崩溃一致的特性，从快照中恢复系统后要解决的问题就简化成了和发生系统级别的停电后恢复系统所要解决的问题一样。</p>
<p>可以对 <code>Frangipani</code> 稍作修改来改进这个恢复机制，即创建一个系统文件级别一致的快照，从而也无需执行恢复操作。可以让备份程序先强制要求所有的 <code>Frangipani</code> 服务器进入一个栅栏，这个功能可以由锁服务提供的全局锁来实现。每个 <code>Frangipani</code> 服务器以共享的模式获取这把锁然后执行修改操作，而备份程序以互斥的方式来处理请求。当 <code>Frangipani</code> 服务器收到请求要求释放锁时，它会阻塞所有新的修改数据的文件系统调用然后进入栅栏，接着清空缓存中已修改的数据，最后释放锁。当所有的 <code>Frangipani</code> 服务器进入栅栏后，备份程序会以互斥的模式获取锁，然后创建一个 <code>Petal</code> 快照并释放锁。之后各 <code>Frangipani</code> 就可以继续以共享的模式获取锁，然后恢复服务。</p>
<p>在后一种方案下，一个 <code>Frangipani</code> 的快照可以无需进行恢复就直接挂载使用。用户就可以从新的磁盘卷中在线获取单个文件，或者将其以一个更方便的格式转储到磁带中而无需 <code>Frangipani</code> 参与数据恢复。新添加的卷必须以只读的格式挂载，因为底层的 <code>Petal</code> 快照是只读的。在未来作者可能扩展 <code>Petal</code> 的快照使其可写，或者在 <code>Petal</code> 之上再抽象一层来模拟写操作。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/thekkath-frangipani.pdf">Frangipani: A Scalable Distributed File System</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/frangipani-faq.txt">FAQ for Frangipani, Thekkath, Mann, Lee, SOSP 1997</a></li>
<li><a target="_blank" rel="noopener" href="https://kb.synology.com/en-global/DSM/tutorial/What_is_file_system_consistent_snapshot">What is the difference between crash-consistent and file-system consistent snapshots?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/06/04/engineering-culture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/engineering-culture/" class="post-title-link" itemprop="url">工程师文化和实事求是</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-04 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-04T00:00:00+08:00">2022-06-04</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>677</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>陈皓在 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17497.html">什么是工程师文化？</a> 中谈到工程师文化由两点组成：自由和效率。不过我认为可以再加一点，那就是实事求是。实事求是要求尊重客观事实，不弄虚作假，不过现实中往往大相径庭。</p>
<h2 id="不尊重客观事实"><a class="markdownIt-Anchor" href="#不尊重客观事实"></a> 不尊重客观事实</h2>
<p>福尔摩斯里有一句话：</p>
<blockquote>
<p>Once you eliminate the impossible, whatever remains, no matter how improbable, must be the truth.</p>
</blockquote>
<p>对应了软件开发中一个烂大街的场景：在尽可能的考虑了所有的因素之后，不管完成一个工程所需要的时间是多么的不符合非执行者的预期，最终完成这个工程的时间也只会只多不少。如果无法正视客观事实，则会使得工程从开始到结束都弥漫着自我焦虑。而工程实施时往往只会拙劣的采用10个女人1个月生10个孩子的方式，最终也容易造成工程的反复返工，不过这倒能在总结大会上提供丰富的演讲素材，以及时间紧、任务重的自我感动，然后下次一定。</p>
<h2 id="避实就虚"><a class="markdownIt-Anchor" href="#避实就虚"></a> 避实就虚</h2>
<p>优秀的团队能正视问题，如果一个团队在面对问题分析时首先想的是哪些问题该提，哪些问题不该提，哪些问题提了会赢得芳心，那这种问题分析就是表演作秀，最终也继续重蹈覆辙。</p>
<h2 id="形式主义"><a class="markdownIt-Anchor" href="#形式主义"></a> 形式主义</h2>
<p>陈皓在 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17497.html">什么是工程师文化？</a> 中关于工程师文化如何落地提到引入绩效考核，不过这可能会造成形式主义和和团队间无意义的攀比。例如，如果将 <code>Code Review</code> 作为考核指标，难免会出现：快到月末了，还需要再提20个 <code>comment</code>；某部门的人均 <code>comment</code> 有 <code>xx</code> 个，本部门才 <code>yy</code> 个，每个人努努力，提到 <code>zz</code> 个。</p>
<h2 id="移花接木"><a class="markdownIt-Anchor" href="#移花接木"></a> 移花接木</h2>
<p>在成果导向的规则下，如果通过 <code>A</code>，<code>B</code>，<code>C</code> 达成了 <code>D</code>，则直接对外宣称通过 <code>A</code> 达成了 <code>D</code>。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17497.html">什么是工程师文化？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/06/04/mit-6.824-lab3-implementation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/mit-6.824-lab3-implementation/" class="post-title-link" itemprop="url">MIT 6.824 - Lab 3 (2): 实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-04 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-04T00:00:00+08:00">2022-06-04</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Lab 3</code> 需要我们实现一个基于 <code>Raft</code> 的键值数据库，支持三个操作：</p>
<ul>
<li><code>Put(key, value)</code></li>
<li><code>Append(key, value)</code></li>
<li><code>Get(key)</code></li>
</ul>
<h2 id="3a"><a class="markdownIt-Anchor" href="#3a"></a> 3A</h2>
<h3 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h3>
<p>客户端要做的只有一件事，就是向某个服务端发送请求。不过由于客户端不知道哪个服务端是主节点，所以需要不断轮询各服务端发送请求。为了避免每次轮询所有服务端浪费时间，客户端可以记录每次请求成功后的服务端编号，这个服务端就是当次请求中的主节点；当客户端再次发起请求时，可以先假定之前的服务端依然是主节点，从而先向该服务端发送请求，如果请求失败并返回 <code>ErrWrongLeader</code> 异常，则再尝试下一个服务端。</p>
<h3 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h3>
<p><code>Lab 3</code> 要求服务端将客户端请求成功的结果放到 <code>RPC</code> 响应中，不过 <code>Raft.Start()</code> 的执行成功不代表最终日志的应用成功，所以服务端调用 <code>Raft.Start()</code> 后需要阻塞等待，直到 <code>Raft</code> 将对应日志应用到状态机。等待/唤醒的模式可以想到使用条件变量 <code>sync.Cond</code>，不过 <code>Go</code> 中有 <code>channel</code> 这个更方便的特性来实现。</p>
<p>正常情况下，服务端调用 <code>Raft.Start()</code> 添加日志的顺序和之后从 <code>applyCh</code> 中收到日志的顺序一致，也就是说客户端请求到达服务端并被处理的顺序和服务端从 <code>applyCh</code> 中收到日志的顺序一致。所以，服务端可以维护一个客户端请求的队列，队列中存放的是 <code>channel</code>，每当服务端从 <code>applyCh</code> 中收到日志，就将日志发送到队首的 <code>channel</code> 中，并从队列中移除。这样阻塞等待中的 <code>RPC</code> 服务端线程就能被唤醒，并响应客户端。</p>
<p>不过在异常情况下，客户端请求队列和服务端从 <code>applyCh</code> 中收到日志的顺序并不是一一对应，因此服务端收到日志时需要剔除掉队列中无效的请求，并通过 <code>channel</code> 发送一个 <code>ErrWrongLeader</code> 异常，这样客户端就能换一个服务端来重试。由于通过日志索引无法唯一确定一条 <code>Raft</code> 日志，所以需要在 <code>ApplyMsg</code> 中添加 <code>CommandTerm</code> 来标识日志所属的任期，这样服务端从 <code>applyCh</code> 中收到日志后就能通过比较客户端请求队列中的日志任期和索引来判断请求是否有效。</p>
<p>记客户端请求队列队首日志的任期和索引为 <code>(term_client, index_client)</code>，记服务端从 <code>applyCh</code> 收到的日志的任期和索引为 <code>(term_applied, index_applied)</code>。正常情况下有 <code>term_client == term_applied</code> 以及 <code>index_client == index_applied</code>。从服务端角度来说，异常情况有两种，一种是当前服务端不再是主节点，另一种情况是当前服务端依然是主节点，不过中途发生了主从切换可能造成当前的日志和最初的不同。对于第一种情况可以直接清空客户端请求队列，虽然 <code>(term_applied, index_applied)</code> 有可能匹配部分客户端请求，不过由于当前服务端不再是主节点，下次客户端请求的时候本身就要再轮询所有的服务端，所以这里等同于是提前让客户端轮询。对于第二种情况（也考虑原来是从节点后来变成主节点的场景），可以从队首开始遍历客户端请求队列，剔除掉比 <code>(term_applied, index_applied)</code> 小的 <code>(term_client, index_client)</code> 请求，并通过 <code>channel</code> 返回异常（这里需要一个自定义异常，告诉客户端直接重试，因为当前服务端依然是主节点，所以客户端没有必要轮询）。这里的剔除掉比 <code>(term_applied, index_applied)</code> 小的 <code>(term_client, index_client)</code> 请求，指的是仅保留 <code>term_client &gt;= term_applied</code> 和 <code>index_client &gt;= index_applied</code> 的请求，因为根据 <code>Raft</code> 日志的性质，其他情况下的客户端请求都已经不可能被提交。</p>
<p>因此，服务端需要开启一个单独的 <code>goroutine</code>，并不断的从 <code>applyCh</code> 中获取日志，然后根据日志的指令内容更新本地的键值数据库，最后唤醒客户端请求队列中的请求。而如何实现本地键值数据库不是本实验的重点，所以简单使用了一个 <code>map</code>。</p>
<h3 id="客户端请求去重"><a class="markdownIt-Anchor" href="#客户端请求去重"></a> 客户端请求去重</h3>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">6.824 Lab 3: Fault-tolerant Key/Value Service</a> 中提到：</p>
<blockquote>
<p>It’s OK to assume that a client will make only one call into a Clerk at a time.</p>
</blockquote>
<p>一个客户端一次只发送一个请求，加上请求阻塞的特性，任何时刻每个客户端都最多只有一个进行中的请求。为了对请求去重，每个客户端可以生成一个唯一的客户端 <code>id</code>，每次发请求时生成一个递增的请求序号，而服务端只需要维护每个客户端已提交到状态机的最大请求序号即可，这是因为当前场景下每个客户端的请求序列是个递增的序列（非严格递增，相邻数字之间可能存在重复）。所以，当服务端收到请求时，如果发现请求中的序号小于等于该客户端的最大请求序号，则说明该请求是重复的。</p>
<p>不过，处理重复的读请求有两种方案，一种是返回当前值，另一种是返回第一次收到读请求时的值。两种方式都可解释，本实验中直接返回当前值即可。</p>
<p>那么服务端收到 <code>Raft</code> 日志时如何知道这个日志对应的客户端请求序号？这个属于应用层面的数据，可以将客户端 <code>id</code> 和请求序号放到 <code>Op</code> 中，服务端收到 <code>Raft</code> 的日志后，将 <code>ApplyMsg.Command</code> 进行类型转换，转为 <code>Op</code> 即可。</p>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<h4 id="testspeed3a"><a class="markdownIt-Anchor" href="#testspeed3a"></a> TestSpeed3A</h4>
<p><code>TestSpeed3A</code> 要求每个心跳周期至少完成三次客户端请求，不过在做 <code>Lab 2</code> 时，<code>Raft</code> 收到日志后不会马上发起共识，而是在下一次发送心跳时批量对收到的日志发起共识。又由于 <code>TestSpeed3A</code> 会循环发起请求，每个请求阻塞，服务端只有在收到 <code>applyCh</code> 的日志后才会通知客户端，所以本质上在这个测试中服务端约等于一个心跳周期只处理一个请求。所以需要修改 <code>Raft.Start()</code>，收到日志后开启一个 <code>goroutine</code> 发起心跳。</p>
<h4 id="客户端请求队列无法被唤醒"><a class="markdownIt-Anchor" href="#客户端请求队列无法被唤醒"></a> 客户端请求队列无法被唤醒</h4>
<p>服务端收到 <code>Raft</code> 的日志后才唤醒客户端请求队列会造成客户端请求队列永远不会被唤醒，因为这强依赖于某条日志被提交，而客户端的日志不一定会被提交。例如，某个服务端收到客户端的请求，将请求放到队列中，此时服务端发生异常，其他服务端成为新的主节点，而新的主节点并没有收到客户端的日志，在没有其他客户端请求的情况下，最开始的客户端请求永远不会被唤醒。所以，这里也额外开启了一个 <code>goroutine</code>，如果当前服务端不是主节点且客户端请求队列不为空，则清空客户端请求队列，并通知 <code>ErrWrongLeader</code> 异常。</p>
<p>不过，这个策略也会带来一个请求重复执行的问题。当前身为主节点的服务端成功提交了某个客户端的请求，注意这里是 <code>commit</code>，而不是 <code>apply</code>，此时服务端发生异常，另一个服务端成为新的主节点，原来的服务端发现自己不是主节点并且请求队列不为空，则清空了请求队列，然后客户端发起重试，新的主节点收到了请求并成功提交，最后 <code>Raft</code> 的日志中就会有两条内容一样的日志，但是 <code>Raft</code> 并不关心两条日志的内容是否相同。所以这个去重需要在服务端处理，服务端从 <code>applyCh</code> 收到日志后，需要判断日志中对应的请求是否已被处理。造成这个问题的主要原因在于 <code>Raft</code> 处理日志的 <code>commit</code> 和 <code>apply</code> 之间存在时间差，而服务端只通过 <code>applyCh</code> 和 <code>Raft</code> 进行交互。</p>
<h2 id="3b"><a class="markdownIt-Anchor" href="#3b"></a> 3B</h2>
<p>引入快照之后，服务端从 <code>applyCh</code> 收到日志时需要判断是否是快照消息，如果是快照消息则执行快照逻辑。<code>3B</code> 整体难度低于 <code>3A</code>，快照的代码逻辑类似于 <code>Lab 2</code> 中的快照代码，不过要注意两点：</p>
<ol>
<li>快照会通过 <code>RPC</code> 发送，所以涉及快照的字段命名注意首字母大写</li>
<li><code>Raft</code> 收到快照 <code>RPC</code> 后，再通过 <code>applyCh</code> 发送快照，但是服务端从 <code>applyCh</code> 中收到的快照消息不一定是最新的，即快照的最远日志索引有可能会落后于服务端已经应用到状态机的最远日志索引（因为 <code>Raft</code> 层收到的快照可能只覆盖了当前日志的一部分，而 <code>Raft</code> 往 <code>applyCh</code> 中发送已应用的日志或快照间没有顺序关系，所以对于服务端来说已经应用到状态机的日志索引可能会大于快照中的日志索引。）。如果快照不是最新的，服务端直接忽略即可，避免覆盖当前的状态机。如何知道当前快照不是最新的？服务端可以记录已提交到本地状态机的最大 <code>ApplyMsg.CommandIndex</code>，收到快照消息后将其和快照消息中的 <code>ApplyMsg.SnapshotIndex</code> 比较即可</li>
</ol>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">6.824 Lab 3: Fault-tolerant Key/Value Service</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/05/30/mit-6.824-lab3-students-guide-to-raft-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/30/mit-6.824-lab3-students-guide-to-raft-part-2/" class="post-title-link" itemprop="url">MIT 6.824 - Lab 3 (1): Students' Guide to Raft（续）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-30T00:00:00+08:00">2022-05-30</time>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a> 是 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/">MIT 6.824: Distributed Systems</a> 之前的助教写给学生看的实验生存指南。在 <a href="/2022/05/06/mit-6.824-lab2-students-guide-to-raft/">MIT 6.824 - Lab 2 (1): Students’ Guide to Raft</a> 中介绍了关于 <code>Lab 2</code> 的部分，本文将继续介绍关于 <code>Lab 3</code> 的部分。</p>
<p>在 <code>Lab 3</code> 中，我们需要实现一个基于 <code>Raft</code> 的 <code>Key-Value</code> 数据库，本文描述了某些对实现可能有帮助的细节。</p>
<h2 id="提交客户端操作"><a class="markdownIt-Anchor" href="#提交客户端操作"></a> 提交客户端操作</h2>
<p>实现客户端请求时可能会先直接发一个请求给客户端所认为的主节点，然后对应的服务端等待 <code>Raft</code> 应用日志，接着服务端执行客户端的请求逻辑，最后再把结果返回给客户端。这种方式适合单客户端的系统，不过不适合多客户端并发的系统。在多客户端请求下，每个客户端请求都有可能修改系统状态，即使各 <code>Raft</code> 节点的日志保持一致，由于各客户端请求间可能相互交替执行，服务端本地状态可能和 <code>Raft</code> 节点的最新日志不一致，除非使用全局的锁隔离各客户端请求，不过系统会退化为串行程序。</p>
<p>文中建议将服务端当做状态机处理，每个客户端的请求本质上都是将状态机从一个状态转变为另一个状态。服务端中有一个专门的线程来处理客户端请求，该线程每次获取一个客户端请求，然后将其提交给 <code>Raft</code>，之后收到 <code>Raft</code> 应用日志的通知后，按顺序将客户端命令应用到服务端的本地状态机中，这里虽然看起来也是串行处理客户端请求，不过由于 <code>Raft.Start()</code> 方法会立即返回，当有大量请求时，<code>Raft</code> 在实现时会批量发送日志。这个线程是整个服务端中唯一能修改本地状态机的地方，所以服务端的 <code>RPC</code> 就简化为了向任务队列中提交任务，并且当 <code>applyCh</code> 接收到可以执行的日志时，将日志所对应的命令应用到本地状态机中，然后响应客户端。</p>
<p>不过，这也带来了一个问题：什么时候知道某个客户端请求执行完成了？这在一切正常的情况下非常简单，因为我们是按序将客户端请求提交给 <code>Raft</code>，所以最后从 <code>applyCh</code> 中出来的日志的顺序就是提交客户端请求的顺序。不过，当前客户端所通信的服务端有可能在中途不再是主节点，所以客户端所发送的日志有可能被丢弃，此时客户端需要能够知道发生了异常，然后尝试换一个服务端。</p>
<p>一个简单的方法是记录提交客户端请求时 <code>Raft</code> 返回的日志索引，然后从 <code>applyCh</code> 收到对应索引的日志时，判断该条日志是否对应最初的客户端请求（可以向 <code>ApplyMsg.Command</code> 添加额外的信息来标识是否是当初的请求）。如果不是同一条请求，则说明发生了异常。</p>
<h2 id="识别重复请求"><a class="markdownIt-Anchor" href="#识别重复请求"></a> 识别重复请求</h2>
<p>因为客户端异常重试的机制存在，所以服务端需要能识别出重复的客户端请求：例如某个客户端发送 <code>APPEND</code> 请求，当前服务端成功执行但是客户端没有收到响应，客户端会选择一个新的服务端发送请求，新的服务端需要确保 <code>APPEND</code> 请求不会被执行两次。因此，每个客户端请求需要一个唯一的标识，使得服务端能够识别已经执行的请求。另外，由于客户端会选择不同的服务端发送请求，各服务端需要对已执行的客户端请求达成共识。</p>
<p>有很多方法来为客户端请求生成唯一的标识符。一种简单并且相对有效的方法是先给每个客户端分配一个唯一的标识符，然后给每一个请求附带一个递增的序列号。如果某个客户端重新发送请求，则会复用之前的请求序列号。各服务端需要维护每个客户端最新的请求序列号，如果服务端发现客户端的请求序列号已处理，则直接忽略该请求。</p>
<h2 id="难以定位的边界条件"><a class="markdownIt-Anchor" href="#难以定位的边界条件"></a> 难以定位的边界条件</h2>
<p>如果按照上述的方式实现，有可能会遇到两个难以定位的问题。</p>
<h3 id="重复出现的日志索引"><a class="markdownIt-Anchor" href="#重复出现的日志索引"></a> 重复出现的日志索引</h3>
<p><code>Raft.Start()</code> 会返回所添加的日志的索引，不过在实际实现时可能会认为这个索引不会重复返回，或者遇到重复的索引时会认为前一个相同索引的日志所对应的请求已经执行失败。不过实际上这两种看法都不正确，即使没有个任何一个服务端发生异常。</p>
<p>假设有 <code>S1</code> 到 <code>S5</code> 五个节点，一开始 <code>S1</code> 是主节点，并且没有日志，然后系统发生以下交互：</p>
<ol>
<li><code>S1</code> 收到两个客户端请求 <code>C1</code> 和 <code>C2</code></li>
<li><code>S1</code> 分别返回日志索引1和2给 <code>C1</code> 和 <code>C2</code></li>
<li><code>S1</code> 发送包含了 <code>C1</code> 和 <code>C2</code> 的 <code>AppendEntries</code> 请求给其他从节点，其中 <code>S2</code> 收到请求，其余节点均未收到</li>
<li><code>S3</code> 成为候选节点</li>
<li><code>S1</code> 和 <code>S2</code> 不会投票给 <code>S3</code>，但是 <code>S4</code> 和 <code>S5</code> 会，所以 <code>S3</code> 成为新的主节点</li>
<li><code>S3</code> 收到新的客户端请求 <code>C3</code></li>
<li><code>S3</code> 调用 <code>Start()</code> 方法并返回日志索引1给 <code>C3</code></li>
<li><code>S3</code> 发送包含 <code>C3</code> 的 <code>AppendEntries</code> 请求给 <code>S1</code>，<code>S1</code> 丢弃 <code>C1</code> 和 <code>C2</code> 的日志后添加 <code>C3</code></li>
<li><code>S3</code> 在给其他从节点发送 <code>AppendEntries</code> 请求前发生异常</li>
<li><code>S1</code> 成为候选节点，由于它的日志最新，所以再次成为主节点</li>
<li><code>S1</code> 收到新的客户端请求 <code>C4</code></li>
<li><code>S1</code> 调用 <code>Start()</code> 方法并返回日志索引2给 <code>C4</code>（在之前的步骤中，日志索引2也返回给了 <code>C2</code>）</li>
<li><code>S1</code> 在给其他从节点发送 <code>AppendEntries</code> 请求前发生异常，此时 <code>S2</code> 成为候选节点</li>
<li><code>S1</code> 和 <code>S3</code> 不会投票给 <code>S2</code>，但是 <code>S4</code> 和 <code>S5</code> 会，所以 <code>S2</code> 成为新的主节点</li>
<li><code>S2</code> 收到新的客户端请求 <code>C5</code></li>
<li><code>S2</code> 调用 <code>Start()</code> 方法并返回日志索引3给 <code>C5</code></li>
<li><code>S2</code> 成功将 <code>AppendEntries</code> 请求发送给其他所有从节点，在后续的心跳中，<code>leaderCommit = 3</code></li>
</ol>
<p>最终 <code>S2</code> 的日志为 <code>[C1, C2, C5]</code>，此时所有节点在索引位置2处的日志为 <code>C2</code>，这就为开头的两个观点提供了反例：<code>Start()</code> 方法可能返回重复的日志索引，以及遇到重复的索引时不代表前一个相同索引的日志所对应的请求已经执行失败。</p>
<h3 id="四方死锁"><a class="markdownIt-Anchor" href="#四方死锁"></a> 四方死锁</h3>
<p>课程的另一个助教 <a target="_blank" rel="noopener" href="https://stebalien.com/">Steven Allen</a> 发现在实现 <code>Lab 3</code> 时很容易遇到一个四方死锁问题。</p>
<p>不管具体的 <code>Raft</code> 代码如何实现，一般来说都会有一个类似于 <code>Raft.Start()</code> 的方法来使得应用程序添加日志，以及很有可能有一个单独的线程将位于 <code>[lastApplied + 1, commitIndex]</code> 范围内的日志通过 <code>apply()</code> 方法发送给应用程序（<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a> 这篇文章写于2016年，在最新的课程中 <code>Raft</code> 通过 <code>applyCh</code> 来发送日志）。这两个方法很可能都需要持有锁 <code>a</code>。而在应用程序中，很可能会在某个 <code>RPC</code> 中调用 <code>Raft.Start()</code> 方法，然后同样可能有个线程会等待 <code>Raft</code> 的日志应用通知，当这个线程收到通知后，就可以响应客户端。由于这两个方法需要通信（例如，<code>RPC</code> 方法需要知道什么时候客户端请求执行完成），所以很可能也都需要持有锁 <code>b</code>。</p>
<p>上述的方法用 <code>Go</code> 描述如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">RPC</span><span class="params">(args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    a.mutex.Lock()</span><br><span class="line">    i := a.raft.Start(args)</span><br><span class="line">    <span class="comment">// update some data structure so that apply knows to poke us later</span></span><br><span class="line">    a.mutex.Unlock()</span><br><span class="line">    <span class="comment">// wait for apply to poke us</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">Start</span><span class="params">(cmd <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="comment">// do things to start agreement on this new command</span></span><br><span class="line">    <span class="comment">// store index in the log where cmd was placed</span></span><br><span class="line">    r.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">apply</span><span class="params">(index <span class="keyword">int</span>, cmd <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    a.mutex.Lock()</span><br><span class="line">    <span class="keyword">switch</span> cmd := cmd.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> GetArgs:</span><br><span class="line">        <span class="comment">// do the get</span></span><br><span class="line">	<span class="comment">// see who was listening for this index</span></span><br><span class="line">	<span class="comment">// poke them all with the result of the operation</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    a.mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">AppendEntries</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> r.lastApplied &lt; r.commitIndex &#123;</span><br><span class="line">      r.lastApplied++</span><br><span class="line">      r.app.apply(r.lastApplied, r.log[r.lastApplied])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    r.mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设此时系统处于以下状态：</p>
<ul>
<li><code>App.RPC</code> 获取锁 <code>a.mutex</code> 然后调用 <code>Raft.Start</code></li>
<li><code>Raft.Start</code> 正在等待锁 <code>r.mutex</code></li>
<li><code>Raft.AppendEntries</code> 持有锁 <code>r.mutex</code>，然后调用 <code>App.apply</code></li>
</ul>
<p>此时就发生了死锁，因为：</p>
<ul>
<li><code>Raft.AppendEntries</code> 在 <code>App.apply</code> 返回前无法释放锁 <code>r.mutex</code></li>
<li><code>App.apply</code> 在获取锁 <code>a.mutex</code> 前无法返回</li>
<li><code>a.mutex</code> 在 <code>App.RPC</code> 返回前无法被释放</li>
<li><code>App.RPC</code> 在 <code>Raft.Start</code> 返回前无法返回</li>
<li><code>Raft.Start</code> 在获取锁 <code>r.mutex</code> 前无法返回</li>
<li><code>Raft.Start</code> 需要等待 <code>Raft.AppendEntries</code> 释放锁 <code>r.mutex</code></li>
</ul>
<p>有几种方法来避免死锁。其中最简单的就是在 <code>App.RPC</code> 中，调用 <code>a.raft.Start</code> 之后再尝试获取锁。不过这可能会带来个问题，在 <code>a.raft.Start(args)</code> 和 <code>a.mutex.Lock()</code> 执行之间可能触发 <code>app.Apply</code>，造成错失日志通知。所以另一种方法是从 <code>Raft.AppendEntries</code> 中分离出 <code>r.app.apply</code>，由一个单独的线程来调用 <code>r.app.apply</code>，这就保证了服务端不会错过日志的通知，同时又避免了死锁。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiaodan Mao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaodan Mao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
