<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"frederick-s.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Übung macht den Meister">
<meta property="og:url" content="https://frederick-s.github.io/index.html">
<meta property="og:site_name" content="Übung macht den Meister">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaodan Mao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://frederick-s.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Übung macht den Meister</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J1NC2B33VK"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-J1NC2B33VK","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Übung macht den Meister" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Übung macht den Meister</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-mit-6.824"><a href="/mit-6.824/" rel="section"><i class="fas fa-book fa-fw"></i>MIT 6.824</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-赞赏"><a href="/sponsor/" rel="section"><i class="fas fa-heart fa-fw"></i>赞赏</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fas fa-rss fa-fw"></i>RSS</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiaodan Mao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2025/01/01/top-10-games/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/01/top-10-games/" class="post-title-link" itemprop="url">个人向最喜欢的十款单机游戏</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T00:00:00+08:00">2025-01-01</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>817</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>豆瓣个人评分标准：</p>
<ul>
<li>五星：一见钟情，简直停不下来，必然多周目起步</li>
<li>四星：依然优秀，但是相比五星存在无法忽略的缺点，可能会多周目</li>
<li>三星：没什么吸引人的地方，大部分能坚持到一周目结束，基本不会多周目</li>
<li>二星：肉眼可见的烂，中途就弃</li>
<li>一星：还没遇到过</li>
</ul>
<p>以下是个人向五星里最喜欢的十款单机游戏，重剧情、代入感，轻玩法、动作，按接触时间倒序。</p>
<h2 id="赛博朋克2077"><a class="markdownIt-Anchor" href="#赛博朋克2077"></a> 赛博朋克2077</h2>
<p>一开始被蠢驴泼天的 bug 劝退了，一直没有上手。不过，看到 DLC 往日之影发售之后大受好评，而且据说2.0版本相比初版已改进不少，遂抱着试试看的心理购入，最终真香，依然吃蠢驴这套。遗憾的是支线的量不够多，意犹未尽。</p>
<h2 id="上古卷轴5"><a class="markdownIt-Anchor" href="#上古卷轴5"></a> 上古卷轴5</h2>
<p>2024年才接触老滚5，而且还没装 Mod，玩了200小时之后依然觉得还有200小时的内容在等待发掘。个人认为老滚5和荒野之息体现了做开放世界的两个赛道，在老滚5里我能停下来和每个人对话，探索世界的动力在于我会遇到什么样的人，会发生什么事。</p>
<h2 id="荒野大镖客2"><a class="markdownIt-Anchor" href="#荒野大镖客2"></a> 荒野大镖客2</h2>
<p>R 星的另一个代表作道德与法治5由于缺少对三个主角的代入感，加上整体枪车戏份过多，玩了一遍后就没有重拾的动力。反而比较适合大表哥2慢悠悠的世界，最终随着结尾曲响起，代入感达到顶峰，仿佛失去了一位朋友。</p>
<h2 id="女神异闻录5"><a class="markdownIt-Anchor" href="#女神异闻录5"></a> 女神异闻录5</h2>
<p>中二的剧情，新奇的 UI，魔性的音乐，不知不觉就过了100小时，并且回合制战斗也不显得枯燥。</p>
<h2 id="巫师3"><a class="markdownIt-Anchor" href="#巫师3"></a> 巫师3</h2>
<p>蠢驴入坑之作，虽然相比老滚5显得并不开放，但丰富的支线加上优秀的音乐让人流连忘返。</p>
<h2 id="最后生还者"><a class="markdownIt-Anchor" href="#最后生还者"></a> 最后生还者</h2>
<p>线性叙事的巅峰，没有一丝冗余，剧情和动作完美结合，无时无刻不在关注下一秒的走向。</p>
<h2 id="空之轨迹"><a class="markdownIt-Anchor" href="#空之轨迹"></a> 空之轨迹</h2>
<p>一首星之所在伴随至今，相比于现在注水冗余的轨迹系列，剧情优秀，人物感情细腻。</p>
<h2 id="三国志11"><a class="markdownIt-Anchor" href="#三国志11"></a> 三国志11</h2>
<p>独特的水墨画风，恰到好处的音乐，相比于即时制更喜欢回合制的操控，能够一直待在电脑里，历史感十足。</p>
<h2 id="太阁立志传5"><a class="markdownIt-Anchor" href="#太阁立志传5"></a> 太阁立志传5</h2>
<p>自由度满分，做一个躺平散养的人，喝茶交友，四处乱逛，没有 KPI。</p>
<h2 id="最终幻想10"><a class="markdownIt-Anchor" href="#最终幻想10"></a> 最终幻想10</h2>
<p>很难想象当初顶着看不懂的日文玩到了最后，惊艳的 CG 和音乐，共情最深的 FF。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2024/12/29/why-python's-integer-division-floors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/29/why-python's-integer-division-floors/" class="post-title-link" itemprop="url">为什么 Python 的负整数除法结果和 C 不同</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-29T00:00:00+08:00">2024-12-29</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>3 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对于整数-5除以2，在 <code>Python</code> 中的结果是-3，但是在 <code>C</code> 中是-2。如果扩展到其他几种常见的语言，可以看到和 <code>C</code> 一致的比较多：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>-2</td>
</tr>
<tr>
<td>C++</td>
<td>-2</td>
</tr>
<tr>
<td>Java</td>
<td>-2</td>
</tr>
<tr>
<td>C#</td>
<td>-2</td>
</tr>
<tr>
<td>Rust</td>
<td>-2</td>
</tr>
<tr>
<td>Go</td>
<td>-2</td>
</tr>
<tr>
<td>Python</td>
<td>-3</td>
</tr>
<tr>
<td>Ruby</td>
<td>-3</td>
</tr>
</tbody>
</table>
<p>区别在于对于结果-2.5是选择向0取整还是向负无穷取整，<code>Python</code> 和 <code>Ruby</code> 选择了后者。</p>
<p>对于整数 <code>a</code> 和 <code>n</code>，记 <code>a</code> 除以 <code>n</code> 的结果是 <code>q</code>，余数是 <code>r</code>，则有：<code>a = n * q + r</code>，其中 <code>|r| &lt; |n|</code>。在数论中，<code>r</code> 始终是正数，但是不同的编程语言各自有不同的实现。</p>
<blockquote>
<p>In number theory, the positive remainder is always chosen, but in computing, programming languages choose depending on the language and the signs of a or n.</p>
</blockquote>
<h2 id="编程语言实现"><a class="markdownIt-Anchor" href="#编程语言实现"></a> 编程语言实现</h2>
<h3 id="truncated-division"><a class="markdownIt-Anchor" href="#truncated-division"></a> Truncated division</h3>
<p>很多语言采用这种实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>n</mi><mi>c</mi><mo stretchy="false">(</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = trunc(\frac{a}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，其中 <code>trunc</code> 表示向0取整，代表语言如 <code>Java</code>。</p>
<h3 id="floored-division"><a class="markdownIt-Anchor" href="#floored-division"></a> Floored division</h3>
<p><code>Donald Knuth</code> 提倡这种实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">q = \lfloor \frac{a}{n} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>，即向下取整，代表语言如 <code>Python</code>。</p>
<h3 id="euclidean-division"><a class="markdownIt-Anchor" href="#euclidean-division"></a> Euclidean division</h3>
<p><code>Raymond T. Boute</code> 则提倡这种实现，约定：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo>=</mo><mi>s</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mrow><mi mathvariant="normal">∣</mi><mi>n</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌋</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>if n &gt; 0</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">⌈</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌉</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>if n &lt; 0</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">q = sgn(n)\lfloor \frac{a}{|n|} \rfloor =     
    \begin{cases}
      \lfloor \frac{a}{n} \rfloor &amp; \text{if n &gt; 0}\\
      \lceil \frac{a}{n} \rceil &amp; \text{if n &lt; 0}
    \end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0435600000000003em;vertical-align:-0.936em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal">n</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if n &gt; 0</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if n &lt; 0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>即根据 <code>n</code> 的正负号来判断是向下取整还是向上取整，代表语言如 <code>ABAP</code>。</p>
<h3 id="rounded-division"><a class="markdownIt-Anchor" href="#rounded-division"></a> Rounded division</h3>
<p>这是 <code>Common Lisp</code> 和 <code>IEEE 754</code> 采用的实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = round(\frac{a}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，其中 <code>round</code> 使用 <code>rounding half to even</code>，即在常规的取整之外，对于1.5，2.5，x.5这样的数字取整到最近的偶数，例如6.5取整到6，7.5取整到8。</p>
<h3 id="ceiling-division"><a class="markdownIt-Anchor" href="#ceiling-division"></a> Ceiling division</h3>
<p>这是 <code>Common Lisp</code> 提供的另一种实现，约定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mo stretchy="false">⌈</mo><mfrac><mi>a</mi><mi>n</mi></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">q = \lceil \frac{a}{n} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>，即向上取整。</p>
<h2 id="python-实现"><a class="markdownIt-Anchor" href="#python-实现"></a> Python 实现</h2>
<p>回到 <code>Python</code>，很难说上述哪种实现一定最优，<code>Python</code> 的作者提到采用 <code>floored division</code> 是因为对于某些应用来说，如果取模运算返回负数没有意义。例如，给定一个 <code>POSIX timestamp</code>，如何返回该天的时间部分，即时分秒？因为一天有86400秒，假设时间戳是 <code>t</code>，那么 <code>t % 86400</code> 就表示该天过了多少秒，就可以进一步转化为时分秒。而对于在 <code>1970-01-01T00:00:00Z</code> 之前的日期，<code>t</code> 则是负数，采用 <code>floored division</code> 的情况下 <code>t % 86400</code> 依然返回正数，并且结果也是正确的，而 <code>truncated division</code> 则返回负数，需要应用程序进一步处理。</p>
<p>不过，一种编程语言中不一定只提供一种实现，其他实现可以借助函数库。例如，<code>Python</code> 中 <code>-5 % 2</code> 结果是1，实现方式为 <code>floored division</code>，但是 <code>math.fmod(-5, 2)</code> 结果是-1，实现方式为 <code>truncated division</code>。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html">Why Python’s Integer Division Floors</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Modulo">Modulo</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2024/03/31/snowflake-storage-integration-with-s3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/31/snowflake-storage-integration-with-s3/" class="post-title-link" itemprop="url">Snowflake 配置 S3 Storage Integration</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-31T00:00:00+08:00">2024-03-31</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>6 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>Snowflake</code> 的 <code>Data Loading</code> 和 <code>Data Unloading</code> 可以通过 <code>S3</code> 导入和导出数据。用户可以使用 <code>AWS_KEY_ID</code> 和 <code>AWS_SECRET_KEY</code> 来授权 <code>Snowflake</code> 访问 <code>S3</code>，不过出于安全和权限控制的考虑，一般不会这么做。</p>
<p><code>Snowflake</code> 建议通过 <code>Storage Integration</code> 来管理权限。</p>
<h2 id="获取-vpc-id"><a class="markdownIt-Anchor" href="#获取-vpc-id"></a> 获取 VPC ID</h2>
<p>在配置 <code>Storage Integration</code> 前，需要设置 <code>S3</code> 策略。首先获取 <code>Snowflake</code> 的 <code>VPC ID</code>，后续的 <code>S3</code> 策略配置中将只允许该 <code>VPC</code> 访问。</p>
<blockquote>
<p>允许特定 VPC 访问的功能要求 Snowflake 实例和对应的 S3 Bucket 运行在相同的 AWS 区域内。</p>
</blockquote>
<p>切换到 <code>ACCOUNTADMIN</code> 角色在 <code>Snowflake</code> 中执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE ROLE ACCOUNTADMIN;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SYSTEM</span>$GET_SNOWFLAKE_PLATFORM_INFO();</span><br></pre></td></tr></table></figure>
<p>记录下返回的 <code>VPC ID</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;snowflake-vpc-id&quot;:[&quot;vpc-abc&quot;]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-iam-策略"><a class="markdownIt-Anchor" href="#创建-iam-策略"></a> 创建 IAM 策略</h2>
<p>然后，需要创建一个 <code>S3</code> 策略来定义 <code>Snowflake</code> 访问 <code>S3 Bucket</code> 的权限。</p>
<p>从 <code>AWS</code> 控制台进入 <code>IAM</code>，在左侧导航栏 <code>Access management</code> 下选择 <code>Account settings</code>：</p>
<p><img src="/images/snowflake-1.png" alt="alt" /></p>
<p>在 <code>Security Token Service (STS)</code> 下查看所在区域的 <code>STS</code> 状态是否是 <code>Active</code>：</p>
<p><img src="/images/snowflake-2.png" alt="alt" /></p>
<p>接着，在左侧导航栏 <code>Access management</code> 下选择 <code>Policies</code>，之后点击 <code>Create policy</code>：</p>
<p><img src="/images/snowflake-3.png" alt="alt" /></p>
<p>切换到 <code>JSON</code> 后输入 <code>S3</code> 策略：</p>
<p><img src="/images/snowflake-4.png" alt="alt" /></p>
<p>下面的策略中 <code>vpc-abc</code> 是 <code>Snowflake</code> 实例的 <code>VPC</code>，<code>snowflake-storage-integration-example</code> 是示例 <code>Bucket</code> 的名字，<code>unloading</code> 和 <code>loading</code> 是该 <code>Bucket</code> 下的两个文件夹，分别用于 <code>Data Unloading</code> 和 <code>Data Loading</code> 使用：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Statement1&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;s3:PutObject&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;s3:GetObject&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;s3:GetObjectVersion&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;s3:DeleteObject&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;s3:DeleteObjectVersion&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;arn:aws:s3:::snowflake-storage-integration-example/unloading/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;arn:aws:s3:::snowflake-storage-integration-example/loading/*&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;StringEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;aws:SourceVpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vpc-abc&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Statement2&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;s3:ListBucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;s3:GetBucketLocation&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;arn:aws:s3:::snowflake-storage-integration-example&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;StringLike&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;s3:prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">						<span class="string">&quot;unloading/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">						<span class="string">&quot;loading/*&quot;</span></span><br><span class="line">					<span class="punctuation">]</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;StringEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;aws:SourceVpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vpc-abc&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建-iam-角色"><a class="markdownIt-Anchor" href="#创建-iam-角色"></a> 创建 IAM 角色</h2>
<p>接着，创建一个 <code>IAM</code> 角色并绑定前一步创建的 <code>S3</code> 策略。在 <code>IAM</code> 左侧导航栏 <code>Access management</code> 下选择 <code>Roles</code>，之后点击 <code>Create role</code>：</p>
<p><img src="/images/snowflake-5.png" alt="alt" /></p>
<p><code>Trusted entity type</code> 选择 <code>AWS account</code>，然后在 <code>An AWS account</code> 下选择 <code>Another AWS account</code>，<code>Account ID</code> 暂时先填当前账号的 <code>ID</code>，之后会修改：</p>
<p><img src="/images/snowflake-6.png" alt="alt" /></p>
<p>同时，选择 <code>Require external ID (Best practice when a third party will assume this role)</code>，<code>External ID</code> 暂时用一个假的例如 <code>0000</code> 替代，之后同样会修改：</p>
<p><img src="/images/snowflake-7.png" alt="alt" /></p>
<p>最后绑定先前创建的 <code>S3</code> 策略：</p>
<p><img src="/images/snowflake-8.png" alt="alt" /></p>
<p>创建角色之后，记录下角色的 <code>ARN</code>，接下来会用到：</p>
<p><img src="/images/snowflake-9.png" alt="alt" /></p>
<h2 id="创建-storage-integration"><a class="markdownIt-Anchor" href="#创建-storage-integration"></a> 创建 Storage Integration</h2>
<p>这时就可以在 <code>Snowflake</code> 中创建 <code>Storage Integration</code> 了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> STORAGE INTEGRATION snowflake_storage_integration_example</span><br><span class="line">  TYPE <span class="operator">=</span> EXTERNAL_STAGE</span><br><span class="line">  STORAGE_PROVIDER <span class="operator">=</span> <span class="string">&#x27;S3&#x27;</span></span><br><span class="line">  ENABLED <span class="operator">=</span> <span class="literal">TRUE</span></span><br><span class="line">  STORAGE_AWS_ROLE_ARN <span class="operator">=</span> <span class="string">&#x27;arn:aws:iam::123:role/snowflake-integration-role&#x27;</span></span><br><span class="line">  STORAGE_ALLOWED_LOCATIONS <span class="operator">=</span> (<span class="string">&#x27;s3://snowflake-storage-integration-example/loading/&#x27;</span>, <span class="string">&#x27;s3://snowflake-storage-integration-example/unloading/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其中 <code>STORAGE_AWS_ROLE_ARN</code> 是之前所创建的 <code>IAM</code> 角色的 <code>ARN</code>，<code>STORAGE_ALLOWED_LOCATIONS</code> 是示例 <code>Bucket</code> 下的两个文件夹的地址。</p>
<blockquote>
<p>只有授权了 <code>CREATE INTEGRATION</code> 权限的角色才能创建 <code>STORAGE INTEGRATION</code>，默认只有 <code>ACCOUNTADMIN</code> 才有这个权限。</p>
</blockquote>
<h2 id="获取-snowflake-的用户-arn-和-external-id"><a class="markdownIt-Anchor" href="#获取-snowflake-的用户-arn-和-external-id"></a> 获取 Snowflake 的用户 ARN 和 External ID</h2>
<p>接着需要获取所创建的 <code>Storage Integration</code> 对应的 <code>Snowflake</code> <code>IAM</code> 用户的 <code>ARN</code> 和 <code>External ID</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> integration snowflake_storage_integration_example;</span><br></pre></td></tr></table></figure>
<p><img src="/images/snowflake-10.png" alt="alt" /></p>
<p>记录下 <code>STORAGE_AWS_IAM_USER_ARN</code> 和 <code>STORAGE_AWS_EXTERNAL_ID</code>。</p>
<h2 id="授权-snowflake-用户"><a class="markdownIt-Anchor" href="#授权-snowflake-用户"></a> 授权 Snowflake 用户</h2>
<p>回到之前创建的 <code>IAM</code> 角色，在 <code>Trust relationships</code> 下替换掉之前填写的临时 <code>Account ID</code> 和 <code>External ID</code>：</p>
<p><img src="/images/snowflake-11.png" alt="alt" /></p>
<p><img src="/images/snowflake-12.png" alt="alt" /></p>
<p>完成后，我们就可以执行一条 <code>Data Unloading</code> 命令来验证配置是否成功：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> <span class="keyword">into</span> <span class="string">&#x27;s3://snowflake-storage-integration-example/unloading/&#x27;</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> OBJECT_CONSTRUCT_KEEP_NULL(<span class="operator">*</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> MY_DATABASE.MY_SCHEMA.MY_TABLE limit <span class="number">10</span>))</span><br><span class="line">FILE_FORMAT <span class="operator">=</span> (type <span class="operator">=</span> json, COMPRESSION <span class="operator">=</span> <span class="keyword">NONE</span>)</span><br><span class="line">STORAGE_INTEGRATION <span class="operator">=</span> snowflake_storage_integration_example</span><br></pre></td></tr></table></figure>
<p>如果配置成功，那么 <code>Snowflake</code> 会将表 <code>MY_DATABASE.MY_SCHEMA.MY_TABLE</code> 的数据导出到 <code>s3://snowflake-storage-integration-example/unloading/</code> 文件夹下。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.snowflake.com/en/user-guide/data-load-s3-allow">Allowing the Virtual Private Cloud IDs</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.snowflake.com/en/user-guide/data-load-s3-config-storage-integration">Option 1: Configuring a Snowflake storage integration to access Amazon S3</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration">CREATE STORAGE INTEGRATION</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2024/03/03/hospital/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/03/hospital/" class="post-title-link" itemprop="url">【读】Newton 科学世界 - 就诊指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-03T00:00:00+08:00">2024-03-03</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>62</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>翻到了一本压箱底的 <code>Newton 科学世界</code>，本期主题为 <code>就诊指南</code>，大概整理了一下，<a target="_blank" rel="noopener" href="https://1drv.ms/u/s!AgP1jNp0kP4-1kMaeBvVo1xntEtm?e=yYWOFm">源文件</a>。</p>
<p><img src="/images/%E5%B0%B1%E8%AF%8A%E6%8C%87%E5%8D%97.png" alt="alt" /></p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li>Newton 科学世界（2022.5）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2023/08/12/17-reasons-not-to-be-a-manager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/12/17-reasons-not-to-be-a-manager/" class="post-title-link" itemprop="url">【读】17 REASONS NOT TO BE A MANAGER</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2023-08-12T00:00:00+08:00">2023-08-12</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>这是一篇出现在 <code>Hacker News</code> 上的文章，作者阐述了关于不当管理者的17个理由。</p>
<h2 id="17个理由"><a class="markdownIt-Anchor" href="#17个理由"></a> 17个理由</h2>
<h3 id="1-你热爱你所做的事"><a class="markdownIt-Anchor" href="#1-你热爱你所做的事"></a> 1. 你热爱你所做的事</h3>
<ul>
<li>你会为能亲自实现某个功能而兴奋不已吗？</li>
<li>你会时而在敲完一天代码后开心的哼着小曲下班吗？</li>
<li>你会为过去所实现的功能、达成的成就感到自豪吗？</li>
</ul>
<p>如果是的话，那么你是一个幸运的打工人。永远不要低估一颗热爱工作的心，同时也不要想当然的认为无论何时都能重拾这份热爱。</p>
<h3 id="2-找到一份工程师的工作很简单"><a class="markdownIt-Anchor" href="#2-找到一份工程师的工作很简单"></a> 2. 找到一份工程师的工作很简单</h3>
<p>在裁员时代，这点已经不再简单。不过在同等条件下，工程师岗位相对于管理者岗位来说：</p>
<ul>
<li>技能更能够量化，仅从通过面试来说，一部分技能甚至可以在面试过程中不断学习强化</li>
<li>除了特定行业外，工程师的技能一般不和公司深度绑定。在上一家公司培养的技能并不会因为换了家公司就基本没用；而管理者在上一家公司与各团队构建的信任关系则一般无法带到下一家公司，或者换了一家公司后，需要应对未曾遇到的人员关系</li>
</ul>
<h3 id="3-管理者岗位僧多粥少"><a class="markdownIt-Anchor" href="#3-管理者岗位僧多粥少"></a> 3. 管理者岗位僧多粥少</h3>
<p>管理者岗位一个萝卜一个坑，其招聘数量远少于工程师岗位。</p>
<h3 id="4-管理者最先被炒鱿鱼"><a class="markdownIt-Anchor" href="#4-管理者最先被炒鱿鱼"></a> 4. 管理者最先被炒鱿鱼</h3>
<p>如果真要裁员，光裁管理者是不够的，工程师反而有天然的【人数优势】。</p>
<p>除非是一锅端，否则各部门按比例的裁员场景下，应该不会有管理者自告奋勇的说自己产生不了直接价值，底下的人离开我也能转，裁我吧。</p>
<h3 id="5-管理者不易跳槽"><a class="markdownIt-Anchor" href="#5-管理者不易跳槽"></a> 5. 管理者不易跳槽</h3>
<p>除开管理者岗位本身的原因，年龄也有一定的影响，但这不仅仅针对管理者。管理者的年龄一般比下属的工程师大，即使一个工程师在年轻的时候可以一年两跳，到了管理者同样的年纪也可能会变得不容易跳槽。</p>
<h3 id="6-工程师会看轻管理者"><a class="markdownIt-Anchor" href="#6-工程师会看轻管理者"></a> 6. 工程师会看轻管理者</h3>
<p>大家都是打工的，没有必要谁看不起谁。当然也会有唯技术论的工程师，无视技术之外的一切；但同样的，也有始终认为自己是主子的管理者，这种，自然是没有必要迎合的。</p>
<p>那么，管理者需不需要懂技术？如果是放权型管理者，能安心将技术决策委托给核心工程师，是可以不用懂技术的，从而专注发挥好自己的管理长处。不过，这属于可遇不可求的情况，现实中没有那么多的刘备和孔明。虽然作者和他的同事们讨论后都认为所遇到的优秀的管理者都不懂技术，但是优秀的管理者本身是比优秀的工程师更为稀缺的存在。所以，对于一般的管理者，至少在技术上要能认识到十个女人一个月真的生不出孩子。</p>
<h3 id="7-管理者有时候要当坏人"><a class="markdownIt-Anchor" href="#7-管理者有时候要当坏人"></a> 7. 管理者有时候要当坏人</h3>
<p>身为管理者，难免会遇到以下的情况：</p>
<ul>
<li>绩效有人要背 C</li>
<li>裁员指标</li>
<li>传达上头不合理的要求</li>
</ul>
<p>而并不是所有人都愿意和能合理的处理好这些场景。</p>
<h3 id="8-管理者的技能树比你想象中的要少"><a class="markdownIt-Anchor" href="#8-管理者的技能树比你想象中的要少"></a> 8. 管理者的技能树比你想象中的要少</h3>
<p>如果从工程师切到了管理者，可能会觉得自己一直在飘着，不再是实际的执行者，这对于某些工程师来说可能会比较难受。而另一方面，立志往管理线发展的人可能会更乐于去做引导一个产品或项目落地的过程，对实际执行并不太关心，并在这期间逐步提高自己的影响力。</p>
<p>我认为这里能体现管理者水平的地方包含但不限于如何处理：</p>
<ul>
<li>你的目标对你很重要，但对其他人不重要</li>
<li>你有雄心壮志，但其他人只想安分守己</li>
</ul>
<h3 id="9-做得好是你的本分做不好是你的锅"><a class="markdownIt-Anchor" href="#9-做得好是你的本分做不好是你的锅"></a> 9. 做得好是你的本分，做不好是你的锅</h3>
<p>大和田老师在半泽直树1里说过：</p>
<blockquote>
<p>下属的功劳是上司的功绩，上司的过错是下属的责任</p>
</blockquote>
<p>做不好又能把锅甩出去也是管理的一种能力。</p>
<h3 id="10-你需要以-ic-的身份和管理者分庭抗礼"><a class="markdownIt-Anchor" href="#10-你需要以-ic-的身份和管理者分庭抗礼"></a> 10. 你需要以 IC 的身份和管理者分庭抗礼</h3>
<p><code>IC</code> 全称 <code>Individual Contributor</code>，常见翻译为独立贡献者或个人贡献者。<code>IC</code> 最明显的特点是没有管理职责，注意不等同于没有管理工作，他们利用自己的专业水平协同或者独立完成任务，最终可能成为某一方面的专家。</p>
<p><code>IC</code> 也分等级，例如 <code>Dropbox</code> 的软件工程师职位就划分为了 <code>IC1</code> 到 <code>IC7</code>，而管理者岗位则是 <code>M</code> 线。高级的 <code>IC</code> 也会有管理工作，例如项目管理（高级 <code>IC</code> 负责的项目很可能已经不是自己能独立完成的了）或者人员管理（什么地方用什么样的人）。</p>
<p>这里作者认为需要有能够发声的高级 <code>IC</code>，因为他们毕竟还是 <code>IC</code> 线，他们所代表的利益有时也符合普通工程师的利益。如果高级 <code>IC</code> 最终都转到了管理岗，那么本来就人微言轻的普通工程师的利益也更难传达到上层。不过，这也要求公司有能够让高级 <code>IC</code> 开花结果的土壤。</p>
<h3 id="11-管理只是一系列技能你同样能以-ic-的身份去尝试所有有趣的管理工作"><a class="markdownIt-Anchor" href="#11-管理只是一系列技能你同样能以-ic-的身份去尝试所有有趣的管理工作"></a> 11. 管理只是一系列技能，你同样能以 <code>IC</code> 的身份去尝试所有有趣的管理工作</h3>
<p>随着在 <code>IC</code> 路线上的成长，你会逐渐涉及一些技术之外的管理工作。有人可能就会乐于去尝试这些管理工作，例如担任导师，面试，参与决策，制定职业规划等。作者认为一个健康的公司应当鼓励并允许高级 <code>IC</code> 去参与这些工作。这样就避免了参与管理者职责中的一些不讨喜的活，例如绩效考核，裁人等。</p>
<h3 id="12-更难从工作中感到愉悦"><a class="markdownIt-Anchor" href="#12-更难从工作中感到愉悦"></a> 12. 更难从工作中感到愉悦</h3>
<p>修复一个问题或者学习新知识所带来的愉悦可能就此一去不复返，同时，工作中的正反馈周期也可能变长。</p>
<p>不过，这也因人而异，那些享受改完一个高深 <code>Bug</code> 的工程师可能根本不会想着做管理，而有些做管理的人也可能根本不认为改完一个高深的 <code>Bug</code> 是种享受，他们的愉悦点可能在于来自底下的服从。</p>
<h3 id="13-情绪影响会衍生甚至占据你的个人生活"><a class="markdownIt-Anchor" href="#13-情绪影响会衍生甚至占据你的个人生活"></a> 13. 情绪影响会衍生甚至占据你的个人生活</h3>
<p>身为管理者后，会与更多的人打交道，而人不是一个确定的个体，每个人有各自的行为处世，你可能会觉得更心累。</p>
<h3 id="14-你的时间不再属于你"><a class="markdownIt-Anchor" href="#14-你的时间不再属于你"></a> 14. 你的时间不再属于你</h3>
<p>普通工程师的时间都不能够一定保证，管理者可能更甚。</p>
<h3 id="15-会议"><a class="markdownIt-Anchor" href="#15-会议"></a> 15. 会议</h3>
<p>更恐怖的是无尽的低效会议。</p>
<h3 id="16-如果你的心之所向是技术引领"><a class="markdownIt-Anchor" href="#16-如果你的心之所向是技术引领"></a> 16. 如果你的心之所向是技术引领</h3>
<p>成为管理者后，你的做事方式就转变为了影响团队，提高团队。你的技术水平也会因此停滞不前，然后逐渐衰退。如果你认为这是一种折磨，那么你就不适合成为管理者。</p>
<h3 id="17-管理者岗位始终会等着你"><a class="markdownIt-Anchor" href="#17-管理者岗位始终会等着你"></a> 17. 管理者岗位始终会等着你</h3>
<p>即使是技术路线越往上走也越会要涉及管理工作，如果你不在乎一个头衔，又何必急于一时。</p>
<h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2>
<p>理想的情况下自然是合适的人在合适的位置上，不过现实中也会有赶鸭子上架而做了管理者的人，或者为了延长自己的职业寿命而无奈转了管理者。但无论如何，管理并不是一个想当然的工作，并不是因为工程师干不下去了所以到时候就转管理，这既不尊重管理岗位本身，也不尊重团队中的其他人，只会多一个不靠谱的管理者，而不靠谱的管理者比不靠谱的工程师更糟糕。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://charity.wtf/2019/09/08/reasons-not-to-be-a-manager/">17 REASONS NOT TO BE A MANAGER</a></li>
<li><a target="_blank" rel="noopener" href="https://dropbox.github.io/dbx-career-framework/overview.html">Dropbox Engineering Career Framework</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2023/03/12/grafana-agent-remote-write-/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/12/grafana-agent-remote-write-/" class="post-title-link" itemprop="url">通过 Grafana Agent 上传 Prometheus 指标数据到 Grafana Cloud</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-12 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-12T00:00:00+08:00">2023-03-12</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>8 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>Grafana Cloud</code> 为免费账户提供了一万条指标的存储额度，对于业余项目来说可以考虑将指标上传到由 <code>Grafana Cloud</code> 托管的 <code>Prometheus</code> 中。</p>
<h2 id="安装-grafana-agent"><a class="markdownIt-Anchor" href="#安装-grafana-agent"></a> 安装 Grafana Agent</h2>
<p><code>Prometheus</code> 指标数据的上传需要通过 <code>Grafana Agent</code> 来完成，以下安装步骤以 <code>Ubuntu</code> 为例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/apt/keyrings/</span><br><span class="line">wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo <span class="built_in">tee</span> /etc/apt/keyrings/grafana.gpg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/grafana.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grafana-agent</span><br></pre></td></tr></table></figure>
<p>安装完成之后通过 <code>sudo systemctl start grafana-agent</code> 将其启动，并可通过 <code>sudo systemctl status grafana-agent</code> 显示 <code>grafana-agent</code> 的当前状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● grafana-agent.service - Monitoring system and forwarder</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/grafana-agent.service; disabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sun 2023-03-12 05:08:43 UTC; 13s ago</span><br><span class="line">       Docs: https://grafana.com/docs/agent/latest/</span><br><span class="line">   Main PID: 1049084 (grafana-agent)</span><br><span class="line">      Tasks: 7 (limit: 1041)</span><br><span class="line">     Memory: 125.6M</span><br><span class="line">     CGroup: /system.slice/grafana-agent.service</span><br><span class="line">             └─1049084 /usr/bin/grafana-agent --config.file /etc/grafana-agent.yaml -server.http.address=127.0.0.1:9090 -server.grpc.address=127.0.0.1:9091</span><br><span class="line"></span><br><span class="line">Mar 12 05:08:43 example-name systemd[1]: Started Monitoring system and forwarder.</span><br></pre></td></tr></table></figure>
<p>同时，如果希望系统重启后自动启动 <code>grafana-agent</code> 服务，可以执行如下的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> grafana-agent.service</span><br></pre></td></tr></table></figure>
<p>另外，可以通过 <code>sudo journalctl -u grafana-agent</code> 查看 <code>grafana-agent</code> 的运行日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Logs begin at Sun 2021-12-26 04:48:21 UTC, end at Sun 2023-03-12 06:34:53 UTC. --</span><br><span class="line">Mar 12 05:08:43 example-name systemd[1]: Started Monitoring system and forwarder.</span><br><span class="line">Mar 12 05:38:45 example-name grafana-agent[1049084]: ts=2023-03-12T05:38:45.6366501Z caller=cleaner.go:203 level=warn agent=prometheus component=cleaner msg=&quot;unable to fi&gt;</span><br><span class="line">Mar 12 06:08:45 example-name grafana-agent[1049084]: ts=2023-03-12T06:08:45.63549564Z caller=cleaner.go:203 level=warn agent=prometheus component=cleaner msg=&quot;unable to f&gt;</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: Stopping Monitoring system and forwarder...</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: grafana-agent.service: Succeeded.</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: Stopped Monitoring system and forwarder.</span><br><span class="line">Mar 12 06:20:16 example-name systemd[1]: Started Monitoring system and forwarder.</span><br></pre></td></tr></table></figure>
<h2 id="上报监控数据"><a class="markdownIt-Anchor" href="#上报监控数据"></a> 上报监控数据</h2>
<p><code>grafana-agent</code> 上报的监控数据分两种，一种是 <code>grafana-agent</code> 自身及其所在主机的监控数据，另一种是自定义服务的监控数据，我们需要修改 <code>grafana-agent</code> 的配置文件来指定如何收集监控数据。</p>
<p><code>grafana-agent</code> 的默认配置文件为 <code>/etc/grafana-agent.yaml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Sample config for Grafana Agent</span><br><span class="line"># For a full configuration reference, see: https://grafana.com/docs/agent/latest/configuration/.</span><br><span class="line">server:</span><br><span class="line">  log_level: warn</span><br><span class="line"></span><br><span class="line">metrics:</span><br><span class="line">  global:</span><br><span class="line">    scrape_interval: 1m</span><br><span class="line">  wal_directory: &#x27;/var/lib/grafana-agent&#x27;</span><br><span class="line">  configs:</span><br><span class="line">    # Example Prometheus scrape configuration to scrape the agent itself for metrics.</span><br><span class="line">    # This is not needed if the agent integration is enabled.</span><br><span class="line">    # - name: agent</span><br><span class="line">    #   host_filter: false</span><br><span class="line">    #   scrape_configs:</span><br><span class="line">    #     - job_name: agent</span><br><span class="line">    #       static_configs:</span><br><span class="line">    #         - targets: [&#x27;127.0.0.1:9090&#x27;]</span><br><span class="line"></span><br><span class="line">integrations:</span><br><span class="line">  agent:</span><br><span class="line">    enabled: true</span><br><span class="line">  node_exporter:</span><br><span class="line">    enabled: true</span><br><span class="line">    include_exporter_metrics: true</span><br><span class="line">    disable_collectors:</span><br><span class="line">      - &quot;mdadm&quot;</span><br></pre></td></tr></table></figure>
<p>自定义服务的监控数据收集需要定义在 <code>metrics.configs</code> 下，<code>grafana-agent</code> 自身及其所在主机的监控数据收集默认已经是开启的。</p>
<p>假设需要收集由 <code>Spring Boot</code> 的 <code>actuator</code> 模块所暴露的 <code>Prometheus</code> 监控数据，则需要在 <code>metrics.configs</code> 下新增如下类似配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">  scrape_configs:</span><br><span class="line">    - job_name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">      metrics_path: &#x27;/actuator/prometheus&#x27;</span><br><span class="line">      scrape_interval: 1m</span><br><span class="line">      static_configs:</span><br><span class="line">        - targets: [&#x27;127.0.0.1:8080&#x27;]</span><br><span class="line">          labels:</span><br><span class="line">            application: &#x27;My Spring Boot App&#x27;</span><br></pre></td></tr></table></figure>
<p>最后，再通过 <code>remote_write</code> 设置将监控数据推送到 <code>Grafana Cloud</code> 下的 <code>Prometheus</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remote_write:</span><br><span class="line">  - url: https://prometheus-xxx.grafana.net/api/prom/push</span><br><span class="line">    basic_auth:</span><br><span class="line">      username: username</span><br><span class="line">      password: password</span><br></pre></td></tr></table></figure>
<p>其中 <code>url</code>，<code>username</code> 和 <code>password</code> 这三个信息都可以在所创建的 <code>Grafana Cloud Stack</code> 下的 <code>Prometheus</code> 的详情页中找到。<code>password</code> 对应 <code>Grafana Cloud API Key</code>，如果之前没有创建过的话需要新生成一个，角色选择 <code>MetricsPublisher</code> 即可：</p>
<p><img src="/images/grafana-cloud-1.png" alt="alt" /></p>
<p>完整的配置文件示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  log_level: warn</span><br><span class="line"></span><br><span class="line">metrics:</span><br><span class="line">  global:</span><br><span class="line">    scrape_interval: 1m</span><br><span class="line">  wal_directory: &#x27;/var/lib/grafana-agent&#x27;</span><br><span class="line">  configs:</span><br><span class="line">    - name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">      scrape_configs:</span><br><span class="line">        - job_name: &#x27;My Spring Boot App&#x27;</span><br><span class="line">          metrics_path: &#x27;/actuator/prometheus&#x27;</span><br><span class="line">          scrape_interval: 1m</span><br><span class="line">          static_configs:</span><br><span class="line">            - targets: [&#x27;127.0.0.1:8080&#x27;]</span><br><span class="line">              labels:</span><br><span class="line">                application: &#x27;My Spring Boot App&#x27;</span><br><span class="line">      remote_write:</span><br><span class="line">        - url: https://prometheus-xxx.grafana.net/api/prom/push</span><br><span class="line">          basic_auth:</span><br><span class="line">            username: username</span><br><span class="line">            password: password</span><br><span class="line"></span><br><span class="line">integrations:</span><br><span class="line">  agent:</span><br><span class="line">    enabled: true</span><br><span class="line">  node_exporter:</span><br><span class="line">    enabled: true</span><br><span class="line">    include_exporter_metrics: true</span><br><span class="line">    disable_collectors:</span><br><span class="line">      - &quot;mdadm&quot;</span><br><span class="line">  prometheus_remote_write:</span><br><span class="line">    - url: https://prometheus-xxx.grafana.net/api/prom/push</span><br><span class="line">      basic_auth:</span><br><span class="line">        username: username</span><br><span class="line">        password: password</span><br></pre></td></tr></table></figure>
<p>配置文件修改完成之后，通过 <code>sudo systemctl restart grafana-agent</code> 来重启 <code>grafana-agent</code> 服务。</p>
<h2 id="grafana-展示"><a class="markdownIt-Anchor" href="#grafana-展示"></a> Grafana 展示</h2>
<p>对于自定义服务的监控展示使用自己熟悉的方式即可，例如 <code>Java</code> 应用可以配合使用 <a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards/4701-jvm-micrometer/">JVM (Micrometer)</a>。</p>
<p>对于 <code>grafana-agent</code> 自身的监控展示可以结合 <a target="_blank" rel="noopener" href="https://github.com/grafana/agent/blob/main/example/docker-compose/grafana/dashboards/agent-remote-write.json">agent-remote-write.json</a>：</p>
<p><img src="/images/grafana-cloud-2.png" alt="alt" /></p>
<p>最后，<code>grafana-agent</code> 对于所在主机的监控展示可以借助 <a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards/1860-node-exporter-full/">Node Exporter Full</a>：</p>
<p><img src="/images/grafana-cloud-3.png" alt="alt" /></p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://grafana.com/docs/agent/latest/set-up/install-agent-linux/">Install Grafana Agent on Linux</a></li>
<li><a target="_blank" rel="noopener" href="https://grafana.com/blog/2020/07/02/getting-started-with-the-grafana-cloud-agent-a-remote_write-focused-prometheus-agent/">Getting started with the Grafana Cloud Agent, a remote_write-focused Prometheus agent</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/12/26/google-api-design-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/26/google-api-design-guide/" class="post-title-link" itemprop="url">【读】Google API Design Guide</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-26T00:00:00+08:00">2022-12-26</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>30k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>49 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><a target="_blank" rel="noopener" href="https://cloud.google.com/apis/design">Google API Design Guide</a> 是 <code>Google</code> 设计 <a target="_blank" rel="noopener" href="https://cloud.google.com/apis/docs/overview">Cloud APIs</a> 和其他 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis">Google APIs</a> 的设计指南。</p>
<p>该指南面向的不仅仅是 <code>REST APIs</code>，同时也适用于 <code>RPC APIs</code>，其中 <code>RPC APIs</code> 主要面向的是 <code>gRPC APIs</code>。</p>
<h2 id="面向资源的设计"><a class="markdownIt-Anchor" href="#面向资源的设计"></a> 面向资源的设计</h2>
<p>传统的 <code>RPC</code> 接口设计面向的是操作，各个接口之间是孤立的，没有明确的关联；不同系统的接口也有着不同的设计风格，存在着一定的学习和使用成本。</p>
<p>而面向资源的设计则将系统抽象为一系列资源，开发者则通过有限的几个标准方法来操作资源，从而实现对系统的修改。对于 <code>RESTful</code> 接口来说，有限的几个标准方法对应的就是 <code>HTTP</code> 请求方法中的 <code>POST</code>，<code>GET</code>，<code>PUT</code>，<code>PATCH</code> 和 <code>DELETE</code>。另一方面，由于遵循了统一的设计，当开发者调用不同系统的接口时，能够自然的假定各个系统都支持相同的标准方法，从而降低了开发者学习的成本。</p>
<blockquote>
<p>不管是面向资源的设计还是其他的设计标准，统一的标准胜过百花齐放，开发者应当将更多的精力放在自身系统的业务实现上，而不是耗费时间学习和调试其他系统的接口。</p>
</blockquote>
<p>该指南建议按照如下的步骤设计面向资源的接口：</p>
<ul>
<li>确定接口所提供的资源类型</li>
<li>确定资源间的关系</li>
<li>根据资源类型和资源间的关系确定资源命名模式</li>
<li>确定资源体系</li>
<li>为每个资源设计最小限度的操作方法</li>
</ul>
<p>在面向资源的设计体系下，各接口一般会按照资源的层级结构进行组织，层级结构中的每个节点可能是单一的资源，也可能是一个资源集合：</p>
<ul>
<li>一个资源集合包含了一系列相同类型的资源，例如，一个用户拥有一个联系人资源集合</li>
<li>一个资源包含了若干的状态，同时也包含了0个或者多个子资源。每个子资源可以是一个单一资源或者是资源集合</li>
</ul>
<p>以创建邮件接口为例，传统的接口设计可能是如下的方式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /createMail</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;userId&quot;: 123,</span><br><span class="line">    &quot;title:&quot; &quot;Title&quot;,</span><br><span class="line">    &quot;from&quot;: &quot;from@example.com&quot;</span><br><span class="line">    &quot;to&quot;: &quot;to@example.com&quot;,</span><br><span class="line">    &quot;body&quot;: &quot;Body&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而面向资源的接口设计则可能为：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /users/&#123;userId&#125;/mails</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;title:&quot; &quot;Title&quot;,</span><br><span class="line">    &quot;from&quot;: &quot;from@example.com&quot;</span><br><span class="line">    &quot;to&quot;: &quot;to@example.com&quot;,</span><br><span class="line">    &quot;body&quot;: &quot;Body&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，面向资源的接口设计体现了资源间的层级关系。一般而言，对于 <code>RESTful</code> 接口来说，请求 <code>URL</code> 中只会包含资源的名称（名词），而不会包含对资源的操作（动词），<code>HTTP</code> 的请求方法就对应了资源的标准操作方法。而该指南讨论的是通用的面向资源的设计，其对应的资源标准操作方法为：<code>List</code>，<code>Get</code>，<code>Create</code>，<code>Update</code> 和 <code>Delete</code>。</p>
<h2 id="资源名称"><a class="markdownIt-Anchor" href="#资源名称"></a> 资源名称</h2>
<p>在面向资源的设计下，资源是一个命名实体，每个资源都有一个唯一的名称作为其标识符。一个资源的名称由三部分组成：</p>
<ol>
<li>资源的 <code>ID</code></li>
<li>所有父资源的 <code>ID</code></li>
<li><code>API</code> 服务名，如 <code>gmail.googleapis.com</code></li>
</ol>
<p>资源集合被视为一种特殊的资源，它包含了一组相同类型的子资源，例如一个目录可以被视为一个资源集合，它包含了一组文件资源。同时，资源集合也有相应的 <code>ID</code>。</p>
<p>资源名称由资源 <code>ID</code> 和资源集合 <code>ID</code> 组成，其定义也体现了资源的层级结构关系，各层级之间使用 <code>/</code> 进行分隔。例如，对于某个对象存储服务中的对象来说，其资源名称可能为 <code>//storage.googleapis.com/buckets/bucket-123/objects/object-123</code>，其中最顶层为服务名，即 <code>//storage.googleapis.com</code>，然后是一个资源集合，即 <code>buckets</code>，对象存储服务一般以 <code>bucket</code> 为维度来管理对象；接下来为了要定位到某个对象，需要先定位到具体的 <code>bucket</code>，<code>bucket-123</code> 就是某个 <code>bucket</code> 的资源 <code>ID</code>，而每个 <code>bucket</code> 下包含了多个对象，进而产生了一个资源集合 <code>objects</code>，最后的 <code>object-123</code> 就是实际对象的资源 <code>ID</code>。</p>
<p>一般来说，一个资源在实现上很可能对应一张数据库的表，所以可以用表的主键来作为资源的 <code>ID</code>。而由于使用了 <code>/</code> 来分隔资源的层级，因此只有最底层的资源才允许资源 <code>ID</code> 中包含 <code>/</code>，从而避免层级歧义。</p>
<blockquote>
<p>如果资源 <code>ID</code> 中包含了 <code>/</code>，则必须在 <code>API</code> 文档中明确声明。</p>
</blockquote>
<p>资源集合更多的是一种层级上的逻辑概念，所以其 <code>ID</code> 命名需要有意义，以及符合以下的规范：</p>
<ol>
<li>必须是以小驼峰形式命名的英文单词复数，如果对应单词没有复数，则应当使用单词的单数形式</li>
<li>必须使用简洁明了的英文单词</li>
<li>避免使用过于宽泛的英文单词，例如，<code>rowValues</code> 优于 <code>values</code>。同时应当避免无条件的使用如下的英文单词：
<ul>
<li>elements</li>
<li>entries</li>
<li>instances</li>
<li>items</li>
<li>objects</li>
<li>resources</li>
<li>types</li>
<li>values</li>
</ul>
</li>
</ol>
<blockquote>
<p>对于 <code>Google</code> 的服务来说，资源集合 <code>ID</code> 还会经常出现在自动生成的客户端类库代码中，所以它们的命名也必须是合法的 <code>C/C++</code> 标识符。</p>
</blockquote>
<p>完整的资源名称是协议无关的，虽然它看起来像 <code>RESTful</code> 服务的 <code>HTTP</code> 接口请求路径，但本质上这是两个东西。实际的资源请求还需要附带版本号，协议等信息，例如对于资源名称 <code>//calendar.googleapis.com/users/john smith/events/123</code> 来说，实际的 <code>RESTful</code> 请求路径可能是 <code>https://calendar.googleapis.com/v3/users/john%20smith/events/123</code>，和原本的资源名称相比有三点不同：</p>
<ol>
<li>指明了具体的协议，<code>HTTPS</code></li>
<li>指明了版本号，<code>v3</code></li>
<li>对资源名称进行了 <code>URL</code> 转义</li>
</ol>
<p><code>Google</code> 的 <code>API</code> 服务要求资源名称必须是字符串，除非有后向兼容的问题，资源名称在跨模块间传递时必须确保没有任何数据丢失。对于资源定义来说，第一个字段应该命名为 <code>name</code>，类型为字符串，用于表示资源的名称，以下是 <code>gRPC</code> 服务的定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 图书馆服务</span><br><span class="line">service LibraryService &#123;</span><br><span class="line">  // 获取一本书</span><br><span class="line">  rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 创建一本书</span><br><span class="line">  rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">      body: &quot;book&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源定义</span><br><span class="line">message Book &#123;</span><br><span class="line">  // 资源名称，必须以 &quot;shelves/*/books/*&quot; 的形式。</span><br><span class="line">  // 例如，&quot;shelves/shelf1/books/book2&quot;。</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // ... 其他属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取书籍请求</span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // 资源名称，例如 &quot;shelves/shelf1/books/book2&quot;。</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建书籍请求</span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // 父资源的名称，例如 &quot;shelves/shelf1&quot;。</span><br><span class="line">  string parent = 1;</span><br><span class="line">  // 需要创建的资源实体，客户端不允许设置 `Book.name` 属性。</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么这里资源的名称字段要定义为 <code>name</code> 而不是 <code>id</code>？首先从命名上来说 <code>name</code> 本身要比 <code>id</code> 更适合作为 <code>名称</code> 一词的命名。其次，<code>name</code> 也是一个较为宽泛的词语，例如文件资源的 <code>name</code> 代表的是文件的名称还是完整的路径？通过将 <code>name</code> 作为标准字段，使得开发人员必须要选择更适合的命名，例如 <code>display_name</code>，<code>title</code> 或者 <code>full_name</code>。</p>
</blockquote>
<p>为什么不直接使用资源 <code>ID</code> 来定位资源？一个系统中往往有多个资源，单纯的资源 <code>ID</code> 不具有辨识度以及缺少上下文信息。例如，如果使用数据库表的自增主键作为资源 <code>ID</code>，则无法简单的通过数字来定位资源。如果想要通过资源 <code>ID</code> 来定位资源，则势必要扩展资源 <code>ID</code> 的定义，例如使用元组来表示资源 <code>ID</code>，如 <code>(bucket, object)</code> 用于定位某个对象存储服务的对象。不过，这也带来了几个问题：</p>
<ol>
<li>对开发人员不友好，需要额外理解和记忆（例如不同资源 <code>ID</code> 的元组元素个数不同，每个元组元素代表的含义是什么）</li>
<li>解析元组比解析字符串更为困难</li>
<li>对基础设施组件不友好，例如日志和访问控制系统无法直接理解元组</li>
<li>限制了 <code>API</code> 设计的灵活性，如提供可复用的 <code>API</code> 接口</li>
</ol>
<h2 id="标准方法"><a class="markdownIt-Anchor" href="#标准方法"></a> 标准方法</h2>
<p>标准方法的作用在于为大多数的服务场景提供统一、易用的接口，超过 70% 的 <code>Google APIs</code> 都是标准方法。<code>Google APIs</code> 设计了5种标准方法：</p>
<ol>
<li><code>List</code></li>
<li><code>Get</code></li>
<li><code>Create</code></li>
<li><code>Update</code></li>
<li><code>Delete</code></li>
</ol>
<p>下表是标准方法和 <code>HTTP</code> 请求方法的映射：</p>
<table>
<thead>
<tr>
<th>标准方法</th>
<th><code>HTTP</code> 请求方法映射</th>
<th><code>HTTP</code> 请求体</th>
<th><code>HTTP</code> 响应体</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>Get &lt;资源集合 <code>URL</code>&gt;</td>
<td>无</td>
<td>资源集合</td>
</tr>
<tr>
<td>Get</td>
<td>GET &lt;资源 <code>URL</code>&gt;</td>
<td>无</td>
<td>资源</td>
</tr>
<tr>
<td>Create</td>
<td>POST &lt;资源集合 <code>URL</code>&gt;</td>
<td>资源</td>
<td>资源</td>
</tr>
<tr>
<td>Update</td>
<td>PUT 或者 PATCH &lt;资源 <code>URL</code>&gt;</td>
<td>资源</td>
<td>资源</td>
</tr>
<tr>
<td>Delete</td>
<td>DELETE &lt;资源 <code>URL</code>&gt;</td>
<td>无</td>
<td>空</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>HTTP</code> 响应体返回的资源可能不会包含资源的全部字段，例如客户端请求时可以指定只返回需要的字段。<br />
如果 <code>Delete</code> 操作不是立即删除资源，例如只是更新资源的某个字段标记删除或者是创建一个 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto">长时间运行任务</a> 来删除资源，则 <code>HTTP</code> 响应体应该包含修改后的资源或者任务信息。</p>
</blockquote>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3>
<p><code>List</code> 方法用于返回一系列同类的资源，同时该接口支持额外的参数从而允许只返回匹配的资源。它适合用于获取有限大小、未缓存的单一资源集合，对于更复杂的场景则可以考虑使用自定义方法中的 <code>Search</code> 接口。</p>
<p>如果想要批量获取资源，例如入参一组资源 <code>ID</code> 来返回每个资源 <code>ID</code> 所对应的资源，则应该考虑实现 <code>BatchGet</code> 的自定义方法，而不是在 <code>List</code> 方法上扩展。</p>
<p><code>List</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p>
<ul>
<li><code>List</code> 方法必须对应 <code>HTTP</code> 的 <code>GET</code> 请求</li>
<li><code>List</code> 方法的 <code>RPC</code> 请求消息体的 <code>name</code> 字段（也就是资源集合名称）应该和 <code>HTTP</code> 的请求路径匹配，如果相匹配，则 <code>HTTP</code> 请求路径的最后一个段必须是字面量（即资源集合 <code>ID</code>）</li>
<li><code>List</code> 方法的 <code>RPC</code> 请求消息体的其他字段应该和 <code>HTTP</code> 请求路径的查询参数相匹配</li>
<li>对应的 <code>HTTP</code> 请求无请求体；<code>List</code> 方法的 <code>API</code> 定义中不允许声明 <code>body</code> 语句</li>
<li><code>HTTP</code> 响应体应该包含一组资源及可选的元数据信息</li>
</ul>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 获取书架上的书</span><br><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">  // List 方法映射为 HTTP GET 请求</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // parent 对应父资源的名称，如 shelves/shelf1</span><br><span class="line">    get: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取书籍集合请求</span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // 父资源的名称，如shelves/shelf1</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // 返回资源的最大个数</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line"></span><br><span class="line">  // 返回第几页的资源集合，其值为前一个 List 请求返回的 next_page_token 字段</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取书籍集合响应</span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  // 返回的书籍资源集合，该字段名应该和方法名中的 Books 相匹配。其数量上限由 ListBooksRequest 中的 page_size 决定</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line"></span><br><span class="line">  // 下一页资源集合的页码信息，用于获取下一页的资源集合；没有下一页时为空</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> Get</h3>
<p><code>Get</code> 方法接收一个资源名称及其他参数来返回某个指定的资源。</p>
<p><code>Get</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p>
<ul>
<li><code>Get</code> 方法必须对应 <code>HTTP</code> 的 <code>GET</code> 请求</li>
<li><code>Get</code> 方法的 <code>RPC</code> 请求消息体的 <code>name</code> 字段（也就是资源名称）应该和 <code>HTTP</code> 的请求路径匹配</li>
<li><code>Get</code> 方法的 <code>RPC</code> 请求消息体的其他字段应该和 <code>HTTP</code> 请求路径的查询参数相匹配</li>
<li>对应的 <code>HTTP</code> 请求无请求体；<code>Get</code> 方法的 <code>API</code> 定义中不允许声明 <code>body</code> 语句</li>
<li><code>Get</code> 方法返回的资源实体应该和 <code>HTTP</code> 的整个响应体相匹配</li>
</ul>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取一本书</span><br><span class="line">rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">  // Get 方法映射为 HTTP GET 请求，资源名称映射到请求路径，无请求体</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // 所请求的资源名称，如 shelves/shelf1/books/book2</span><br><span class="line">    get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取单个书籍请求</span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // 所请求的资源名称，如 shelves/shelf1/books/book2</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create"><a class="markdownIt-Anchor" href="#create"></a> Create</h3>
<p><code>Create</code> 方法接收一个父资源名称，一个资源实体，以及其他的参数来在指定的父资源下创建一个新的资源，并返回创建的资源。</p>
<p>如果某个 <code>API</code> 服务支持创建资源，则应当为每一类的资源创建对应的 <code>Create</code> 方法。</p>
<p><code>Create</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p>
<ul>
<li><code>Create</code> 方法必须对应 <code>HTTP</code> 的 <code>POST</code> 请求</li>
<li><code>Create</code> 方法的 <code>RPC</code> 请求消息体应当包含一个 <code>parent</code> 字段用于表示所创建的资源的父资源的名称</li>
<li><code>Create</code> 方法的 <code>RPC</code> 请求消息体中表示资源实体的各字段应当和 <code>HTTP</code> 请求体中的字段相对应。如果 <code>Create</code> 方法定义中标注了 <code>google.api.http</code>，则必须声明 <code>body: &quot;&lt;resource_field&gt;&quot;</code> 语句</li>
<li><code>Create</code> 方法的 <code>RPC</code> 请求消息体可能包含一个 <code>&lt;resource&gt;_id</code> 字段来允许调用方指定所创建的资源的 <code>id</code>。这个字段可能会包含在资源字段实体内</li>
<li><code>Create</code> 方法的其余参数应当和 <code>URL</code> 的查询参数相匹配</li>
<li><code>Create</code> 方法返回的资源实体应该和 <code>HTTP</code> 的整个响应体相匹配</li>
</ul>
<p>如果 <code>Create</code> 方法允许由调用方指定所创建的资源的名称，并且该资源已经存在，则该请求应当作失败处理并返回错误码 <code>ALREADY_EXISTS</code>；或者由服务端重新生成一个资源名称，并返回创建的资源，同时接口文档应当清晰的标注最终创建的资源的名称有可能和调用方传入的资源名称不同。</p>
<p><code>Create</code> 方法的 <code>RPC</code> 请求消息体中必须包含资源实体，这样当资源实体的定义发生变更时，就无需同时变更请求消息体的定义。如果资源实体中的某些字段无法由客户端设置，则必须将其标注为 <code>Output only</code> 字段。</p>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 在书架上创建一本书</span><br><span class="line">rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Create 方法对应 HTTP 的 POST 请求，URL 请求路径为资源集合名称</span><br><span class="line">  // HTTP 请求体中包含需要创建的资源</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // parent 对应父资源的名称，如 shelves/1</span><br><span class="line">    post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建书籍请求</span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // 父资源名称</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // 资源 id</span><br><span class="line">  string book_id = 3;</span><br><span class="line"></span><br><span class="line">  // 需要创建的资源</span><br><span class="line">  // 字段名称需要和 RPC 方法中的名词对应，即 book -&gt; Book</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个书架</span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1/shelves&quot;</span><br><span class="line">    body: &quot;shelf&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建书架请求</span><br><span class="line">message CreateShelfRequest &#123;</span><br><span class="line">  Shelf shelf = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update"><a class="markdownIt-Anchor" href="#update"></a> Update</h3>
<p><code>Update</code> 方法接收一个资源实体，以及其他的参数来更新指定的资源及其属性，并返回更新后的资源。</p>
<p>资源的可变属性应当能够通过 <code>Update</code> 方法修改，除非该属性包含资源的名称或父资源的名称。资源重命名或者将资源移动到另一个父资源下都不允许在 <code>Update</code> 方法中实现，而应当由自定义方法来实现。</p>
<p><code>Update</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p>
<ul>
<li>标准的 <code>Update</code> 方法应该能够支持更新资源的部分属性，并通过 <code>update_mask</code> 字段来指明需要更新的属性，对应的 <code>HTTP</code> 请求方法为 <code>PATCH</code>。资源实体中标注为 <code>Output only</code> 的属性应该在资源更新时忽略</li>
<li>如果要求 <code>Update</code> 方法实现更为高级的局部更新语义则应当将其作为自定义方法来实现，例如追加新值到资源的某个列表类型的属性上</li>
<li>如果 <code>Update</code> 方法不支持局部属性更新，则对应的 <code>HTTP</code> 请求方法必须是 <code>PUT</code>。不过不建议 <code>Update</code> 方法仅支持全局更新，因为后续如果为资源添加新的属性则可能会有后向兼容问题</li>
<li><code>Update</code> 方法的 <code>RPC</code> 请求消息体中表示资源名称的字段值必须和 <code>URL</code> 中的请求路径相匹配。这个资源名称字段可能包含在资源实体内</li>
<li><code>Update</code> 方法的 <code>RPC</code> 请求消息体中表示资源实体的各字段必须和 <code>HTTP</code> 请求体中的字段相对应</li>
<li><code>Update</code> 方法的其余参数必须和 <code>URL</code> 的查询参数相匹配</li>
<li><code>Update</code> 方法的返回结果必须是更新后的资源实体</li>
</ul>
<blockquote>
<p>既然 URL 中已经有了资源名称，为什么请求体里面还要再传一遍资源名称？关于这一点不同的服务有不同的实现，例如 <code>DigitalOcean</code> 的更新接口就不要求请求体中再传一遍 <code>id</code>：<a target="_blank" rel="noopener" href="https://docs.digitalocean.com/reference/api/api-reference/#operation/apps_update">Update an App</a>。</p>
</blockquote>
<blockquote>
<p><code>Update</code> 方法的返回结果必须是更新后的资源实体看起来是多此一举，但是某些资源的属性必须由服务端来更新，例如资源的更新时间，或者对于 <code>Git</code> 服务来说文件更新后的版本号等等，这些属性更新后也需要返回给客户端。</p>
</blockquote>
<p>如果后端服务允许客户端指定资源名称则 <code>Update</code> 方法允许客户端调用时发送一个不存在的资源名称，然后服务端会自动创建一个新的资源。否则，<code>Update</code> 方法应当作失败处理并返回 <code>NOT_FOUND</code> 的错误码（如果这是唯一的错误的话）。</p>
<p>即使 <code>Update</code> 方法本身支持新建资源也应当提供额外的 <code>Create</code> 方法，否则服务的使用者可能会感到迷惑。</p>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 更新一本书</span><br><span class="line">rpc UpdateBook(UpdateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Update 方法对应 HTTP 的 PATCH 请求，资源名称映射到请求路径</span><br><span class="line">  // 资源实体包含在 HTTP 请求体中</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // 请求路径包含了需要更新的资源名称</span><br><span class="line">    patch: &quot;/v1/&#123;book.name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新书籍请求</span><br><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // 需要更新的书籍</span><br><span class="line">  Book book = 1;</span><br><span class="line"></span><br><span class="line">  // 指定需要更新的书籍属性，具体定义见 https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> Delete</h3>
<p><code>Delete</code> 方法接受一个资源名称和其他参数来删除或者计划删除某个指定的资源。<code>Delete</code> 方法返回的消息体类型应当为 <code>google.protobuf.Empty</code>。</p>
<p>服务调用方不应该依赖 <code>Delete</code> 方法返回的任何信息，因为 <code>Delete</code> 方法被重复调用时不一定每次都返回相同的信息。</p>
<p><code>Delete</code> 方法和 <code>HTTP</code> 请求的映射关系如下：</p>
<ul>
<li><code>Delete</code> 方法必须对应 <code>HTTP</code> 的 <code>DELETE</code> 请求</li>
<li><code>Delete</code> 方法的 <code>RPC</code> 请求消息体中表示资源名称的字段值应当和 <code>URL</code> 中的请求路径相匹配</li>
<li><code>Delete</code> 方法的其余参数应当和 <code>URL</code> 的查询参数相匹配</li>
<li>对应的 <code>HTTP</code> 请求无请求体；<code>Delete</code> 方法的 <code>API</code> 定义中不允许声明 <code>body</code> 语句</li>
<li>如果 <code>Delete</code> 方法在实现时是立即删除资源则该方法返回的消息体为空</li>
<li>如果 <code>Delete</code> 方法在实现时是创建一个 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto">长时间运行任务</a> 来删除资源，则该方法返回的消息体应当为对应的任务信息</li>
<li>如果 <code>Delete</code> 方法在实现时仅将资源标记为删除而不是物理删除，则该方法应当返回更新后的资源</li>
</ul>
<p><code>Delete</code> 方法应当是幂等的，但并不要求每次都返回相同的信息。对同一个资源的多个 <code>Delete</code> 请求应当使得该资源（最终）被删除，不过只有第一个成功删除资源的请求应当返回相应的成功信息，其余的请求应当返回 <code>google.rpc.Code.NOT_FOUND</code> 错误码。</p>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 删除一本书</span><br><span class="line">rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) &#123;</span><br><span class="line">  // Delete 方法对应 HTTP 的 DELETE 请求，资源名称映射到请求路径，无 HTTP 请求体</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // 请求路径包含了需要删除的资源名称，例如 shelves/shelf1/books/book2</span><br><span class="line">    delete: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除书籍请求</span><br><span class="line">message DeleteBookRequest &#123;</span><br><span class="line">  // 需要被删除的资源名称，如 shelves/shelf1/books/book2</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义方法"><a class="markdownIt-Anchor" href="#自定义方法"></a> 自定义方法</h2>
<p>标准方法提供了对资源的基础操作功能，它们的职责都较为单一，基本上对应了基础的 <code>CRUD</code> 操作。不过，并不是所有对资源的操作都能或者适合抽象为 <code>CRUD</code> 操作，这也是对于 <code>RESTful</code> 风格的服务经常争论的地方。因此，自定义方法就应运而生。</p>
<p>不过，对于 <code>API</code> 的设计者而言应当尽可能的首选使用标准方法，因为标准方法有着更为统一的语义，对开发者而言更为简单易懂。</p>
<p>自定义方法可以应用于资源，资源集合或者服务。它可能会接收任意类型的输入和返回任意类型的输出，并且支持流式的请求和响应。</p>
<h3 id="http-请求映射"><a class="markdownIt-Anchor" href="#http-请求映射"></a> HTTP 请求映射</h3>
<p>对于自定义方法来说，应当使用如下的 <code>HTTP</code> 请求映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://service.name/v1/some/resource/name:customVerb</span><br></pre></td></tr></table></figure>
<p>这里之所以选择 <code>:</code> 而不是 <code>/</code> 将 <code>name</code> 和 <code>customVerb</code> 分开是为了支持 <code>name</code> 中包含 <code>/</code> 的情况，例如将文件路径作为资源名称时则获取资源的请求可能为 <code>GET /files/a/long/file/name</code>，则撤销对该文件的删除操作所对应的自定义方法可能为 <code>POST /files/a/long/file/name:undelete</code>，如果 <code>undelete</code> 前用 <code>/</code> 分割则无法识别完整的资源名称。</p>
<p>自定义方法和 <code>HTTP</code> 请求的映射关系应当遵循如下规则：</p>
<ul>
<li>自定义方法应当使用 <code>HTTP</code> 请求的 <code>POST</code> 方法，除非该自定义方法是作为标准方法中的 <code>List</code> 或者 <code>Get</code> 方法的扩展，此时可以使用 <code>HTTP</code> 请求的 <code>GET</code> 方法</li>
<li>自定义方法不应该使用 <code>HTTP</code> 请求的 <code>PATCH</code> 方法，但是可以使用其他 <code>HTTP</code> 请求方法</li>
<li>对于使用 <code>HTTP</code> 请求的 <code>GET</code> 方法的自定义方法来说必须保证接口的幂等性</li>
<li>自定义方法的 <code>RPC</code> 请求消息体中表示资源或者资源集合名称的字段值应当和 <code>URL</code> 中的请求路径相匹配</li>
<li><code>HTTP</code> 请求的路径必须以 <code>:customVerb</code> 的形式结尾</li>
<li>如果自定义方法对应的 <code>HTTP</code> 请求方法允许 <code>HTTP</code> 请求体（如 <code>POST</code>，<code>PUT</code>，<code>PATCH</code> 或者自定义的 <code>HTTP</code> 方法），则该自定义方法的 <code>HTTP</code> 配置中必须声明 <code>body: &quot;*&quot;</code> 语句，并且 <code>RPC</code> 消息体中的剩余字段应当和 <code>HTTP</code> 请求体中的字段相匹配</li>
<li>如果自定义方法对应的 <code>HTTP</code> 请求方法不接受 <code>HTTP</code> 请求体（如 <code>GET</code>，<code>DELETE</code>），则该自定义方法的 <code>HTTP</code> 配置中不允许声明 <code>body</code> 语句，并且 <code>RPC</code> 消息体中的剩余字段应当和 <code>URL</code> 的查询参数相匹配</li>
</ul>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 服务级别的自定义方法</span><br><span class="line">rpc Watch(WatchRequest) returns (WatchResponse) &#123;</span><br><span class="line">  // 对应 HTTP 的 POST 请求，所有请求参数都来自于 HTTP 的请求体</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1:watch&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源集合级别的自定义方法</span><br><span class="line">rpc ClearEvents(ClearEventsRequest) returns (ClearEventsResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/events:clear&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 资源级别的自定义方法</span><br><span class="line">rpc CancelEvent(CancelEventRequest) returns (CancelEventResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/&#123;name=events/*&#125;:cancel&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个批量获取资源的自定义方法</span><br><span class="line">rpc BatchGetEvents(BatchGetEventsRequest) returns (BatchGetEventsResponse) &#123;</span><br><span class="line">  // 对应 HTTP 的 GET 请求</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v3/events:batchGet&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3>
<p>以下是一些自定义方法比标准方法更适合的场景：</p>
<ul>
<li>重启一台虚拟机：其中一种反直觉的设计是在重启资源集合下创建一个重启资源，这属于生搬硬套；或者为虚拟机增加一个状态字段，重启操作就等价于资源的局部更新操作，即将虚拟机的状态由 <code>RUNNING</code> 改为 <code>RESTARTING</code>，虽然看似合理但是增加了使用人员的心智负担，例如除了这两种状态之外还有其他什么状态？另一方面也增加了接口实现的复杂度，标准方法的 <code>Update</code> 接口需要额外针对状态字段进行逻辑处理，违背了单一职责原则</li>
<li>批处理：对于性能敏感的场景而言，提供批处理的自定义方法比一系列独立的标准方法可能有着更好的性能</li>
</ul>
<blockquote>
<p>对于 <code>RESTful</code> 服务的争论中最常提到的例子就是如何使用 <code>RESTful</code> 接口表示注册/登陆？注册/登陆并不适合作为标准方法来实现，使用自定义方法会更好。一般而言，标准方法的实现应当尽量简单直白，一旦需要对标准方法扩展处理额外的逻辑，就需要考虑是否使用自定义方法更合适。</p>
</blockquote>
<h2 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h2>
<p>错误处理是 <code>RESTful</code> 又一个争论的点，即业务错误可能有很多，<code>HTTP</code> 的状态码根本不够，以及业务的状态码不应该和协议层的状态码相混淆。</p>
<h3 id="错误模型"><a class="markdownIt-Anchor" href="#错误模型"></a> 错误模型</h3>
<p><code>Google API</code> 将错误统一封装为 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto">google.rpc.Status</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package google.rpc;</span><br><span class="line"></span><br><span class="line">// 适用于不同编程环境的统一错误模型，包括 REST 接口和 RPC 接口</span><br><span class="line">message Status &#123;</span><br><span class="line">  // 错误码，具体错误码的定义见 google.rpc.Code</span><br><span class="line">  int32 code = 1;</span><br><span class="line"></span><br><span class="line">  // 错误信息，对错误原因的描述以及可能的修复方式</span><br><span class="line">  string message = 2;</span><br><span class="line"></span><br><span class="line">  // 错误的详细信息，开发人员可以通过详细信息找到一些有用的信息</span><br><span class="line">  repeated google.protobuf.Any details = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于大部分的 <code>Google APIs</code> 都是面向资源的设计，错误处理同样遵循了这样的设计，即使用一系列的标准错误来应对大多数的资源错误场景。例如使用标准的 <code>google.rpc.Code.NOT_FOUND</code> 错误来统一表示某个资源不存在，而不是为每一个资源定义一个 <code>SOME_RESOURCE_NOT_FOUND</code> 错误。</p>
<h4 id="错误码"><a class="markdownIt-Anchor" href="#错误码"></a> 错误码</h4>
<p><code>Google APIs</code> 必须使用 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto">google.rpc.Code</a> 中定义的错误码，不允许独自额外定义错误码。</p>
<h4 id="错误信息"><a class="markdownIt-Anchor" href="#错误信息"></a> 错误信息</h4>
<p>错误信息应当能够帮助用户简单快速的理解和解决 <code>API</code> 错误。一般而言，描述错误信息可以遵循如下的规则：</p>
<ul>
<li>不要假设用户是你所开发的服务的专家，他们可能是客户端开发者，运维人员，<code>IT</code> 人员以及应用的终端用户</li>
<li>不要假设用户知晓你所开发的服务任何的实现细节，或者熟悉错误的上下文</li>
<li>尽可能的使得错误信息有助于技术用户（不一定是服务的开发人员）响应错误并修正</li>
<li>保持错误信息简洁。如果可能的话在错误信息中提供一个帮助链接，以便于用户能够提问，反馈或者查找一些有用的信息</li>
</ul>
<blockquote>
<p>错误信息可能会随时变动，应用开发人员不应该强依赖错误信息。</p>
</blockquote>
<h4 id="错误详情"><a class="markdownIt-Anchor" href="#错误详情"></a> 错误详情</h4>
<p><code>Google APIs</code> 定义了一些列标准的 <a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto">错误详情</a>，这些错误详情覆盖了大部分的错误场景，例如配额分配失败以及无效的参数等等。和错误码一样，开发人员应当尽可能的优先使用标准的错误详情。</p>
<p>只有当错误详情有助于应用代码处理错误的情况下才应该考虑引入新的错误详情。如果当前错误只能由人工处理，则应依据错误信息由开发人员处理，而不是引入额外的错误详情。</p>
<p>以下是一些错误详情类型的例子：</p>
<ul>
<li><code>ErrorInfo</code>：提供稳定又可扩展的结构化错误信息</li>
<li><code>RetryInfo</code>：告诉客户端什么时候可以对一个失败的请求进行重试，可能随错误码 <code>Code.UNAVAILABLE</code> 或者 <code>Code.ABORTED</code> 返回</li>
<li><code>QuotaFailure</code>：描述为什么配额分配失败了，可能随错误码 <code>Code.RESOURCE_EXHAUSTED</code> 返回</li>
<li><code>BadRequest</code>：客户端请求参数非法，可能随错误码 <code>Code.INVALID_ARGUMENT</code> 返回</li>
</ul>
<h3 id="错误映射"><a class="markdownIt-Anchor" href="#错误映射"></a> 错误映射</h3>
<p><code>Google APIs</code> 会被不同的编程环境访问，每个环境有自己的错误处理方式，所以需要将前面描述的错误模型对各个编程环境进行适配和映射。</p>
<h4 id="http-映射"><a class="markdownIt-Anchor" href="#http-映射"></a> HTTP 映射</h4>
<p>对于 <code>HTTP</code> 接口来说，出于后向兼容性的考虑，<code>Google APIs</code> 定义了如下的错误模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 适用于 JSON HTTP 接口的错误模型</span><br><span class="line">message Error &#123;</span><br><span class="line">  // 废弃字段，仅用于 v1 格式的错误</span><br><span class="line">  message ErrorProto &#123;&#125;</span><br><span class="line">  // 和 `google.rpc.Status 有着相同的语义，出于和 Google API Client</span><br><span class="line">  // Libraries 后向兼容的考虑多了额外的 status 和 errors 字段</span><br><span class="line">  message Status &#123;</span><br><span class="line">    // 错误码，同时也是 HTTP 状态码，对应 google.rpc.Status.code</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    // 错误信息，对应 google.rpc.Status.message</span><br><span class="line">    string message = 2;</span><br><span class="line">    // 废弃字段，仅用于 v1 格式的错误</span><br><span class="line">    repeated ErrorProto errors = 3;</span><br><span class="line">    // 错误码的枚举值，对应 google.rpc.Status.code</span><br><span class="line">    google.rpc.Code status = 4;</span><br><span class="line">    // 错误详情，对应 google.rpc.Status.details</span><br><span class="line">    repeated google.protobuf.Any details = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  // 实际的错误消息体，之所以要额外包一层也是出于和 Google API Client</span><br><span class="line">  // Libraries 后向兼容的考虑，同时对于开发人员来说错误信息的可读性更高</span><br><span class="line">  Status error = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: 400,</span><br><span class="line">    &quot;message&quot;: &quot;API key not valid. Please pass a valid API key.&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;INVALID_ARGUMENT&quot;,</span><br><span class="line">    &quot;details&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;type.googleapis.com/google.rpc.ErrorInfo&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;API_KEY_INVALID&quot;,</span><br><span class="line">        &quot;domain&quot;: &quot;googleapis.com&quot;,</span><br><span class="line">        &quot;metadata&quot;: &#123;</span><br><span class="line">          &quot;service&quot;: &quot;translate.googleapis.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="grpc-映射"><a class="markdownIt-Anchor" href="#grpc-映射"></a> gRPC 映射</h4>
<p>不同的 <code>RPC</code> 协议有着不同的错误处理模式，对于 <code>gRPC</code> 来说，上述的错误模型在各语言自动生成的代码中已经天然支持。</p>
<h4 id="客户端类库映射"><a class="markdownIt-Anchor" href="#客户端类库映射"></a> 客户端类库映射</h4>
<p>不同的编程语言对于错误处理有着不同的准则，客户端类库会尽量去适配这些准则，例如 <code>google-cloud-go</code> 遇到错误时会返回和 <code>google.rpc.Status</code> 实现了同样接口的错误，而 <code>google-cloud-java</code> 则会直接抛出错误。</p>
<h3 id="错误处理-2"><a class="markdownIt-Anchor" href="#错误处理-2"></a> 错误处理</h3>
<p>下表列出了 <code>google.rpc.Code</code> 定义的所有错误码：</p>
<table>
<thead>
<tr>
<th>HTTP</th>
<th>gRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
</tr>
<tr>
<td>400</td>
<td>INVALID_ARGUMENT</td>
</tr>
<tr>
<td>400</td>
<td>FAILED_PRECONDITION</td>
</tr>
<tr>
<td>400</td>
<td>OUT_OF_RANGE</td>
</tr>
<tr>
<td>401</td>
<td>UNAUTHENTICATED</td>
</tr>
<tr>
<td>403</td>
<td>PERMISSION_DENIED</td>
</tr>
<tr>
<td>404</td>
<td>NOT_FOUND</td>
</tr>
<tr>
<td>409</td>
<td>ABORTED</td>
</tr>
<tr>
<td>409</td>
<td>ALREADY_EXISTS</td>
</tr>
<tr>
<td>429</td>
<td>RESOURCE_EXHAUSTED</td>
</tr>
<tr>
<td>499</td>
<td>CANCELLED</td>
</tr>
<tr>
<td>500</td>
<td>DATA_LOSS</td>
</tr>
<tr>
<td>500</td>
<td>UNKNOWN</td>
</tr>
<tr>
<td>500</td>
<td>INTERNAL</td>
</tr>
<tr>
<td>501</td>
<td>NOT_IMPLEMENTED</td>
</tr>
<tr>
<td>502</td>
<td>N/A</td>
</tr>
<tr>
<td>503</td>
<td>UNAVAILABLE</td>
</tr>
<tr>
<td>504</td>
<td>DEADLINE_EXCEEDED</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Google APIs 可能会并发的检查 API 请求是否满足条件，返回某个错误码不代表其他条件都符合要求，应用代码不应该依赖条件检查的顺序。</p>
</blockquote>
<p>可以看到，即使是相同的 <code>HTTP</code> 状态码其代表的含义也是不同的，此时就需要 <code>status</code> 字段来进一步区分，类似于将所有错误划分几个大类，然后在每个大类中再细分小类，相比于单纯用 <code>HTTP</code> 状态码来表示不同的错误来说更加灵活，扩展性也更好。</p>
<p>与之相对的非 <code>RESTful</code> 做法则是 <code>HTTP</code> 状态码永远返回200，在返回的消息体中定义错误码和错误信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &quot;some data&quot;,</span><br><span class="line">  &quot;code&quot;: 123,</span><br><span class="line">  &quot;message&quot;: &quot;something is wrong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重试错误"><a class="markdownIt-Anchor" href="#重试错误"></a> 重试错误</h4>
<p>对于 <code>503 UNAVAILABLE</code> 错误客户端可以采用 <code>exponential backoff</code> 的方式进行重试，最短重试等待时间应该是1秒，以及默认重试次数应当是1次，除非文档有特别说明。</p>
<p>对于 <code>429 RESOURCE_EXHAUSTED</code> 错误客户端可以等待更长的时间进行重试，不过最短的等待时间应当是30秒。这种重试仅对于长时间运行任务有效。</p>
<p>对于其他的错误，重试可能就不太适合。</p>
<h4 id="错误传播"><a class="markdownIt-Anchor" href="#错误传播"></a> 错误传播</h4>
<p>如果当前服务依赖于其他服务，则不应该直接将其他服务的错误返回给客户端。在进行错误转换时建议：</p>
<ul>
<li>隐藏实现的细节及机密的信息</li>
<li>调整负责该错误的一方，例如当前服务从其他服务收到 <code>INVALID_ARGUMENT</code> 错误时则返回 <code>INTERNAL</code> 错误给客户端</li>
</ul>
<h4 id="错误重现"><a class="markdownIt-Anchor" href="#错误重现"></a> 错误重现</h4>
<p>如果通过日志分析和监控无法解决错误，则应该尝试通过简单、可重复的测试来重现错误。</p>
<h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2>
<h3 id="空响应"><a class="markdownIt-Anchor" href="#空响应"></a> 空响应</h3>
<p>标准方法中的 <code>Delete</code> 方法应当返回 <code>google.protobuf.Empty</code>，除非 <code>Delete</code> 执行的是软删除，此时应当返回更新后的资源实体。</p>
<p>对于自定义方法来说，应当返回各自的 <code>XxxResponse</code> 消息体，因为即使该方法现在没有数据返回随着时间的推移有很大的可能会增加额外的字段。</p>
<h3 id="范围表示"><a class="markdownIt-Anchor" href="#范围表示"></a> 范围表示</h3>
<p>表示范围的字段应当使用左闭右开的区间，并以 <code>[start_xxx, end_xxx)</code> 的形式命名，例如 <code>[start_key, end_key)</code> 或者 <code>[start_time, end_time)</code>。<code>API</code> 应当避免其他形式的范围表示，如 <code>(index, count)</code> 或者 <code>[first, last]</code>。</p>
<h3 id="资源标签"><a class="markdownIt-Anchor" href="#资源标签"></a> 资源标签</h3>
<p>在面向资源的 <code>API</code> 设计下，资源的模式由 <code>API</code> 决定。为了让客户端能够给资源添加自定义的元数据（例如标记某台虚拟机为数据库服务器），资源定义中应当添加一个 <code>map&lt;string, string&gt; labels</code> 字段，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  map&lt;string, string&gt; labels = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="长时间运行操作"><a class="markdownIt-Anchor" href="#长时间运行操作"></a> 长时间运行操作</h3>
<p>如果某个 <code>API</code> 方法需要很长时间才能完成，则该方法应该设计成返回一个长时间运行操作资源给客户端，客户端可以通过这个资源来跟踪方法的执行进展及获取执行结果。<a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto">Operation</a> 定义了标准的接口来处理长时间运行操作，各 <code>API</code> 不允许自行定义额外的长时间运行操作接口以避免不一致。</p>
<p>长时间运行操作资源必须以响应消息体的方式返回给客户端，并且该操作的任何直接结果都应该反应到其他 <code>API</code> 中。例如，如果有一个长时间运行操作用于创建资源，即使该资源未创建完成，<code>LIST</code> 和 <code>GET</code> 标准方法也应该返回该资源，只是该资源会被标记为暂未就绪。当长时间操作完成时，<code>Operation.response</code> 字段应当包含该操作的执行结果。</p>
<p>长时间运行操作可以通过 <code>Operation.metadata</code> 字段来反馈其运行进展。<code>API</code> 在实现时应当为 <code>Operation.metadata</code> 定义消息类型，即使在一开始的实现中不会填充 <code>metadata</code> 字段。</p>
<h3 id="list-方法分页"><a class="markdownIt-Anchor" href="#list-方法分页"></a> List 方法分页</h3>
<p>支持 <code>List</code> 方法的资源集合应当支持分页功能，即使该方法返回的结果集很小。</p>
<p>因为如果一开始 <code>List</code> 方法不支持分页，后续增加分页功能就会使得和原有 <code>API</code> 的行为不一致。客户端在不知道 <code>List</code> 方法使用分页的情况下依然会认为该方法返回的是完整的资源集合，而实际上有可能只是返回了第一页的资源。</p>
<blockquote>
<p>为了兼容旧的逻辑，只能将分页信息设为非必要字段。</p>
</blockquote>
<p>为了支持 <code>List</code> 方法的分页功能，<code>API</code> 应当：</p>
<ul>
<li>在 <code>List</code> 方法的请求消息中定义 <code>string</code> 类型的 <code>page_token</code> 字段。客户端通过该字段来获取指定某页的资源</li>
<li>在 <code>List</code> 方法的请求消息中定义 <code>int32</code> 类型的 <code>page_size</code> 字段。客户端通过该字段来指定每页返回的最大数据量。对于服务端来说，可能会为客户端传入的 <code>page_size</code> 大小设置一个上限。如果 <code>page_size</code> 的值为0，则由服务端来决定需要返回多少数据</li>
<li>在 <code>List</code> 方法的响应消息中定义 <code>string</code> 类型的 <code>next_page_token</code> 字段。客户端通过该字段来获取下一页的资源，如果 <code>next_page_token</code> 的值为 <code>&quot;&quot;</code>，则表示没有下一页的资源</li>
</ul>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string parent = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有分页的实现可能会在响应消息中增加一个 <code>int32</code> 类型的 <code>total_size</code> 字段来表示资源的总个数。</p>
<h3 id="查询子资源集合"><a class="markdownIt-Anchor" href="#查询子资源集合"></a> 查询子资源集合</h3>
<p>有时候客户端可能会希望有一个 <code>API</code> 能够在多个子资源集合间查询资源。例如，某个图书馆 <code>API</code> 有一个书架的资源集合，每个书架包含一个书籍资源集合，客户端可能会希望在多个书架之间搜索某本书。这种情况建议对子资源使用标准的 <code>List</code> 方法，并使用通配符 <code>-</code> 来表示父资源集合，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books?filter=xxx</span><br></pre></td></tr></table></figure>
<h3 id="从子资源集合获取唯一资源"><a class="markdownIt-Anchor" href="#从子资源集合获取唯一资源"></a> 从子资源集合获取唯一资源</h3>
<p>有时候某个子资源集合下的资源在全局父资源下有着唯一的标识符。常规的做法是需要先知道该资源的父资源的名称然后才能获取该资源，这种情况建议对该资源使用标准的 <code>Get</code> 方法，并使用通配符 <code>-</code> 来表示父资源集合。例如，如果某本书在所有的书架上有着唯一的标识符，那么可以使用如下的请求来获取该本书籍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/-/books/&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>另外，该接口返回的资源名称必须是完整的，其父资源名称必须返回实际的值，而不是 <code>-</code>，例如上述的请求应该返回资源名称 <code>shelves/shelf713/books/book8141</code>，而不是 <code>shelves/-/books/book8141</code>。</p>
<h3 id="排序顺序"><a class="markdownIt-Anchor" href="#排序顺序"></a> 排序顺序</h3>
<p>如果某个 <code>API</code> 允许客户端指定资源的排序顺序，则请求消息体中应该包含一个 <code>order_by</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string order_by = ...;</span><br></pre></td></tr></table></figure>
<p><code>order_by</code> 应当遵循 <code>SQL</code> 语法：即使用逗号分割多个字段，例如 <code>&quot;foo,bar&quot;</code>。默认的排序规则是升序，如果需要降序排序，则应当在字段名后增加 <code>&quot; desc&quot;</code> 后缀，例如 <code>&quot;foo desc,bar&quot;</code>。</p>
<p>同时，字段间额外的空格是无关紧要的，例如 <code>&quot;foo,bar desc&quot;</code> 和 <code>&quot;  foo ,  bar  desc  &quot;</code> 是等价的。</p>
<h3 id="请求验证"><a class="markdownIt-Anchor" href="#请求验证"></a> 请求验证</h3>
<p>如果某个 <code>API</code> 有副作用并且需要在执行前验证请求是否有效，则请求消息体中应该包含一个 <code>validate_only</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool validate_only = ...;</span><br></pre></td></tr></table></figure>
<p>如果设置为 <code>true</code>，则该 <code>API</code> 收到请求时仅进行验证而不会实际执行。</p>
<p>如果验证通过，则必须返回 <code>google.rpc.Code.OK</code> 给客户端，并且对于任何有着相同参数的请求都不应该返回 <code>google.rpc.Code.INVALID_ARGUMENT</code> 错误。不过该 <code>API</code> 依然有可能返回其他错误例如 <code>google.rpc.Code.ALREADY_EXISTS</code>。</p>
<h3 id="请求去重"><a class="markdownIt-Anchor" href="#请求去重"></a> 请求去重</h3>
<p>对于网络 <code>API</code> 来说首选幂等的 <code>API</code>，因为当发生网络异常时可以安全的重试。不过某些 <code>API</code> 无法轻易的实现幂等，例如创建一个资源，但是又需要避免重复的请求。这种情况下请求消息体应该包含一个唯一的 <code>ID</code>，例如 <code>UUID</code> 使得服务端能够通过这个唯一的 <code>ID</code> 进行去重：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 服务端根据此唯一的 ID 进行去重</span><br><span class="line">// 该字段应当命名为 request_id</span><br><span class="line">string request_id = ...;</span><br></pre></td></tr></table></figure>
<p>当服务端监测到重复的请求时，服务端应当返回之前成功的相同请求的结果给客户端，因为客户端大概率没有收到之前的返回结果。</p>
<h3 id="枚举默认值"><a class="markdownIt-Anchor" href="#枚举默认值"></a> 枚举默认值</h3>
<p>每一个枚举的定义都必须以0作为起始值，当枚举值未明确时应当使用该0值，同时 <code>API</code> 文档必须标注如何处理0值。</p>
<p>枚举0值应当命名为 <code>ENUM_TYPE_UNSPECIFIED</code>。如果 <code>API</code> 有着通用的默认行为，则枚举值未定义时应当使用0值，否则0值应当被拒绝并返回 <code>INVALID_ARGUMENT</code> 错误。</p>
<p>枚举值示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Isolation &#123;</span><br><span class="line">  // 未定义</span><br><span class="line">  ISOLATION_UNSPECIFIED = 0;</span><br><span class="line">  // 从快照读取数据，如果当前所有的读写操作与并发执行中的事务无法做到逻辑串行执行则发生冲突</span><br><span class="line">  SERIALIZABLE = 1;</span><br><span class="line">  // 从快照读取数据，如果当前有并发执行中的事务写入到相同的行则发生冲突</span><br><span class="line">  SNAPSHOT = 2;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当隔离级别未定义时，服务端可能会采用 SNAPSHOT 或者更优的隔离级别</span><br><span class="line">Isolation level = 1;</span><br></pre></td></tr></table></figure>
<p>在某些情况下可能使用某个惯用名表示枚举0值，例如 <code>google.rpc.Code.OK</code> 是错误码不存在时的默认值，它在语义上等价于 <code>UNSPECIFIED</code>。</p>
<h3 id="语法规则"><a class="markdownIt-Anchor" href="#语法规则"></a> 语法规则</h3>
<p>在某些场景下，需要为特定的数据格式定义简单的语法，例如允许接受的文本输入。为了在各 <code>API</code> 间提供一致的开发体验，<code>API</code> 设计者必须使用如下的 <code>Extended Backus-Naur Form (EBNF)</code> 的变种来定义语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Production  = name &quot;=&quot; [ Expression ] &quot;;&quot; ;</span><br><span class="line">Expression  = Alternative &#123; &quot;|&quot; Alternative &#125; ;</span><br><span class="line">Alternative = Term &#123; Term &#125; ;</span><br><span class="line">Term        = name | TOKEN | Group | Option | Repetition ;</span><br><span class="line">Group       = &quot;(&quot; Expression &quot;)&quot; ;</span><br><span class="line">Option      = &quot;[&quot; Expression &quot;]&quot; ;</span><br><span class="line">Repetition  = &quot;&#123;&quot; Expression &quot;&#125;&quot; ;</span><br></pre></td></tr></table></figure>
<h3 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h3>
<p>设计 <code>API</code> 时应当避免使用无符号整型例如 <code>uint32</code> 和 <code>fixed32</code>，因为某些重要的编程语言或者系统不能很好的支持无符号整型，例如 <code>Java</code>，<code>JavaScript</code> 和 <code>OpenAPI</code>，并且它们很大可能会造成整型溢出错误。另一个问题是不同的 <code>API</code> 可能将同一个值各自解析为不同的无符号整型或者带符号整型。</p>
<p>在某些场景下类型为带符号整型的字段值如果是负数则没有意义，例如大小，超时时间等等；<code>API</code> 设计者可能会用-1（并且只有-1）来表示特殊的含义，例如文件结束符（<code>EOF</code>），无限的超时时间，无限的配额或者未知的年龄等等。这种用法必须明确的在接口文档中标注以避免迷惑。同时 <code>API</code> 设计者也应当标注当整型数值为0时的系统行为，如果它不是非常直白明了的话。</p>
<h3 id="局部响应"><a class="markdownIt-Anchor" href="#局部响应"></a> 局部响应</h3>
<p>在某些情况下，客户端可能只希望获取资源的部分属性。<code>Google API</code> 通过 <code>FieldMask</code> 来支持这一场景。</p>
<p>对于任意 <code>Google API</code> 的 <code>REST</code> 接口，客户端都可以传入额外的 <code>$fields</code> 参数来表明需要获取哪些字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves?$fields=shelves.name</span><br><span class="line">GET https://library.googleapis.com/v1/shelves/123?$fields=name</span><br></pre></td></tr></table></figure>
<h3 id="资源视图"><a class="markdownIt-Anchor" href="#资源视图"></a> 资源视图</h3>
<p>为了减少网络传输，可以允许客户端指定需要返回资源的某个视图而不是完整的资源数据，这需要在请求消息体中增加一个额外的参数，该参数要求：</p>
<ul>
<li>应该是 <code>enum</code> 类型</li>
<li>必须命名为 <code>view</code></li>
</ul>
<p>枚举类型的每一个值都定义了应当返回资源的哪部分数据。具体返回哪部分数据由实现决定并且应当在文档中标注。</p>
<p>接口定义示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*&#125;/books&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum BookView &#123;</span><br><span class="line">  // 未定义，等同于 BASIC</span><br><span class="line">  BOOK_VIEW_UNSPECIFIED = 0;</span><br><span class="line"></span><br><span class="line">  // 默认视图，仅返回作者，标题，ISBN 和书籍 ID</span><br><span class="line">  BASIC = 1;</span><br><span class="line"></span><br><span class="line">  // 完整视图，返回书籍的全部数据，包括书籍的内容</span><br><span class="line">  FULL = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // 指定需要返回书籍的哪个视图</span><br><span class="line">  BookView view = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端就可以通过如下的方式调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://library.googleapis.com/v1/shelves/shelf1/books?view=BASIC</span><br></pre></td></tr></table></figure>
<h3 id="etags"><a class="markdownIt-Anchor" href="#etags"></a> ETags</h3>
<p><code>ETag</code> 用于客户端进行条件请求，例如客户端获取了某个资源后将其缓存，下次再请求相同的资源时附带上之前服务端返回的 <code>ETag</code>，如果服务端判断 <code>ETag</code> 没有发生变化则无需返回完整的资源实体。为了支持 <code>ETag</code>，应当在资源定义时添加 <code>etag</code> 字段，同时其语义应当同 <code>ETag</code> 的常见用法保持一致。</p>
<p><code>ETag</code> 支持强校验和弱校验，弱校验时 <code>ETag</code> 的值需要添加前缀 <code>W/</code>。强校验模式下，如果两个资源有着相同的 <code>ETag</code> 则说明这两个资源的每个字节都是相同的，而且有着相同的额外字段（例如 <code>Content-Type</code>）。这表示强校验模式下获取的多个资源局部响应数据可以组合成为一个完整的资源数据。</p>
<p>相反的，弱校验模式下两个资源有着相同的 <code>ETag</code> 并不能说明两个资源的每一个字节都相同，因此不适合用于缓存字节范围的请求响应。</p>
<p>强弱 <code>ETag</code> 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 强 ETag，包括引号</span><br><span class="line">&quot;1a2f3e4d5b6c7c&quot;</span><br><span class="line">// 弱 ETag，包括前缀和引号</span><br><span class="line">W/&quot;1a2b3c4d5ef&quot;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，引号也是 <code>ETag</code> 的一部分，所以如果 <code>ETag</code> 在 <code>JSON</code> 中表示需要对引号进行转义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 强</span><br><span class="line">&#123; &quot;etag&quot;: &quot;\&quot;1a2f3e4d5b6c7c\&quot;&quot;, &quot;name&quot;: &quot;...&quot;, ... &#125;</span><br><span class="line">// 弱</span><br><span class="line">&#123; &quot;etag&quot;: &quot;W/\&quot;1a2b3c4d5ef\&quot;&quot;, &quot;name&quot;: &quot;...&quot;, ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出字段"><a class="markdownIt-Anchor" href="#输出字段"></a> 输出字段</h3>
<p>一个资源的某些字段可能不允许客户端设置而只能由服务端返回，这些字段应当需要额外标注。</p>
<p>需要注意的是如果仅作为输出的字段在请求消息体中设置了，或者包含在了 <code>google.protobuf.FieldMask</code> 中，服务端也必须接受该请求而不是返回错误，只不过服务端在处理时需要忽略这些输出字段。之所以要这么做是因为客户端经常会复用某个接口返回的资源，将其作为另一个接口的输入，例如客户端可能会先请求获取一个 <code>Book</code> 资源，将其修改后再调用 <code>UPDATE</code> 方法。如果服务端对输出字段进行校验，则要求客户端进行额外的处理来删除这些输出字段。</p>
<p>接口示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/api/field_behavior.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  Timestamp create_time = 2 [(google.api.field_behavior) = OUTPUT_ONLY];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单例资源"><a class="markdownIt-Anchor" href="#单例资源"></a> 单例资源</h3>
<p>当只有一个资源存在于某个父资源下（或服务，如果没有父资源的话）时，则可以使用单例资源。</p>
<p>标准方法的 <code>Create</code> 和 <code>Delete</code> 方法对单例资源无效，单例资源一般随着父资源的创建而创建，<br />
随着父资源的删除而删除。单例资源必须通过标准方法的 <code>Get</code> 和 <code>Update</code> 方法来访问，以及其他适合的自定义方法。</p>
<p>例如，每一个 <code>User</code> 资源可以有一个单例的 <code>Settings</code> 资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">rpc GetSettings(GetSettingsRequest) returns (Settings) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v1/&#123;name=users/*/settings&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc UpdateSettings(UpdateSettingsRequest) returns (Settings) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    patch: &quot;/v1/&#123;settings.name=users/*/settings&#125;&quot;</span><br><span class="line">    body: &quot;settings&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">message Settings &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  // 省略其他字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetSettingsRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateSettingsRequest &#123;</span><br><span class="line">  Settings settings = 1;</span><br><span class="line">  // 支持局部更新</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流式半关闭"><a class="markdownIt-Anchor" href="#流式半关闭"></a> 流式半关闭</h3>
<p>对于任何的双向或者客户端流式 <code>API</code>，服务端应该依赖由 <code>RPC</code> 系统提供、客户端发起的半关闭来完成客户端流。没有必要额外的定义一个完成的消息。</p>
<p>任何在客户端发起半关闭前想要发送的消息都必须定义为请求消息体的一部分。</p>
<h3 id="domain-scoped-名称"><a class="markdownIt-Anchor" href="#domain-scoped-名称"></a> Domain-scoped 名称</h3>
<p><code>domain-scoped</code> 名称指的是添加了域名前缀的实体名称，用于避免不同服务的命名冲突。<code>Google APIs</code> 和 <code>Kubernetes APIs</code> 大量使用了 <code>domain-scoped</code> 名称：</p>
<ul>
<li><code>Protobuf</code> 的 <code>Any</code> 类型：<code>type.googleapis.com/google.protobuf.Any</code></li>
<li><code>Stackdriver</code> 的指标类型：<code>compute.googleapis.com/instance/cpu/utilization</code></li>
<li>标签的键：<code>cloud.googleapis.com/location</code></li>
<li><code>Kubernetes</code> 的 <code>API</code> 版本号：<code>networking.k8s.io/v1</code></li>
<li><code>x-kubernetes-group-version-kind</code> 的 <code>OpenAPI</code> 扩展中的 <code>kind</code> 字段</li>
</ul>
<h3 id="布尔值-vs-枚举-vs-字符串"><a class="markdownIt-Anchor" href="#布尔值-vs-枚举-vs-字符串"></a> 布尔值 vs. 枚举 vs. 字符串</h3>
<p>设计 <code>API</code> 时有时候会遇到需要能够启用或者禁用某个功能的场景，从实现上说可以增加一个 <code>bool</code>，<code>enum</code> 或者 <code>string</code> 类型的字段来控制，具体选择哪种类型可以遵循如下规则：</p>
<ul>
<li>如果确定只有两种状态且不希望在未来扩展时使用 <code>bool</code>，例如 <code>enable_tracing</code> 或者 <code>enable_pretty_print</code></li>
<li>如果希望设计更为灵活但是又不希望改动太频繁时使用 <code>enum</code>，一个评估的准则是一旦 <code>enum</code> 的值确定了，那么一年内只会改动一次或者更低频，例如 <code>enum TlsVersion</code> 或者 <code>enum HttpVersion</code></li>
<li><code>string</code> 有着最大的灵活性，适用于可能会频繁修改的场景，其对应的值必须清晰的在文档中标注，例如：
<ul>
<li><a target="_blank" rel="noopener" href="https://www.unicode.org/reports/tr35/#unicode_region_subtag">Unicode regions</a> 对应的 <code>string region_code</code></li>
<li><a target="_blank" rel="noopener" href="https://www.unicode.org/reports/tr35/#Unicode_locale_identifier">Unicode locales</a> 对应的 <code>string language_code</code></li>
</ul>
</li>
</ul>
<h3 id="数据保留"><a class="markdownIt-Anchor" href="#数据保留"></a> 数据保留</h3>
<p>对于某些服务而言，用户数据非常重要，如果用户数据不小心被软件 <code>bug</code> 或者人为错误删除，在缺少数据保留策略和撤销删除功能的情况下，可能对业务造成灾难性的影响。</p>
<p>一般而言，建议为 <code>API</code> 服务设置如下的数据保留策略：</p>
<ul>
<li>对于用户的元数据，用户设置等其他重要的数据，设置30天的数据保留期。例如监控指标，项目的元数据和服务定义</li>
<li>对于大容量的用户数据，应该设置7天的数据保留期。例如对象存储和数据库表</li>
<li>对于临时的状态数据或者昂贵的存储数据，如果可行的话应该设置1天的数据保留期。例如 <code>memcache</code> 和 <code>Redis</code> 内存中的数据</li>
</ul>
<p>在数据保留期内，可以执行撤销删除的操作从而不会造成数据丢失。</p>
<h3 id="大型传输载荷"><a class="markdownIt-Anchor" href="#大型传输载荷"></a> 大型传输载荷</h3>
<p>网络 <code>API</code> 依赖分层的网络架构来传输数据，大多数的网络协议层对输入和输出的数据量设置了上限，一般而言，<code>32 MB</code> 是大多数系统中常用的大小上限。</p>
<p>如果某个 <code>API</code> 涉及的传输载荷超过 <code>10 MB</code>，则需要选择合适的策略以确保易用性和未来的扩展的需求。对于 <code>Google APIs</code> 来说，建议使用流式传输或者媒体上传/下载的方式来处理大型载荷，在流式传输下，服务端能够以增量同步的方式处理大量数据，例如 <code>Cloud Spanner API</code>。在媒体传输下，大量的数据流先流入到大型的存储系统中，例如 <code>Google Cloud Storage</code>，然后服务端可以异步的从存储系统中读取数据并处理，例如 <code>Google Drive API</code>。</p>
<h3 id="可选的基本类型字段"><a class="markdownIt-Anchor" href="#可选的基本类型字段"></a> 可选的基本类型字段</h3>
<p><code>Protocol Buffers v3</code> 支持 <code>optional</code> 基本类型字段，在语义上等同于众多编程语言中的 <code>nullable</code> 类型，它可以用于区分空值和未设置的值。</p>
<p>在实践中开发人员难以正确的处理可选字段，大多数的 <code>JSON HTTP</code> 客户端类库，包括 <code>Google API Client Libraries</code>，无法正确区分 <code>proto3</code> 的 <code>int32</code>，<code>google.protobuf.Int32Value</code> 以及 <code>optional int32</code>。如果存在一个方案更清晰而且也不需要可选的基本类型字段，则优先选择该方案。如果不使用可选的基本类型字段会造成复杂度上升或者含义不清晰，则选择可选的基本类型字段。但是不允许可选字段搭配包装类型使用。一般而言，从简洁和一致性考虑，<code>API</code> 设计者应当尽量选择基本类型字段，例如 <code>int32</code>。</p>
<h2 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h2>
<p><code>Google APIs</code> 借助版本控制来解决后向兼容问题。</p>
<p>所有的 <code>Google API</code> 接口都必须包含一个主版本号，这个主版本号会附加在 <code>protobuf</code> 包的最后，以及包含在 <code>REST APIs</code> 的 <code>URI</code> 的第一个部分中。如果 <code>API</code> 要引入一个与当前版本不兼容的变更，例如删除或者重命名某个字段，则必须增加主版本号，从而避免引用了当前版本的用户代码受到影响。</p>
<p>所有 <code>API</code> 的新主版本不允许依赖同 <code>API</code> 的前一个主版本。一个 <code>API</code> 本身可能会依赖其他 <code>API</code>，这要求调用方知晓被依赖的 <code>API</code> 的版本稳定性风险。在这种情况下，一个稳定版本的 <code>API</code> 必须只依赖同样是稳定版本的其他 <code>API</code>。</p>
<p>同一个 <code>API</code> 的不同版本在同一个客户端应用内必须能在一段合理的过渡时期内同时生效。这个过渡时期保障了客户端应用升级到新的 <code>API</code> 版本的平滑过渡。同样的，老版本的 <code>API</code> 也必须在废弃并最终停用之前留有足够的过渡时间。</p>
<p>对于会发布 <code>alpha</code> 或者 <code>beta</code> 版本的 <code>API</code> 来说，必须将 <code>alpha</code> 或者 <code>beta</code> 附加在主版本号之后，并且使用如下其一的策略：</p>
<ul>
<li>基于渠道的版本控制（推荐）</li>
<li>基于发布的版本控制</li>
<li>基于可见性的版本控制</li>
</ul>
<h3 id="基于渠道的版本控制"><a class="markdownIt-Anchor" href="#基于渠道的版本控制"></a> 基于渠道的版本控制</h3>
<p><code>stability channel</code> 是在某个稳定性级别下长期进行更新的版本。每个主版本号下的每个稳定性级别最多只有一个版本。因此，在这个策略下，每个主版本最多只有三个可用的版本：<code>alpha</code>，<code>beta</code>，以及 <code>stable</code>。</p>
<p><code>alpha</code> 和 <code>beta</code> 版本必须将稳定性级别附加到主版本号后，而 <code>stable</code> 则不需要也不允许。例如，<code>v1</code> 可用作为 <code>stable</code> 版本的版本号，但是 <code>v1beta</code> 和 <code>v1alpha</code> 不是。类似的，<code>v1beta</code> 或者 <code>v1alpha</code> 可用作为对应的 <code>beta</code> 和 <code>alpha</code> 版本，但是 <code>v1</code> 不行。每个版本下会对新功能进行就地更新而不会修改版本号。</p>
<p><code>beta</code> 版本的功能必须是 <code>stable</code> 版本的功能的超集，同时 <code>alpha</code> 版本的功能必须是 <code>beta</code> 版本的功能的超集。</p>
<p>对于任何版本的 <code>API</code> 来说，其中的元素（字段，消息体，RPC 方法等）都有可能被标记为废弃：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Represents a scroll. Books are preferred over scrolls.</span><br><span class="line">message Scroll &#123;</span><br><span class="line">  option deprecated = true;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>废弃的 <code>API</code> 功能不允许从 <code>alpha</code> 版本继续保留到 <code>beta</code> 版本，也不允许从 <code>beta</code> 版本保留到 <code>stable</code> 版本。也就是说某个功能不能在任何版本中预先废弃。</p>
<p><code>beta</code> 版本的功能可以在废弃后经过合理的时间后删除，建议是180天。对于只存在于 <code>alpha</code> 版本的功能，不一定会标记为废弃，并且删除时也不会通知。</p>
<h3 id="基于发布的版本控制"><a class="markdownIt-Anchor" href="#基于发布的版本控制"></a> 基于发布的版本控制</h3>
<p>在该策略下，<code>alpha</code> 或者 <code>beta</code> 版本的功能在合并到 <code>stable</code> 版本之前只会在有限的时间内可用。因此，一个 <code>API</code> 在每个稳定性级别下可能有任意数量的版本发布。</p>
<blockquote>
<p>基于渠道的版本控制和基于发布的版本控制都会就地更新 <code>stable</code> 版本。</p>
</blockquote>
<p><code>alpha</code> 和 <code>beta</code> 版本发布时需要在 <code>alpha</code> 或者 <code>beta</code> 之后附加一个递增版本号，例如 <code>v1beta1</code> 或者 <code>v1alpha5</code>。<code>API</code> 应当在文档中记录这些版本的时间顺序。</p>
<p>每个 <code>alpha</code> 或者 <code>beta</code> 版本都有可能就地进行后向兼容的更新。对于 <code>beta</code> 版本来说，如果发布了后向不兼容的版本则应当修改 <code>beta</code> 后的版本号，然后发布新的版本。例如，如果当前版本是 <code>v1beta1</code>，则新版本为 <code>v1beta2</code>。</p>
<p>当 <code>alpha</code> 和 <code>beta</code> 版本中的功能合并到 <code>stable</code> 版本之后就可以终止 <code>alpha</code> 或者 <code>beta</code> 版本。<code>alpha</code> 版本可能会在任一时刻终止，但是 <code>beta</code> 版本在终止前应当给用户留有足够的过渡期，建议是180天。</p>
<h3 id="基于可见性的版本控制"><a class="markdownIt-Anchor" href="#基于可见性的版本控制"></a> 基于可见性的版本控制</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/googleapis/googleapis/blob/master/google/api/visibility.proto">API 可见性</a> 是 <code>Google API</code> 基础架构提供的一项高级功能。它允许 <code>API</code> 发布者将一个 <code>API</code> 对外暴露出多个不同的外部 <code>API</code> 视图，每个视图关联一个 <code>API</code> 可见性的标签，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/api/visibility.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Resource &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // 预览功能，勿在生产环境使用</span><br><span class="line">  string display_name = 2</span><br><span class="line">    [(google.api.field_visibility).restriction = &quot;PREVIEW&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见性标签是一个区分大小写的字符串，可以绑定到任意 <code>API</code> 元素上。一般来说，可见性标签应当始终使用全大写字母。所有的 <code>API</code> 元素默认绑定 <code>PUBLIC</code> 的可见性标签，除非显式的声明了可见性。</p>
<p>每个可见性标签本质上是一个允许访问的列表，<code>API</code> 生产者需要授权给 <code>API</code> 消费者合适的可见性标签才能使用 <code>API</code>。换句话说，可见性标签类似于 <code>API</code> 的 <code>ACL</code>（<code>Access Control List</code>）。</p>
<p>每个 <code>API</code> 元素可以绑定多个可见性标签，各可见性标签之间用逗号分割（例如 <code>PREVIEW,TRUSTED_TESTER</code>）。多个可见性标签之间是逻辑或的关系，<code>API</code> 消费者只要授权了其中一个可见性标签就可以使用 <code>API</code>。</p>
<p>一个 <code>API</code> 请求只能使用一个可见性标签，默认使用的是授权给当前 <code>API</code> 消费者的可见性标签。客户端可以显式的指定需要用哪个可见性标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /v1/projects/my-project/topics HTTP/1.1</span><br><span class="line">Host: pubsub.googleapis.com</span><br><span class="line">Authorization: Bearer y29....</span><br><span class="line">X-Goog-Visibilities: PREVIEW</span><br></pre></td></tr></table></figure>
<p><code>API</code> 生产者可以借助可见性标签来实现版本控制，例如 <code>INTERNAL</code> 和 <code>PREVIEW</code>。<code>API</code> 的新功能从 <code>INTERNAL</code> 可见性标签开始，然后升级到 <code>PREVIEW</code> 可见性标签。当功能稳定可用后，就删除所有的可见性标签，即等同于默认的可见性标签 <code>PUBLIC</code>。</p>
<p>总体来说，<code>API</code> 的可见性比 <code>API</code> 版本号更容易实现增量的功能迭代，不过这要求比较成熟的 <code>API</code> 基础架构的支持。<code>Google Cloud APIs</code> 经常使用 <code>API</code> 可见性用于预览功能。</p>
<h2 id="兼容性"><a class="markdownIt-Anchor" href="#兼容性"></a> 兼容性</h2>
<p>这里的兼容性讨论的是对于 <code>API</code> 使用者的影响，<code>API</code> 生产者应当自身知晓为了实现兼容性需要哪方面的工作。</p>
<p>总的来说，<code>API</code> 的小版本更新或者补丁更新不应该对客户端造成兼容性问题。可能的不兼容问题包括：</p>
<ul>
<li>源代码兼容性：针对1.0版本编写的代码升级到1.1版本后编译失败</li>
<li>二进制文件兼容性：针对1.0版本编译生成的二进制文件链接到1.1版本后运行失败</li>
<li>通信兼容性：针对1.0版本编写的应用程序无法和运行1.1版本的服务端通信</li>
<li>语义兼容性：针对1.0版本编写的应用程序升级到1.1版本后能够运行，但是存在不可预知的结果</li>
</ul>
<p>从另一个角度来说，只要主版本号一致，运行着旧版本的客户端程序就能够和运行着新版本的服务端结合使用，并且客户端程序也能轻易的升级小版本。</p>
<h3 id="后向兼容的修改"><a class="markdownIt-Anchor" href="#后向兼容的修改"></a> 后向兼容的修改</h3>
<h4 id="向-api-服务添加新的接口"><a class="markdownIt-Anchor" href="#向-api-服务添加新的接口"></a> 向 API 服务添加新的接口</h4>
<p>从协议角度来看，添加新的接口始终是安全的。需要注意的是有可能新添加的接口名称已经被客户端代码占用了。如果当前新添加的接口与当前存在的接口完全不同，则基本不用担心；但是如果新添加的接口是当前某个存在的接口的简化版本，则有可能和客户端自定义实现的接口冲突。</p>
<h4 id="向-api-接口添加新的方法"><a class="markdownIt-Anchor" href="#向-api-接口添加新的方法"></a> 向 API 接口添加新的方法</h4>
<p>除非新添加的方法和客户端自动生成的代码中的某个方法冲突，否则这也是安全的。</p>
<p>例如当前已经存在了一个 <code>GetFoo</code> 方法，<code>C#</code> 的代码生成器会同时生成一个 <code>GetFooAsync</code> 的方法，如果此时再添加一个 <code>GetFooAsync</code> 方法，则会造成冲突。</p>
<h4 id="向已有的方法添加-http-绑定"><a class="markdownIt-Anchor" href="#向已有的方法添加-http-绑定"></a> 向已有的方法添加 HTTP 绑定</h4>
<p>假设绑定 <code>HTTP</code> 没有任何歧义，那么让服务端响应之前拒绝的 <code>URL</code> 就是安全的。这个操作可能在将某个已有的操作映射到某个新资源时发生。</p>
<h4 id="向请求消息体添加新的字段"><a class="markdownIt-Anchor" href="#向请求消息体添加新的字段"></a> 向请求消息体添加新的字段</h4>
<p>只要服务端在新版本的代码中处理未传入的新字段的逻辑和老版本代码中的逻辑一致，那么添加新的字段就是安全的。</p>
<p>一个最可能出错的场景是添加分页相关的字段：如果 <code>v1.0</code> 版本的代码中没有分页功能，那么也不能将分页功能添加到 <code>v1.1</code> 版本中，除非 <code>page_size</code> 的默认值是无限大（但这通常不是个好的设计）。否则的话依赖了 <code>v1.0</code> 版本的客户端期望一次请求获取所有的数据，但实际上可能只获取了第一页的数据。</p>
<h4 id="向响应消息体添加新的字段"><a class="markdownIt-Anchor" href="#向响应消息体添加新的字段"></a> 向响应消息体添加新的字段</h4>
<p>对于非资源类的响应消息体来说（例如 <code>ListBooksResponse</code>）添加一个字段都不会造成后向兼容性问题，只要新添加的字段不会影响其他字段的行为即可。消息体中之前暴露的字段应当继续以相同的语义保留，即使可能存在冗余。</p>
<p>例如，1.0版本的响应消息体中有一个字段是 <code>contained_duplicates</code> 表示返回的结果存在重复值并已经进行了去重。在1.1版本中新增了 <code>duplicate_count</code> 字段表示重复的数据数量，虽然原有的 <code>contained_duplicates</code> 已经冗余了但是该字段也必须保留。</p>
<h4 id="向枚举添加新值"><a class="markdownIt-Anchor" href="#向枚举添加新值"></a> 向枚举添加新值</h4>
<p>如果枚举是在请求消息体中使用，那么向枚举添加新值是安全的。因为客户端并不关心它们用不到的值。</p>
<p>对于在资源消息体或者响应消息体中的枚举，默认的假设是客户端需要能够处理未知的枚举值。不过，<code>API</code> 生产者应当知晓客户端如何正确的处理新的枚举值不是一件简单的事，因此必须在文档中标注如果客户端遇到未知的枚举值时期望的行为是什么。</p>
<h4 id="添加新的输出字段"><a class="markdownIt-Anchor" href="#添加新的输出字段"></a> 添加新的输出字段</h4>
<p>如果一个字段只可能会由服务端设置并仅作为输出使用，那么添加这个字段也是安全的。服务端可能会校验客户端发送的消息体中的字段，但是如果新添加的输出字段在请求消息体中不存在，服务端不允许抛出异常。</p>
<h3 id="后向不兼容的修改"><a class="markdownIt-Anchor" href="#后向不兼容的修改"></a> 后向不兼容的修改</h3>
<h4 id="移除或者重命名服务字段方法或者枚举值"><a class="markdownIt-Anchor" href="#移除或者重命名服务字段方法或者枚举值"></a> 移除或者重命名服务，字段，方法或者枚举值</h4>
<p>一般来说，移除或者重命名某个客户端代码可能引用的内容都是一次后向不兼容的修改，必须升级主版本号才能更新。对于某些编程语言来说如果引用了旧的名称则会造成编译问题（例如 <code>C#</code> 和 <code>Java</code>）或者对于另一些编程语言来说造成运行时异常或者数据丢失。</p>
<h4 id="更改-http-映射"><a class="markdownIt-Anchor" href="#更改-http-映射"></a> 更改 HTTP 映射</h4>
<p>这里的更改指的是删除然后添加。例如，假设你想将某个已经存在的方法的 <code>HTTP</code> 映射改为 <code>PATCH</code>，而目前暴露的 <code>HTTP</code> 方法是 <code>PUT</code>，你可以添加一个新的 <code>HTTP</code> 映射，但是不能删除原有的 <code>HTTP</code> 映射。</p>
<h4 id="更改字段类型"><a class="markdownIt-Anchor" href="#更改字段类型"></a> 更改字段类型</h4>
<p>即使更改后的字段类型和当前的传输格式兼容，也可能造成客户端生成的代码不兼容，因此也必须升级主版本号才能更新。对于静态编译型编程语言来说，这很容易引入编译问题。</p>
<h4 id="更改资源的命名格式"><a class="markdownIt-Anchor" href="#更改资源的命名格式"></a> 更改资源的命名格式</h4>
<p>不允许修改资源的名称，这也意味着资源集合的名称也不允许修改。</p>
<p>如果客户端能够在 <code>v2.0</code> 版本中访问 <code>v1.0</code> 版本中创建的资源（或者反过来），那么该资源在两个版本中就应当使用相同的资源名称。</p>
<p>另外，有效的资源名称集也不能修改，因为：</p>
<ul>
<li>如果集合变小，那么之前成功的请求就有可能失败</li>
<li>如果集合变大，那么客户端基于之前关于资源名称的假设可能失效。因为客户端很可能会根据资源名称所允许的字符和长度将其存储在其他地方，以及构建自己的资源名称验证规则</li>
</ul>
<h4 id="更改现有请求的可见行为"><a class="markdownIt-Anchor" href="#更改现有请求的可见行为"></a> 更改现有请求的可见行为</h4>
<p>客户端经常会依赖 <code>API</code> 的行为和语义，即使这些行为没有明确的表示支持或者在文档中说明。因此，在大多数情况下更改 <code>API</code> 的行为会造成后向不兼容问题。如果你的 <code>API</code> 的行为不是非常的隐秘，你都应该假设用户已经识别出 <code>API</code> 的行为并依赖它。</p>
<p>因此，加密分页功能中的页码信息就很有必要（即使该数据没有什么意义），从而防止用户自行创建页码信息，然后当页码行为更改时遭遇后向不兼容问题。</p>
<h4 id="更改-http-定义中的-url-格式"><a class="markdownIt-Anchor" href="#更改-http-定义中的-url-格式"></a> 更改 HTTP 定义中的 URL 格式</h4>
<p>除了资源名称之外，还有两个关于 <code>URL</code> 格式的修改：</p>
<ul>
<li>自定义方法的名称：虽然自定义方法名称不是资源名称的一部分，但依然是 <code>REST</code> 请求路径的一部分，虽然修改 <code>HTTP</code> 的自定义方法名称不会破坏 <code>gRPC</code> 客户端，但依然要假设存在 <code>REST</code> 客户端的用户</li>
<li>资源参数名称：例如从 <code>v1/shelves/&#123;shelf&#125;/books/&#123;book&#125;</code> 修改为 <code>v1/shelves/&#123;shelf_id&#125;/books/&#123;book_id&#125;</code> 不会影响资源名称，但是会影响客户端自动生成的代码</li>
</ul>
<h4 id="向资源消息体添加读写字段"><a class="markdownIt-Anchor" href="#向资源消息体添加读写字段"></a> 向资源消息体添加读/写字段</h4>
<p>客户端经常会执行先读，然后修改，最后写入的一整套操作，大多数情况下如果某个字段客户端用不到就不会给它赋值。虽然服务端可以采取缺失值的字段就不执行写入的措施，但不适用于基本类型的字段（包括 <code>string</code> 和 <code>bytes</code>），因为基本类型默认值的存在造成无法区分出是客户端主动设置 <code>int32</code> 类型的字段值为0还是没有设置值从而使用默认值0。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>虽然 <code>Google</code> 的这篇 <code>API</code> 设计主要是面向资源的设计，但同时也针对其不足提出了改进的方案。不管是 <code>RESTful</code> 还是非 <code>RESTful</code> 的接口设计，都只是一种规范，有各自适合的场景没有孰优孰劣，统一的规范胜过生搬硬套。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/apis/design">API design guide</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3715981/what-s-the-best-restful-method-to-return-total-number-of-items-in-an-object">What’s the best RESTful method to return total number of items in an object?</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.digitalocean.com/reference/api/api-reference/">DigitalOcean API (2.0)</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/10/09/monitor-ec2-memory-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/09/monitor-ec2-memory-usage/" class="post-title-link" itemprop="url">AWS EC2 监控内存使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-09T00:00:00+08:00">2022-10-09</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>AWS</code> <code>EC2</code> 的监控页面默认没有显示内存使用率，需要搭配 <code>CloudWatch</code> 配置使用。</p>
<p>由于需要在 <code>EC2</code> 上安装 <code>CloudWatch agent</code> 来上报监控数据到 <code>CloudWatch</code>，所以需要先为 <code>EC2</code> 配置 <code>IAM</code> 角色来授予需要的权限。创建 <code>IAM</code> 角色时，在第一步的 <code>Trusted entity type</code> 选择 <code>AWS service</code>，<code>Use case</code> 选择 <code>EC2</code>；在第二步的 <code>Permissions policies</code> 添加 <code>CloudWatchAgentServerPolicy</code> 即可。更多细节可参考 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/create-iam-roles-for-cloudwatch-agent-commandline.html">Create IAM roles and users for use with CloudWatch agent</a>。</p>
<p>接着，在 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/download-cloudwatch-agent-commandline.html">Download and configure the CloudWatch agent using the command line</a> 中根据实际 <code>EC2</code> 的操作系统下载和安装 <code>CloudWatch agent</code>，这里以 <code>ARM64</code> 的 <code>Ubuntu</code> 系统为例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/arm64/latest/amazon-cloudwatch-agent.deb</span><br><span class="line">sudo dpkg -i -E ./amazon-cloudwatch-agent.deb</span><br></pre></td></tr></table></figure>
<p>然后，为 <code>CloudWatch agent</code> 创建一个配置文件，例如 <code>cloudwatch.json</code>，写入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;metrics&quot;:&#123;</span><br><span class="line">      &quot;metrics_collected&quot;:&#123;</span><br><span class="line">         &quot;mem&quot;:&#123;</span><br><span class="line">            &quot;measurement&quot;:[</span><br><span class="line">               &quot;mem_used_percent&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;metrics_collection_interval&quot;:60</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;append_dimensions&quot;: &#123;</span><br><span class="line">        &quot;InstanceId&quot;: &quot;$&#123;aws:InstanceId&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表示每隔60秒收集一次内存使用率，接着启动 <code>CloudWatch agent</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:<span class="variable">$HOME</span>/cloudwatch.json -s</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>amazon-cloudwatch-agent-ctl -a status</code> 来查看 <code>CloudWatch agent</code> 的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;running&quot;,</span><br><span class="line">  &quot;starttime&quot;: &quot;2022-10-09T13:23:11+00:00&quot;,</span><br><span class="line">  &quot;configstatus&quot;: &quot;configured&quot;,</span><br><span class="line">  &quot;cwoc_status&quot;: &quot;stopped&quot;,</span><br><span class="line">  &quot;cwoc_starttime&quot;: &quot;&quot;,</span><br><span class="line">  &quot;cwoc_configstatus&quot;: &quot;not configured&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.247355.0b252062&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>CloudWatch agent</code> 的状态为运行中。</p>
<p>如果一切正常，那么在 <code>AWS</code> 控制台中 <code>CloudWatch</code> 的 <code>All metrics</code> 下会多出一项 <code>CWAgent</code>（如果原来没有添加过的话）：</p>
<p><img src="/images/cloudwatch-1.png" alt="alt" /></p>
<p>点击进入后选择相应的 <code>EC2</code>，点击 <code>Add to graph</code>：</p>
<p><img src="/images/cloudwatch-2.png" alt="alt" /></p>
<p>在当前页面上方就会显示对应的内存使用率的监控：</p>
<p><img src="/images/cloudwatch-3.png" alt="alt" /></p>
<p>之后也可以创建一个 <code>Dashboard</code>，将这个监控加入到自定义的 <code>Dashboard</code> 中。</p>
<p>如果在 <code>AWS</code> 控制台没有看到 <code>CWAgent</code> 项目，那么可以查看 <code>EC2</code> 上 <code>CloudWatch agent</code> 的日志是否有异常，日志保存在 <code>/opt/aws/amazon-cloudwatch-agent/logs/amazon-cloudwatch-agent.log</code>。例如，如果忘记为 <code>EC2</code> 配置 <code>IAM</code> 角色，同时 <code>EC2</code> 上又没有其他的权限访问信息，<code>CloudWatch agent</code> 就无法上报监控数据，会提示如下类似的异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-10-09T13:27:36Z E! WriteToCloudWatch failure, err:  NoCredentialProviders: no valid providers in chain</span><br><span class="line">caused by: EnvAccessKeyNotFound: failed to find credentials in the environment.</span><br><span class="line">SharedCredsLoad: failed to load profile, .</span><br><span class="line">EC2RoleRequestError: no EC2 instance role found</span><br><span class="line">caused by: EC2MetadataError: failed to make EC2Metadata request</span><br></pre></td></tr></table></figure>
<p>最后，如果想要添加更多的监控指标，可以参考 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/metrics-collected-by-CloudWatch-agent.html">Metrics collected by the CloudWatch agent</a> 添加相应的指标。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lepczynski.it/en/aws_en/how-to-monitor-memory-usage-on-aws-ec2/">How to monitor memory usage on AWS EC2 ??</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/download-cloudwatch-agent-commandline.html">Download and configure the CloudWatch agent using the command line</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/metrics-collected-by-CloudWatch-agent.html">Metrics collected by the CloudWatch agent</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/create-iam-roles-for-cloudwatch-agent-commandline.html">Create IAM roles and users for use with CloudWatch agent</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/09/18/add-volume-to-aws-ec2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/18/add-volume-to-aws-ec2/" class="post-title-link" itemprop="url">AWS EC2 挂载磁盘</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-18T00:00:00+08:00">2022-09-18</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="挂载磁盘"><a class="markdownIt-Anchor" href="#挂载磁盘"></a> 挂载磁盘</h2>
<p>在创建 <code>AWS</code> 的 <code>EC2</code> 实例时如果添加了额外的磁盘则需要手动挂载到系统中。</p>
<p>首先运行 <code>lsblk</code> 来查看可用的块设备：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0          7:0    0 22.2M  1 loop /snap/amazon-ssm-agent/5657</span><br><span class="line">loop1          7:1    0   49M  1 loop /snap/core18/2406</span><br><span class="line">loop2          7:2    0 57.8M  1 loop /snap/core20/1498</span><br><span class="line">loop3          7:3    0 38.7M  1 loop /snap/snapd/15909</span><br><span class="line">loop4          7:4    0 71.8M  1 loop /snap/lxd/22927</span><br><span class="line">nvme1n1      259:0    0    8G  0 disk</span><br><span class="line">nvme0n1      259:1    0    8G  0 disk</span><br><span class="line">├─nvme0n1p1  259:2    0  7.9G  0 part /</span><br><span class="line">└─nvme0n1p15 259:3    0   99M  0 part /boot/efi</span><br></pre></td></tr></table></figure>
<p>其中的 <code>nvme1n1</code> 是本次新添加的磁盘，目前还未挂载到系统中，而 <code>nvme0n1</code> 则是根设备并且有两个分区。</p>
<blockquote>
<p><code>lsblk</code> 的输出结果会移除设备路径中的 <code>/dev/</code> 前缀，所以设备 <code>nvme1n1</code> 的完整路径为 <code>/dev/nvme1n1</code>。</p>
</blockquote>
<p>然后，我们需要在 <code>nvme1n1</code> 之上创建文件系统才能使用，执行 <code>sudo file -s /dev/nvme1n1</code> 显示 <code>nvme1n1</code> 还没有文件系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme1n1: data</span><br></pre></td></tr></table></figure>
<p>而如果我们查看 <code>sudo file -s /dev/nvme0n1</code> 则会显示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 16777215 sectors, extended partition table (last)</span><br></pre></td></tr></table></figure>
<p>执行 <code>sudo mkfs -t xfs /dev/nvme1n1</code> 来为 <code>nvme1n1</code> 创建文件系统，其中 <code>xfs</code> 表示文件系统的类型：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meta-data=/dev/nvme1n1           isize=512    agcount=8, agsize=262144 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                       reflink=1    bigtime=0 inobtcount=0</span><br><span class="line">data     =                       bsize=4096   blocks=2097152, imaxpct=25</span><br><span class="line">         =                       sunit=1      swidth=1 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0, ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=1 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>
<p>接着，我们就可以创建一个文件夹用来挂载磁盘，例如 <code>sudo mkdir /data</code>。最后将 <code>/dev/nvme1n1</code> 挂载到 <code>/data</code> 上：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/nvme1n1 /data</span><br></pre></td></tr></table></figure>
<p>此时如果查看 <code>df -h</code> 就会包含 <code>/dev/nvme1n1</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filesystem       Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        7.6G  1.6G  6.1G  21% /</span><br><span class="line">tmpfs            926M     0  926M   0% /dev/shm</span><br><span class="line">tmpfs            371M 1000K  370M   1% /run</span><br><span class="line">tmpfs            5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/nvme0n1p15   98M  5.1M   93M   6% /boot/efi</span><br><span class="line">tmpfs            186M  4.0K  186M   1% /run/user/1000</span><br><span class="line">/dev/nvme1n1     8.0G   90M  8.0G   2% /data</span><br></pre></td></tr></table></figure>
<h2 id="系统启动自动挂载磁盘"><a class="markdownIt-Anchor" href="#系统启动自动挂载磁盘"></a> 系统启动自动挂载磁盘</h2>
<p>当前的磁盘挂载信息会在系统启动后丢失，如果希望系统启动后自动挂载磁盘则需要向 <code>/etc/fstab</code> 中添加一条记录。</p>
<p>安全起见先备份下 <code>/etc/fstab</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/fstab /etc/fstab.orig</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>sudo blkid</code> 来查看设备 <code>/dev/nvme1n1</code> 的 <code>UUID</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1p1: LABEL=<span class="string">&quot;cloudimg-rootfs&quot;</span> UUID=<span class="string">&quot;15ea47e1-ef7d-4928-9dbe-ffaf0e743653&quot;</span> BLOCK_SIZE=<span class="string">&quot;4096&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;1957f80e-a338-441c-a0e0-ed1575eefda3&quot;</span></span><br><span class="line">/dev/nvme0n1p15: LABEL_FATBOOT=<span class="string">&quot;UEFI&quot;</span> LABEL=<span class="string">&quot;UEFI&quot;</span> UUID=<span class="string">&quot;68E7-1A63&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;vfat&quot;</span> PARTUUID=<span class="string">&quot;1eeb08ab-0afd-4477-bd53-4389a42db8f6&quot;</span></span><br><span class="line">/dev/loop1: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop4: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop2: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop0: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/nvme1n1: UUID=<span class="string">&quot;aa81c000-325c-40b7-ba4c-598ec2c824e0&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line">/dev/loop3: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后向 <code>/etc/fstab</code> 添加一条记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=aa81c000-325c-40b7-ba4c-598ec2c824e0  /data  xfs  defaults,nofail  0  2</span><br></pre></td></tr></table></figure>
<p>可以通过先取消挂载 <code>/data</code> 即 <code>sudo umount /data</code> 然后再执行 <code>sudo mount -a</code> 来验证自动挂载是否生效。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html">Make an Amazon EBS volume available for use on Linux</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/09/11/setup-eks-cluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/11/setup-eks-cluster/" class="post-title-link" itemprop="url">创建 EKS 集群</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-11T00:00:00+08:00">2022-09-11</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>8 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>EKS</code>（<code>Amazon Elastic Kubernetes Service</code>）是 <code>AWS</code> 提供的 <code>Kubernetes</code> 服务，它能大大减轻创建和维护 <code>Kubernetes</code> 集群的负担。</p>
<h2 id="创建-eks-集群"><a class="markdownIt-Anchor" href="#创建-eks-集群"></a> 创建 EKS 集群</h2>
<p>有两种方式来创建 <code>EKS</code> 集群，一种是使用本地的 <code>eksctl</code> 程序；另一种是通过 <code>AWS</code> 的管理后台（<code>AWS Management Console</code>），这里选择通过 <code>AWS</code> 的管理后台来创建 <code>EKS</code> 集群。</p>
<h3 id="创建-cluster-service-role"><a class="markdownIt-Anchor" href="#创建-cluster-service-role"></a> 创建 Cluster service role</h3>
<p>创建 <code>EKS</code> 集群时需要绑定一个 <code>IAM</code> 角色，因为 <code>Kubernetes</code> 的 <code>control plane</code> 需要管理集群内的资源，所以需要有相应的操作权限。</p>
<p>首先进入 <a target="_blank" rel="noopener" href="https://console.aws.amazon.com/iam/">IAM 控制台</a>，选择左侧 <code>Access management</code> 下的 <code>Roles</code>，点击 <code>Create role</code>。在 <code>Trusted entity type</code> 下选择 <code>AWS service</code>，然后在 <code>Use cases for other AWS services</code> 下选择 <code>EKS</code>，接着选择 <code>EKS - Cluster</code> 并点击 <code>Next</code>。在 <code>Add permissions</code> 这步直接点击 <code>Next</code>。在最后一步设置所创建的角色的名字，如 <code>eksClusterRole</code>，最后点击 <code>Create role</code> 创建角色。</p>
<h3 id="创建集群"><a class="markdownIt-Anchor" href="#创建集群"></a> 创建集群</h3>
<p>我们通过 <code>AWS</code> 管理后台中的 <code>Amazon Elastic Kubernetes Service</code> 界面来创建集群，第一步的 <code>Configure cluster</code> 主要设置集群的名称，如 <code>my-cluster</code>，以及绑定在之前步骤中所创建的 <code>Cluster service role</code>。第二步的 <code>Specify networking</code> 这里基本都保持默认，只是将 <code>Cluster endpoint access</code> 设置为 <code>Public and private</code>。第三步的 <code>Configure logging</code> 可以暂时不开启日志监控。最后在第四步的 <code>Review and create</code> 点击 <code>Create</code> 创建集群。</p>
<h2 id="创建-node-group"><a class="markdownIt-Anchor" href="#创建-node-group"></a> 创建 Node group</h2>
<p>当集群的状态变为 <code>Active</code> 后就表示集群创建成功，不过此时集群中还没有任何 <code>Node</code>，所以系统级别的 <code>Pod</code> 还无法正常工作，比如在集群详情的 <code>Resources</code> 下查看某个 <code>coredns</code> 的 <code>Pod</code> 会显示 <code>FailedScheduling</code>，因为 <code>no nodes available to schedule pods</code>。</p>
<p>我们需要创建 <code>Node group</code> 来为系统添加可用的 <code>Node</code>。</p>
<h3 id="创建-node-iam-role"><a class="markdownIt-Anchor" href="#创建-node-iam-role"></a> 创建 Node IAM role</h3>
<p>在创建 <code>Node group</code> 前，需要创建一个 <code>Node IAM role</code>。因为集群中的 <code>Node</code> 内部会运行着一个叫做 <code>kubelet</code> 的程序，它负责和集群的 <code>control plane</code> 进行通信，例如将当前 <code>Node</code> 注册到集群中，而某些操作需要调用 <code>AWS</code> 的接口，所以和 <code>Cluster service role</code> 类似，也需要绑定相应的权限。</p>
<p>这里同样也是通过 <a target="_blank" rel="noopener" href="https://console.aws.amazon.com/iam/">IAM 控制台</a> 来创建角色，在 <code>Trusted entity type</code> 下选择 <code>AWS service</code>，在 <code>Use case</code> 下选择 <code>EC2</code>，然后点击 <code>Next</code>。在第二步的 <code>Add permissions</code> 需要添加 <code>AmazonEKSWorkerNodePolicy</code>，<code>AmazonEC2ContainerRegistryReadOnly</code> 和 <code>AmazonEKS_CNI_Policy</code> 三个权限，虽然文档中说不建议将 <code>AmazonEKS_CNI_Policy</code> 权限添加到 <code>Node IAM role</code> 上，不过这里作为示例教程将三个权限都绑定在了 <code>Node IAM role</code> 上。最后也是点击 <code>Create role</code> 创建角色。</p>
<h3 id="创建-node-group-2"><a class="markdownIt-Anchor" href="#创建-node-group-2"></a> 创建 Node group</h3>
<p>在集群详情的 <code>Compute</code> 下点击 <code>Add node group</code> 来创建 <code>Node group</code>，在第一步 <code>Configure node group</code> 中设置 <code>node group</code> 的名称及绑定在之前步骤中所创建的 <code>Node IAM role</code>。在第二步 <code>Set compute and scaling configuration</code> 里配置节点的类型和数量等信息，作为教程都采用默认配置。第三步 <code>Specify networking</code> 同样采用默认配置。最后在第四步的 <code>Review and create</code> 点击 <code>Create</code> 完成创建。</p>
<p>最后当所创建的 <code>Node group</code> 的状态变为 <code>Active</code> 以及该 <code>Node group</code> 下的 <code>Node</code> 的状态变为 <code>Ready</code> 时说明节点创建成功。此时再查看集群详情下 <code>Resources</code> 的 <code>coredns</code> 的 <code>Pod</code> 已成功分配了 <code>Node</code> 运行。</p>
<h2 id="连接-eks-集群"><a class="markdownIt-Anchor" href="#连接-eks-集群"></a> 连接 EKS 集群</h2>
<p>日常需要通过 <code>kubectl</code> 管理集群，所以需要先在本地配置访问 <code>EKS</code> 集群的权限。<code>kubectl</code> 本质上是和 <code>Kubernetes API server</code> 打交道，而创建集群时 <code>Cluster endpoint access</code> 部分选择的是 <code>Public and private</code>，所以在这个场景下能够从公网管理 <code>EKS</code> 集群。</p>
<p>首先需要安装 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">AWS CLI</a> 和 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html">kubectl</a>。然后在本地通过 <code>aws configure</code> 来设置 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>。根据 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html">Enabling IAM user and role access to your cluster</a> 的描述，创建集群的账户会自动授予集群的 <code>system:masters</code> 权限，本文是通过 <code>AWS</code> 的管理后台创建集群，当前登录的账户为 <code>root</code>，所以 <code>aws configure</code> 需要设置为 <code>root</code> 的 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>：</p>
<blockquote>
<p>When you create an Amazon EKS cluster, the AWS Identity and Access Management (IAM) entity user or role, such as a federated user that creates the cluster, is automatically granted system:masters permissions in the cluster’s role-based access control (RBAC) configuration in the Amazon EKS control plane.</p>
</blockquote>
<p>一般公司生产环境中的 <code>AWS</code> 是不会直接使用 <code>root</code> 账户登录的，而是创建 <code>IAM</code> 用户，由于这里是个人的 <code>AWS</code> 账户所以直接使用了 <code>root</code>，反之就需要使用 <code>IAM</code> 用户的 <code>AWS Access Key ID</code> 和 <code>AWS Secret Access Key</code>。设置完成之后可以通过 <code>aws sts get-caller-identity</code> 来验证当前用户是否设置正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;UserId&quot;: &quot;123&quot;,</span><br><span class="line">    &quot;Account&quot;: &quot;123&quot;,</span><br><span class="line">    &quot;Arn&quot;: &quot;arn:aws:iam::123:user&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>aws eks update-kubeconfig --region us-west-2 --name my-cluster</code> 来更新本地的 <code>kubeconfig</code>，其中 <code>us-west-2</code> 需要修改为实际的 <code>AWS Region</code>，<code>my-cluster</code> 需要修改为实际的集群名称。最后就可以通过 <code>kubectl get all</code> 来验证能否访问集群，如果没有问题就会输出如下类似内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.100.0.1   &lt;none&gt;        443/TCP   175m</span><br></pre></td></tr></table></figure>
<h2 id="设置其他用户的集群访问权限"><a class="markdownIt-Anchor" href="#设置其他用户的集群访问权限"></a> 设置其他用户的集群访问权限</h2>
<p>创建集群的账户可能权限较高，所以需要单独给某些账户开通集群的访问权限。可以通过 <code>kubectl describe -n kube-system configmap/aws-auth</code> 查看当前的权限分配情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name:         aws-auth</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">mapRoles:</span><br><span class="line">----</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers</span><br><span class="line">  - system:nodes</span><br><span class="line">  rolearn: arn:aws:iam::123:role/AmazonEKSNodeRole</span><br><span class="line">  username: system:node:&#123;&#123;EC2PrivateDNSName&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryData</span><br><span class="line">====</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>假设我们需要授予某个 <code>IAM</code> 用户 <code>eks</code> <code>system:masters</code> 的角色，首先运行 <code>kubectl edit -n kube-system configmap/aws-auth</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Please edit the object below. Lines beginning with a &#x27;#&#x27; will be ignored,</span><br><span class="line"># and an empty file will abort the edit. If an error occurs while saving this file will be</span><br><span class="line"># reopened with the relevant failures.</span><br><span class="line">#</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  mapRoles: |</span><br><span class="line">    - groups:</span><br><span class="line">      - system:bootstrappers</span><br><span class="line">      - system:nodes</span><br><span class="line">      rolearn: arn:aws:iam::123:role/AmazonEKSNodeRole</span><br><span class="line">      username: system:node:&#123;&#123;EC2PrivateDNSName&#125;&#125;</span><br><span class="line">  mapUsers: |</span><br><span class="line">    - groups:</span><br><span class="line">      - system:masters</span><br><span class="line">      userarn: arn:aws:iam::123:user/eks</span><br><span class="line">      username: eks</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-09-11T06:33:38Z&quot;</span><br><span class="line">  name: aws-auth</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  resourceVersion: &quot;33231&quot;</span><br><span class="line">  uid: 6b186686-548c-4c99-9f65-0381da1366a4</span><br></pre></td></tr></table></figure>
<p>这里在 <code>data</code> 下新增了 <code>mapUsers</code>，授予用户 <code>eks</code> <code>system:masters</code> 的角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapUsers: |</span><br><span class="line">  - groups:</span><br><span class="line">    - system:masters</span><br><span class="line">    userarn: arn:aws:iam::123:user/eks</span><br><span class="line">    username: eks</span><br></pre></td></tr></table></figure>
<p>保存后可以通过 <code>kubectl describe configmap -n kube-system aws-auth</code> 验证改动是否生效。然后下载 <code>aws-auth-cm.yaml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o aws-auth-cm.yaml https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/aws-auth-cm.yaml</span><br></pre></td></tr></table></figure>
<p>将其中的 <code>&lt;ARN of instance role (not instance profile)&gt;</code> 替换为之前创建的 <code>Node IAM role</code>，然后执行 <code>kubectl apply -f aws-auth-cm.yaml</code> 应用修改，执行 <code>kubectl get nodes --watch</code> 观察是否所有的节点的状态都变为了 <code>Ready</code>。</p>
<p>接着删除本地的 <code>~/.kube/config</code> 来验证权限是否生效。重新运行 <code>aws configure</code> 来设置某个 <code>IAM</code> 用户的信息，因为我们要重新执行 <code>aws eks update-kubeconfig --region us-west-2 --name my-cluster</code> 来生成新的 <code>~/.kube/config</code>，这里要求当前 <code>IAM</code> 用户拥有 <code>DescribeCluster</code> 的权限，这个权限是 <code>AWS</code> 层面的资源访问权限，而不是 <code>EKS</code> 集群的权限，添加权限后可能需要等待几分钟才会生效。当重新生成了 <code>~/.kube/config</code> 文件之后，就可以继续通过 <code>kubectl get all</code> 验证访问权限是否生效。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role">Creating the Amazon EKS cluster role</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html#create-worker-node-role">Creating the Amazon EKS node IAM role</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html">Enabling IAM user and role access to your cluster</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50791303/kubectl-error-you-must-be-logged-in-to-the-server-unauthorized-when-accessing">kubectl error You must be logged in to the server (Unauthorized) when accessing EKS cluster</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Xiaodan Mao</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Frederick-S" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
