<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"frederick-s.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Übung macht den Meister">
<meta property="og:url" content="https://frederick-s.github.io/page/4/index.html">
<meta property="og:site_name" content="Übung macht den Meister">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaodan Mao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://frederick-s.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Übung macht den Meister</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J1NC2B33VK"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-J1NC2B33VK","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Übung macht den Meister" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Übung macht den Meister</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-mit-6.824"><a href="/mit-6.824/" rel="section"><i class="fas fa-book fa-fw"></i>MIT 6.824</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-赞赏"><a href="/sponsor/" rel="section"><i class="fas fa-heart fa-fw"></i>赞赏</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fas fa-rss fa-fw"></i>RSS</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiaodan Mao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/03/27/mit-6.824-lab1-sequential-mapreduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/27/mit-6.824-lab1-sequential-mapreduce/" class="post-title-link" itemprop="url">MIT 6.824 - Lab 1 (3): 示例程序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-27T00:00:00+08:00">2022-03-27</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Lab 1</code> 提供了一个串行化的示例 <code>MapReduce</code> 程序，整体分两部分，第一部分是用户自定义的 <code>map</code> 和 <code>reduce</code> 函数，第二部分是框架代码。</p>
<h2 id="用户自定义-map-和-reduce-函数"><a class="markdownIt-Anchor" href="#用户自定义-map-和-reduce-函数"></a> 用户自定义 map 和 reduce 函数</h2>
<p>以单词计数应用 <code>wc.go</code> 为例，对于 <code>map</code> 函数来说，它的输入键值对类型为 <code>&lt;string, string&gt;</code>，中间结果数据类型为框架定义的 <code>KeyValue</code> 类型，本质上也是个 <code>&lt;string, string&gt;</code> 类型。<code>map</code> 函数首先将文件内容拆分为单词，然后遍历每个单词，输出对应中间结果数据 <code>&lt;w, &quot;1&quot;&gt;</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The map function is called once for each file of input. The first</span></span><br><span class="line"><span class="comment">// argument is the name of the input file, and the second is the</span></span><br><span class="line"><span class="comment">// file&#x27;s complete contents. You should ignore the input file name,</span></span><br><span class="line"><span class="comment">// and look only at the contents argument. The return value is a slice</span></span><br><span class="line"><span class="comment">// of key/value pairs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(filename <span class="type">string</span>, contents <span class="type">string</span>)</span></span> []mr.KeyValue &#123;</span><br><span class="line">	<span class="comment">// function to detect word separators.</span></span><br><span class="line">	ff := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> !unicode.IsLetter(r) &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// split contents into an array of words.</span></span><br><span class="line">	words := strings.FieldsFunc(contents, ff)</span><br><span class="line"></span><br><span class="line">	kva := []mr.KeyValue&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		kv := mr.KeyValue&#123;w, <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">		kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kva</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reduce</code> 函数的输出类型为 <code>string</code>，其逻辑较为简单，中间结果数组的长度就是单词的个数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span><span class="params">(key <span class="type">string</span>, values []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// return the number of occurrences of this word.</span></span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(<span class="built_in">len</span>(values))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="框架代码"><a class="markdownIt-Anchor" href="#框架代码"></a> 框架代码</h2>
<p>我们可以通过 <code>go run -race mrsequential.go wc.so pg*.txt</code> 来运行串行化的 <code>MapReduce</code> 程序，这里的 <code>wc.so</code> 内包含了用户自定义的 <code>map</code> 和 <code>reduce</code> 函数，<code>pg*.txt</code> 则是本次 <code>MapReduce</code> 程序的原始输入数据。</p>
<p>首先，根据入参提供的插件找到用户自定义的 <code>map</code> 和 <code>reduce</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapf, reducef := loadPlugin(os.Args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>接着，依次读取输入文件的内容，并调用用户自定义的 <code>map</code> 函数，生成一组中间结果数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// read each input file,</span></span><br><span class="line"><span class="comment">// pass it to Map,</span></span><br><span class="line"><span class="comment">// accumulate the intermediate Map output.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">intermediate := []mr.KeyValue&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> os.Args[<span class="number">2</span>:] &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	content, err := ioutil.ReadAll(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot read %v&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">	kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line">	intermediate = <span class="built_in">append</span>(intermediate, kva...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，对所有中间结果数据按照键进行排序，而在 <code>MapReduce</code> 论文中，中间结果数据会经过分片函数分发给不同的 <code>reduce</code> 节点，由 <code>reduce</code> 节点自行排序处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// a big difference from real MapReduce is that all the</span></span><br><span class="line"><span class="comment">// intermediate data is in one place, intermediate[],</span></span><br><span class="line"><span class="comment">// rather than being partitioned into NxM buckets.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">sort.Sort(ByKey(intermediate))</span><br></pre></td></tr></table></figure>
<p>最后，遍历所有中间结果数据，对同键的中间结果数据调用用户自定义的 <code>reduce</code> 函数，并将结果写入到最终输出文件中，同样的，这里也只有一个最终输出文件而不是多个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">oname := <span class="string">&quot;mr-out-0&quot;</span></span><br><span class="line">ofile, _ := os.Create(oname)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// call Reduce on each distinct key in intermediate[],</span></span><br><span class="line"><span class="comment">// and print the result to mr-out-0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">	j := i + <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">		values = <span class="built_in">append</span>(values, intermediate[k].Value)</span><br><span class="line">	&#125;</span><br><span class="line">	output := reducef(intermediate[i].Key, values)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">	fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line"></span><br><span class="line">	i = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofile.Close()</span><br></pre></td></tr></table></figure>
<p>至此，一个串行化的 <code>MapReduce</code> 程序就完成了。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">6.824 Lab 1: MapReduce</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/03/26/mit-6.824-lab1-go-buildmode-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/26/mit-6.824-lab1-go-buildmode-plugin/" class="post-title-link" itemprop="url">MIT 6.824 - Lab 1 (2): Go buildmode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-26T00:00:00+08:00">2022-03-26</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>910</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Lab 1</code> 中遇到的第一个命令是 <code>go build -race -buildmode=plugin ../mrapps/wc.go</code>，其中 <code>-buildmode=plugin</code> 表示以插件的形式打包源文件，这里的 <code>wc.go</code> 是用户实现的 <code>map</code> 和 <code>reduce</code> 方法，这体现了面向接口编程的思想，只要用户编写的 <code>map</code> 和 <code>reduce</code> 方法遵循统一的签名，则可以在不重新编译 <code>MapReduce</code> 框架代码的情况下，实时替换运行不同的用户应用。</p>
<p>假设有个 <code>sum.go</code> 文件，里面只有一个 <code>Sum</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>sum.go</code> 以插件形式编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=plugin sum.go</span><br></pre></td></tr></table></figure>
<p>会生成一个 <code>sum.so</code> 文件。</p>
<p>接着，在 <code>main.go</code> 中就可以通过 <code>plugin.Open</code> 读取 <code>sum.so</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;plugin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;sum.so&quot;</span></span><br><span class="line">	p, err := plugin.Open(fileName)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot load plugin %v&quot;</span>, fileName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sumSymbol, err := p.Lookup(<span class="string">&quot;Sum&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot find Map in %v&quot;</span>, fileName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sum := sumSymbol.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;1 + 2 is&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>Lookup</code> 根据方法名找到 <code>Sum</code> 方法，按照指定方法签名转换后即可进行调用。而如果需要换一个 <code>Sum</code> 的实现，则无需重新编译 <code>main.go</code>。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/cmd/go#hdr-Build_modes">Build modes</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/03/24/mit-6.824-lab1-go-race-detector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/24/mit-6.824-lab1-go-race-detector/" class="post-title-link" itemprop="url">MIT 6.824 - Lab 1 (1): Go Race Detector</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-24 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-24T00:00:00+08:00">2022-03-24</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>7.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>13 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Lab 1</code> 中遇到的第一个命令是 <code>go build -race -buildmode=plugin ../mrapps/wc.go</code>，其中 <code>-race</code> 表示启用 <code>Go</code> 的竞争检测，在多线程编程时，数据竞争是必须要考虑的问题，而数据竞争的问题往往难以察觉和排查，所以 <code>Go</code> 内置了竞争检测的工具来帮助开发人员提前发现问题。另外，<code>MIT 6.824</code> 是一门分布式系统课程，必然会涉及多线程编程，所以竞争检测也是校验 <code>Lab</code> 程序正确性的一种方式。</p>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>Go</code> 借助 <code>goroutine</code> 来实现并发编程，所以数据竞争发生在多个 <code>goroutine</code> 并发读写同一个共享变量时，并且至少有一个 <code>goroutine</code> 存在写操作。来看一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;data race&quot;</span></span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello,&quot;</span>, m[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>m</code> 是一个共享变量，被两个 <code>goroutine</code> 并发读写，将上述代码保存为文件 <code>racy.go</code>，然后开启竞争检测执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -race racy.go</span><br></pre></td></tr></table></figure>
<p>会输出类似如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c00007e180 by goroutine 7:</span><br><span class="line">  runtime.mapassign_faststr()</span><br><span class="line">      /usr/local/go/src/runtime/map_faststr.go:203 +0x0</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /path/to/racy.go:10 +0x50</span><br><span class="line"></span><br><span class="line">Previous read at 0x00c00007e180 by main goroutine:</span><br><span class="line">  runtime.mapaccess1_faststr()</span><br><span class="line">      /usr/local/go/src/runtime/map_faststr.go:13 +0x0</span><br><span class="line">  main.main()</span><br><span class="line">      /path/to/racy.go:13 +0x16b</span><br><span class="line"></span><br><span class="line">Goroutine 7 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /path/to/racy.go:9 +0x14e</span><br><span class="line">==================</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c000114088 by goroutine 7:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /path/to/racy.go:10 +0x5c</span><br><span class="line"></span><br><span class="line">Previous read at 0x00c000114088 by main goroutine:</span><br><span class="line">  main.main()</span><br><span class="line">      /path/to/racy.go:13 +0x175</span><br><span class="line"></span><br><span class="line">Goroutine 7 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /path/to/racy.go:9 +0x14e</span><br><span class="line">==================</span><br><span class="line">Found 2 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure>
<p>竞争检测会提示第13行和第10行存在数据竞争，一共涉及两个 <code>goroutine</code>，一个是主 <code>goroutine</code>，另一个是手动创建的 <code>goroutine</code>。</p>
<h2 id="典型数据竞争场景"><a class="markdownIt-Anchor" href="#典型数据竞争场景"></a> 典型数据竞争场景</h2>
<h3 id="循环计数器竞争"><a class="markdownIt-Anchor" href="#循环计数器竞争"></a> 循环计数器竞争</h3>
<p>这个例子中每次循环时会创建一个 <code>goroutine</code>，每个 <code>goroutine</code> 会打印循环计数器 <code>i</code> 的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i) <span class="comment">// Not the &#x27;i&#x27; you are looking for.</span></span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要的结果是能输出 <code>01234</code> 这5个值（实际顺序并不一定是 <code>01234</code>），但由于主 <code>goroutine</code> 对 <code>i</code> 的更新和被创建的 <code>goroutine</code> 对 <code>i</code> 的读取之间存在数据竞争，最终的输出结果可能是 <code>55555</code> 也可能是其他值。</p>
<p>如果要修复这个问题，每次创建 <code>goroutine</code> 时复制一份 <code>i</code> 再传给 <code>goroutine</code> 即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(j) <span class="comment">// Good. Read local copy of the loop counter.</span></span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="意外地共享变量"><a class="markdownIt-Anchor" href="#意外地共享变量"></a> 意外地共享变量</h3>
<p>在日常开发中，我们可能不经意间在多个 <code>goroutine</code> 间共享了某个变量。在下面的例子中，首先 <code>f1, err := os.Create(&quot;file1&quot;)</code> 会创建一个 <code>err</code> 变量，接着在第一个 <code>goroutine</code> 中对 <code>file1</code> 写入时会对 <code>err</code> 进行更新（<code>_, err = f1.Write(data)</code>），然而在主 <code>goroutine</code> 中创建 <code>file2</code> 时同样会对 <code>err</code> 进行更新（<code>f2, err := os.Create(&quot;file2&quot;)</code>，这里虽然用的是 <code>:=</code>，不过 <code>err</code> 并不是一个新的变量，在同一个作用域下是不允许重复对某个同名变量使用 <code>:=</code> 创建的，因为 <code>f2</code> 是一个新的变量，所以这里可用 <code>:=</code>），这就产生了数据竞争：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ParallelWrite writes data to file1 and file2, returns the errors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParallelWrite</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="keyword">chan</span> <span class="type">error</span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">2</span>)</span><br><span class="line">	f1, err := os.Create(<span class="string">&quot;file1&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		res &lt;- err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// This err is shared with the main goroutine,</span></span><br><span class="line">			<span class="comment">// so the write races with the write below.</span></span><br><span class="line">			_, err = f1.Write(data)</span><br><span class="line">			res &lt;- err</span><br><span class="line">			f1.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	f2, err := os.Create(<span class="string">&quot;file2&quot;</span>) <span class="comment">// The second conflicting write to err.</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		res &lt;- err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			_, err = f2.Write(data)</span><br><span class="line">			res &lt;- err</span><br><span class="line">			f2.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := ParallelWrite([]<span class="type">byte</span>(<span class="string">&quot;Hello, world!&quot;</span>))</span><br><span class="line">	&lt;-err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修复方法也很简单，在每个 <code>goroutine</code> 中使用 <code>:=</code> 创建 <code>err</code> 变量即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ParallelWrite writes data to file1 and file2, returns the errors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParallelWrite</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="keyword">chan</span> <span class="type">error</span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">2</span>)</span><br><span class="line">	f1, err := os.Create(<span class="string">&quot;file1&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		res &lt;- err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// This err is shared with the main goroutine,</span></span><br><span class="line">			<span class="comment">// so the write races with the write below.</span></span><br><span class="line">			_, err := f1.Write(data)</span><br><span class="line">			res &lt;- err</span><br><span class="line">			f1.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	f2, err := os.Create(<span class="string">&quot;file2&quot;</span>) <span class="comment">// The second conflicting write to err.</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		res &lt;- err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			_, err := f2.Write(data)</span><br><span class="line">			res &lt;- err</span><br><span class="line">			f2.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := ParallelWrite([]<span class="type">byte</span>(<span class="string">&quot;Hello, world!&quot;</span>))</span><br><span class="line">	&lt;-err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="未受保护的全局变量"><a class="markdownIt-Anchor" href="#未受保护的全局变量"></a> 未受保护的全局变量</h3>
<p>某个包下对外暴露了 <code>RegisterService</code> 和 <code>LookupService</code> 两个方法，而这两个方法会对同一个 <code>map</code> 变量进行读写，客户端调用时有可能多个 <code>goroutine</code> 并发调用，从而存在数据竞争：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> service <span class="keyword">map</span>[<span class="type">string</span>]net.Addr = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]net.Addr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(name <span class="type">string</span>, addr net.Addr)</span></span> &#123;</span><br><span class="line">	service[name] = addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupService</span><span class="params">(name <span class="type">string</span>)</span></span> net.Addr &#123;</span><br><span class="line">	<span class="keyword">return</span> service[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		RegisterService(<span class="string">&quot;hello&quot;</span>, &amp;net.IPAddr&#123;IP: net.ParseIP(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(LookupService(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>sync.Mutex</code> 来保证可见性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	service   <span class="keyword">map</span>[<span class="type">string</span>]net.Addr = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]net.Addr)</span><br><span class="line">	serviceMu sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(name <span class="type">string</span>, addr net.Addr)</span></span> &#123;</span><br><span class="line">	serviceMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> serviceMu.Unlock()</span><br><span class="line">	service[name] = addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupService</span><span class="params">(name <span class="type">string</span>)</span></span> net.Addr &#123;</span><br><span class="line">	serviceMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> serviceMu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> service[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		RegisterService(<span class="string">&quot;hello&quot;</span>, &amp;net.IPAddr&#123;IP: net.ParseIP(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(LookupService(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="未受保护的基本类型变量"><a class="markdownIt-Anchor" href="#未受保护的基本类型变量"></a> 未受保护的基本类型变量</h3>
<p>除了 <code>map</code> 这样的复杂数据类型外，基本类型变量同样会存在数据竞争，如 <code>bool</code>，<code>int</code>，<code>int64</code>。例如在下面的例子中，主 <code>goroutine</code> 对 <code>w.last</code> 的更新和创建的 <code>goroutine</code> 中对 <code>w.last</code> 的读取间存在数据竞争：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Watchdog <span class="keyword">struct</span>&#123; last <span class="type">int64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Watchdog)</span></span> KeepAlive() &#123;</span><br><span class="line">	w.last = time.Now().UnixNano() <span class="comment">// First conflicting access.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Watchdog)</span></span> Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="comment">// Second conflicting access.</span></span><br><span class="line">			<span class="keyword">if</span> w.last &lt; time.Now().Add(<span class="number">-10</span>*time.Second).UnixNano() &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;No keepalives for 10 seconds. Dying.&quot;</span>)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	watchdog := &amp;Watchdog&#123;&#125;</span><br><span class="line">	watchdog.Start()</span><br><span class="line">	watchdog.KeepAlive()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然可以借助 <code>channel</code> 或 <code>sync.Mutex</code> 来修复这个问题，不过类似于 <code>Java</code>，<code>Go</code> 中同样有相应的原子变量来处理基本类型的并发读写，上述例子就可以通过原子包下的 <code>atomic.StoreInt64</code> 和 <code>atomic.LoadInt64</code> 来解决：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Watchdog <span class="keyword">struct</span>&#123; last <span class="type">int64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Watchdog)</span></span> KeepAlive() &#123;</span><br><span class="line">	atomic.StoreInt64(&amp;w.last, time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Watchdog)</span></span> Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">if</span> atomic.LoadInt64(&amp;w.last) &lt; time.Now().Add(<span class="number">-10</span>*time.Second).UnixNano() &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;No keepalives for 10 seconds. Dying.&quot;</span>)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	watchdog := &amp;Watchdog&#123;&#125;</span><br><span class="line">	watchdog.Start()</span><br><span class="line">	watchdog.KeepAlive()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="未同步的-send-和-close-操作"><a class="markdownIt-Anchor" href="#未同步的-send-和-close-操作"></a> 未同步的 send 和 close 操作</h3>
<p>虽然对一个 <code>channel</code> 的发送和相应的读取完成之间存在 <code>happens-before</code> 的关系，但是对 <code>channel</code> 的发送和关闭间并没有 <code>happens-before</code> 的保证，依然存在数据竞争：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// or buffered channel</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The race detector cannot derive the happens before relation</span></span><br><span class="line">	<span class="comment">// for the following send and close operations. These two operations</span></span><br><span class="line">	<span class="comment">// are unsynchronized and happen concurrently.</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;()</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在关闭 <code>channel</code> 前，增加对 <code>channel</code> 的读取操作来保证数据发送完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// or buffered channel</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="竞争检测的开销"><a class="markdownIt-Anchor" href="#竞争检测的开销"></a> 竞争检测的开销</h2>
<p>在开启竞争检测的情况下，程序的内存使用可能会增加5到10倍，性能可能会增加2到20倍，所以一般建议在压力测试或集成测试阶段开启，或者线上集群选择某台机器单独开启。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/race-detector">Introducing the Go Race Detector</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/articles/race_detector">Data Race Detector</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/ref/mem">The Go Memory Model</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/03/13/cf-and-of-flag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/13/cf-and-of-flag/" class="post-title-link" itemprop="url">CF 和 OF 标志位</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-13T00:00:00+08:00">2022-03-13</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>看汇编语言时看到，标志寄存器中 <code>CF</code> 标志位表示无符号数运算时是否向最高有效位外的更高位产生进位或借位，而 <code>OF</code> 标志位表示有符号数运算时是否产生溢出。这里存在两个疑问：</p>
<ol>
<li>对于 <code>CPU</code> 来说，它并不区分处理的是无符号数还是有符号数，那什么时候设置 <code>CF</code>，什么时候设置 <code>OF</code> 呢</li>
<li><code>CF</code> 表示进位时也是一种溢出，能否和 <code>OF</code> 共用一个</li>
</ol>
<h2 id="cf"><a class="markdownIt-Anchor" href="#cf"></a> CF</h2>
<p>首先来看 <code>CF</code> 进位的例子，这里我们以8位无符号数为例，其最大值为255，那么计算 <code>255 + 1</code> 则会产生进位。可以通过一段简单的汇编代码进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    mov $255, %al</span><br><span class="line">    add $1, %al</span><br><span class="line">    movl $1, %eax</span><br><span class="line">    movl $0, %ebx</span><br><span class="line">    int $0x80</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>al</code> 是一个8位寄存器，是 <code>eax</code> 寄存器的低8位，这里首先将255放到 <code>al</code> 寄存器内，然后对 <code>al</code> 寄存器中的值加1并放回到 <code>al</code> 寄存器中，即实现 <code>255 +1</code> 的运算。</p>
<p>最后的 <code>int $0x80</code> 中的 <code>int</code> 表示 <code>interrupt</code>，即中断，当发生一个中断时会有一个与之对应的中断处理程序来处理，这里的 <code>$0x80</code> 就是声明由哪个中断处理程序处理，在 <code>Linux</code> 中，<code>$0x80</code> 对应的是操作系统内核，用于发起一个系统调用，而具体发起哪个系统调用则由 <code>eax</code> 中的值决定，这就是 <code>movl $1, %eax</code> 的作用，1对应的系统调用是 <code>exit</code>，用于退出程序，而程序退出时会伴有一个状态码，这个状态码的值来自于 <code>ebx</code>，也就是 <code>movl $0, %ebx</code> 的作用，这里使用0来表示程序正常退出。</p>
<p>接下来我们借助 <code>gdb</code> 来观察程序运行时 <code>CF</code> 的值的变化。首先将上述代码保存为 <code>demo.s</code> 后进行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as demo.s -o demo.o -gstabs+</span><br></pre></td></tr></table></figure>
<p>这里的 <code>-gstabs+</code> 表示生成机器码时同时生成调试信息，如果没有这个选项后续 <code>gdb</code> 加载时会提示 <code>(No debugging symbols found in ./demo)</code>。</p>
<p>然后进行链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld demo.o -o demo</span><br></pre></td></tr></table></figure>
<p>这个时候就可以通过 <code>gdb</code> 加载生成的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./demo</span><br></pre></td></tr></table></figure>
<p><img src="/images/cf-of-1.png" alt="alt" /></p>
<p>然后输入 <code>break 4</code> 在代码第四行设置一个断点，即 <code>mov $255, %al</code> 处，最后输入 <code>run</code> 开始调试执行：</p>
<p><img src="/images/cf-of-2.png" alt="alt" /></p>
<p>此时可输入 <code>layout reg</code> 来观察各寄存器内的值，我们需要关注的是 <code>eflags</code> 寄存器，它展示了哪些标志位生效了：</p>
<p><img src="/images/cf-of-3.png" alt="alt" /></p>
<p>或者通过执行 <code>info registers eflags</code> 来查看 <code>eflags</code> 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info registers eflags</span><br><span class="line">eflags         0x202               [ IF ]</span><br></pre></td></tr></table></figure>
<p>目前只有一个 <code>IF</code> 标志位，它用于表示是否响应中断。</p>
<p>接着，输入 <code>next</code> 来执行当前断点所在处的指令，可以看到，执行后 <code>rax</code> 寄存器内的值变成了255（<code>rax</code> 是64位 <code>CPU</code> 下的一个通用寄存器，32位 <code>CPU</code> 下对应为 <code>eax</code>）：</p>
<p><img src="/images/cf-of-4.png" alt="alt" /></p>
<p>再输入一次 <code>next</code> 来执行加法运算，此时 <code>rax</code> 中的值变为了0（实际的二进制结果应该是100000000，因为 <code>al</code> 寄存器最多只能表示8位，所以最高位的1无法表示，最终结果为0），<code>eflags</code> 中出现了 <code>CF</code> 标志位，说明发生了进位：</p>
<p><img src="/images/cf-of-5.png" alt="alt" /></p>
<p><code>rax</code> 中的值为0也说明了加法运算后产生的进位并不会体现在比参与运算的寄存器位数更多的寄存器中，否则 <code>rax</code> 中的值应该是256。</p>
<p>再来看借位，将程序稍加修改执行一个 <code>1 - 2</code> 的运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    mov $1, %al</span><br><span class="line">    sub $2, %al</span><br><span class="line">    movl $1, %eax</span><br><span class="line">    movl $0, %ebx</span><br><span class="line">    int $0x80</span><br></pre></td></tr></table></figure>
<p>最后 <code>rax</code> 中的值为255（存在高位借位的情况下最后的二进制结果为11111111，解释为无符号数为255），<code>eflags</code> 中同样出现了 <code>CF</code> 标志位。</p>
<p><img src="/images/cf-of-6.png" alt="alt" /></p>
<p>所以，<code>CF</code> 的标记取决于两个二进制数的运算是否产生进位或借位。</p>
<h2 id="of"><a class="markdownIt-Anchor" href="#of"></a> OF</h2>
<p>有符号数的溢出分两种情况，一种是运算结果应该是正数却返回负数，另一种是运算结果应该是负数却返回正数。</p>
<p>首先来看两个正数运算得到负数的例子，同样对代码稍加修改实现 <code>127 + 1</code> 的运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    mov $127, %al</span><br><span class="line">    add $1, %al</span><br><span class="line">    movl $1, %eax</span><br><span class="line">    movl $0, %ebx</span><br><span class="line">    int $0x80</span><br></pre></td></tr></table></figure>
<p>最后 <code>rax</code> 中的值为128（对应二进制表示为10000000，以有符号数的角度来看，其值为-128，即两个正数相加得到一个负数），<code>eflags</code> 中出现了 <code>OF</code> 标志位，说明发生了溢出：</p>
<p><img src="/images/cf-of-7.png" alt="alt" /></p>
<p>从有符号数的角度来看，参与运算的两个数的符号位都是0，相加后符号位却是1，所以 <code>OF</code> 设置为1。</p>
<p>再来看两个负数运算得到正数的例子，再次对代码稍加修改实现 <code>-128 - 1</code> 的运算，-128的二进制补码表示为10000000，即无符号数角度下的128，-1的二进制补码表示为11111111，即无符号数角度下的255：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    mov $128, %al</span><br><span class="line">    add $255, %al</span><br><span class="line">    movl $1, %eax</span><br><span class="line">    movl $0, %ebx</span><br><span class="line">    int $0x80</span><br></pre></td></tr></table></figure>
<p>最后 <code>rax</code> 中的值为127（对应二进制表示为01111111，以有符号数的角度来看，其值为127，即两个负数相加得到一个正数），<code>eflags</code> 中出现了 <code>OF</code> 标志位，说明发生了溢出：</p>
<p><img src="/images/cf-of-8.png" alt="alt" /></p>
<p>从有符号数的角度来看，参与运算的两个数的符号位都是1，相加后符号位却是0，所以 <code>OF</code> 设置为1。</p>
<p>所以，<code>OF</code> 的标记取决于运算结果的符号位是否发生变化，这里的变化指的是两个相同符号位的数的运算结果是一个不同符号位的数。</p>
<h2 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h2>
<p>注意到前面有符号数 <code>-128 - 1</code> 运算的例子中，最后 <code>CF</code> 和 <code>OF</code> 都被设置为了1，说明 <code>CF</code> 和 <code>OF</code> 并不是互斥的关系，在这个例子中即发生了进位又发生了符号位的变更，也就是说如果满足了设置 <code>CF</code> 的条件，那么 <code>CF</code> 就是1，如果满足了设置 <code>OF</code> 的条件，那么 <code>OF</code> 就是1。因此，回到文章开头的问题，<code>CPU</code> 并不是去判断该设置 <code>CF</code> 还是 <code>OF</code>，而是只要条件满足就会设置对应的标志位，而具体应该关注哪个标志位，则交由编译器去判断，因为对 <code>CPU</code> 而言它处理的只是比特运算，只有编译器知道当前的运算数是无符号数还是有符号数。</p>
<p>另外，<code>CF</code> 和 <code>OF</code> 也不能合二为一，无法相互替代，例如两个无符号数相加 <code>CF</code> 有可能是0，但是 <code>OF</code> 却是1，如 <code>127 + 1</code>；两个有符号数相加 <code>OF</code> 有可能是0，但是 <code>CF</code> 却是1，如 <code>-1 - 1</code>。也有可能 <code>CF</code> 和 <code>OF</code> 都是1，如有符号数运算 <code>-128 - 1</code>。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt">The CARRY flag and OVERFLOW flag in binary arithmetic</a></li>
<li><a target="_blank" rel="noopener" href="https://niranjanmr.wordpress.com/2016/01/20/eflags-registers/">Eflags Registers</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1817577/what-does-int-0x80-mean-in-assembly-code">What does “int 0x80” mean in assembly code?</a></li>
<li>汇编语言（第4版），王爽</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/02/27/how-to-publich-java-package-to-maven-central-repo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/27/how-to-publich-java-package-to-maven-central-repo/" class="post-title-link" itemprop="url">发布 JAR 包到 Maven 中央仓库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-27T00:00:00+08:00">2022-02-27</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>6.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>11 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Sonatype OSSRH (OSS Repository Hosting)</code> 提供了 <code>JAR</code> 包发布服务，并支持自动将 <code>JAR</code> 包同步到 <code>Maven</code> 中央仓库，所以我们将 <code>JAR</code> 包发布到 <code>Sonatype OSSRH</code> 即可。</p>
<h2 id="创建-sonatype-工单"><a class="markdownIt-Anchor" href="#创建-sonatype-工单"></a> 创建 Sonatype 工单</h2>
<p>第一步在 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/secure/Signup!default.jspa">Sonatype</a> 上注册一个账号，创建成功后在上面创建一个 <code>Issue</code>，<code>Project</code> 选择 <code>Community Support - Open Source Project Repository Hosting (OSSRH)</code>，<code>Issue Type</code> 选择 <code>New Project</code>：</p>
<p><img src="/images/sonatype.png" alt="alt" /></p>
<p>这里要注意的是 <code>Group Id</code> 的填写，根据 <a target="_blank" rel="noopener" href="https://central.sonatype.org/publish/requirements/coordinates/">Coordinates</a> 的描述，这里分两种情况：</p>
<ol>
<li>你拥有某个域名，如 <code>example.com</code></li>
<li>你没有域名，但是你的代码托管在了某个代码托管服务上，如 <code>GitHub</code></li>
</ol>
<p>对于第一种情况，你的 <code>Group Id</code> 可以是任何以 <code>com.example</code> 为前缀的字符串，如 <code>com.example.myawesomeproject</code>。不过，<code>Sonatype</code> 会要求你证明确实拥有 <code>example.com</code> 域名，你需要在你的域名注册商那创建一条 <code>TXT</code> 记录，其内容就是你创建的 <code>Issue</code> 的工单号，如 <code>OSSRH-12345</code>，具体步骤可参考 <a target="_blank" rel="noopener" href="https://central.sonatype.org/faq/how-to-set-txt-record/">How do I set the TXT record needed to prove ownership of my Web Domain?</a>。</p>
<p>对于第二种情况，以 <code>GitHub</code> 为例，你的 <code>Group Id</code> 必须是 <code>io.github.myusername</code>，<code>myusername</code> 是你的 <code>GitHub</code> 账户名或者是组织名，类似的，为了证明你对 <code>myusername</code> 的所有权，你需要在 <code>myusername</code> 下创建一个公开的仓库，仓库名称为你所创建 <code>Issue</code> 的工单号，如 <code>OSSRH-12345</code>，认证完成之后你就可以删掉这个仓库。<code>Sonatype</code> 所支持的代码托管服务如下：</p>
<table>
<thead>
<tr>
<th>Service</th>
<th>Example groupId</th>
</tr>
</thead>
<tbody>
<tr>
<td>GitHub</td>
<td>io.github.myusername</td>
</tr>
<tr>
<td>GitLab</td>
<td>io.gitlab.myusername</td>
</tr>
<tr>
<td>Gitee</td>
<td>io.gitee.myusername</td>
</tr>
<tr>
<td>Bitbucket</td>
<td>io.bitbucket.myusername</td>
</tr>
<tr>
<td>SourceForge</td>
<td>io.sourceforge.myusername</td>
</tr>
</tbody>
</table>
<p>工单示例可参考 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/browse/OSSRH-78488">Publish my open source java package</a>。</p>
<h2 id="安装-gpg"><a class="markdownIt-Anchor" href="#安装-gpg"></a> 安装 GPG</h2>
<p><code>GPG</code> 用于对所发布的包进行签名，在 <a target="_blank" rel="noopener" href="https://www.gnupg.org/download/index.html">GnuPG</a> 根据自己的操作系统下载 <code>GPG</code> 安装包，安装完成后执行 <code>gpg --full-gen-key</code> 生成秘钥对，选择默认选项即可，生成秘钥对时会要求输入姓名、邮箱、注释和密码，其中密码在发布阶段会用到，秘钥生成信息类似如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub   rsa3072 2022-02-26 [SC]</span><br><span class="line">      E892F685E5EA9005E0A2DE31F0F732425A15D81D</span><br><span class="line">uid                      examplename &lt;examplename@example.com&gt;</span><br><span class="line">sub   rsa3072 2022-02-26 [E]</span><br></pre></td></tr></table></figure>
<p>其中 <code>E892F685E5EA9005E0A2DE31F0F732425A15D81D</code> 是秘钥的 <code>ID</code>，然后我们需要将公钥分发到公共的秘钥服务器上，这样 <code>Sonatype</code> 就可以通过这个公钥来验证我们所发布包的签名是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver keyserver.ubuntu.com --send-keys E892F685E5EA9005E0A2DE31F0F732425A15D81D</span><br></pre></td></tr></table></figure>
<p>这里选择的公共秘钥服务器是 <code>keyserver.ubuntu.com</code>，也可以选择其他服务器，如 <code>keys.openpgp.org</code> 或者 <code>pgp.mit.edu</code>。</p>
<h2 id="配置-settingsxml"><a class="markdownIt-Anchor" href="#配置-settingsxml"></a> 配置 settings.xml</h2>
<p>为了将包发到 <code>Sonatype OSSRH</code>，需要在 <code>Maven</code> 的 <code>settings.xml</code> 中配置用户信息，即在 <code>servers</code> 下添加如下信息，这里的 <code>your-jira-id</code> 和 <code>your-jira-pwd</code> 对应第一步创建的账号和密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;your-jira-id&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;your-jira-pwd&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure>
<p>另外，为了在打包时对文件进行签名还需要在 <code>profiles</code> 下添加如下信息，这里的 <code>the_pass_phrase</code> 为生成 <code>GPG</code> 秘钥时设置的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;profile&gt;</span><br><span class="line">    &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">    &lt;activation&gt;</span><br><span class="line">    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">    &lt;/activation&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">    &lt;gpg.executable&gt;gpg&lt;/gpg.executable&gt;</span><br><span class="line">    &lt;gpg.passphrase&gt;the_pass_phrase&lt;/gpg.passphrase&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置-pomxml"><a class="markdownIt-Anchor" href="#配置-pomxml"></a> 配置 pom.xml</h2>
<p>最后是配置 <code>pom.xml</code>，首先我们需要告诉 <code>Maven</code> 将包部署到 <code>Sonatype OSSRH</code>，需要增加一个 <code>nexus-staging-maven-plugin</code> 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">  &lt;snapshotRepository&gt;</span><br><span class="line">    &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;https://s01.oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</span><br><span class="line">  &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.7&lt;/version&gt;</span><br><span class="line">      &lt;extensions&gt;true&lt;/extensions&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;serverId&gt;ossrh&lt;/serverId&gt;</span><br><span class="line">        &lt;nexusUrl&gt;https://s01.oss.sonatype.org/&lt;/nexusUrl&gt;</span><br><span class="line">        &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>然后是配置 <code>Javadoc</code> 和源码插件，如果最后的 <code>JAR</code> 包没有包含 <code>Javadoc</code> 和源码，<code>Sonatype</code> 会不允许通过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;attach-javadocs&lt;/id&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>不过上述配置不适合 <code>Kotlin</code> 项目，会提示 <code>Missing: no javadoc jar found in folder '/com/example/username/awesomeproject'</code>，需要将 <code>maven-javadoc-plugin</code> 替换为 <code>dokka-maven-plugin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.jetbrains.dokka&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dokka-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">            &lt;execution&gt;</span><br><span class="line">                &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                &lt;id&gt;attach-javadocs-dokka&lt;/id&gt;</span><br><span class="line">                &lt;goals&gt;</span><br><span class="line">                    &lt;goal&gt;javadocJar&lt;/goal&gt;</span><br><span class="line">                &lt;/goals&gt;</span><br><span class="line">            &lt;/execution&gt;</span><br><span class="line">        &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>最后，剩下补充一些元数据，这个也是必填项，包括：</p>
<ul>
<li>项目名称，描述和地址</li>
<li>许可证信息</li>
<li>开发者信息</li>
<li>源码地址</li>
</ul>
<p>完整的示例可参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.simpligility.training&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;ossrh-demo&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;ossrh-demo&lt;/name&gt;</span><br><span class="line">  &lt;description&gt;A demo for deployment to the Central Repository via OSSRH&lt;/description&gt;</span><br><span class="line">  &lt;url&gt;http://github.com/simpligility/ossrh-demo&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;licenses&gt;</span><br><span class="line">    &lt;license&gt;</span><br><span class="line">      &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;</span><br><span class="line">    &lt;/license&gt;</span><br><span class="line">  &lt;/licenses&gt;</span><br><span class="line"></span><br><span class="line">  &lt;developers&gt;</span><br><span class="line">    &lt;developer&gt;</span><br><span class="line">      &lt;name&gt;Manfred Moser&lt;/name&gt;</span><br><span class="line">      &lt;email&gt;manfred@sonatype.com&lt;/email&gt;</span><br><span class="line">      &lt;organization&gt;Sonatype&lt;/organization&gt;</span><br><span class="line">      &lt;organizationUrl&gt;http://www.sonatype.com&lt;/organizationUrl&gt;</span><br><span class="line">    &lt;/developer&gt;</span><br><span class="line">  &lt;/developers&gt;</span><br><span class="line"></span><br><span class="line">  &lt;scm&gt;</span><br><span class="line">    &lt;connection&gt;scm:git:git://github.com/simpligility/ossrh-demo.git&lt;/connection&gt;</span><br><span class="line">    &lt;developerConnection&gt;scm:git:ssh://github.com:simpligility/ossrh-demo.git&lt;/developerConnection&gt;</span><br><span class="line">    &lt;url&gt;http://github.com/simpligility/ossrh-demo/tree/master&lt;/url&gt;</span><br><span class="line">  &lt;/scm&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h2 id="发包"><a class="markdownIt-Anchor" href="#发包"></a> 发包</h2>
<p>执行 <code>mvn clean deploy</code> 即可发包，如果执行成功，在提交的工单中会自动增加一条回复：</p>
<blockquote>
<p>Central sync is activated for com.example.awesomeproject. After you successfully release, your component will be available to the public on Central <a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a>, typically within 30 minutes, though updates to <a target="_blank" rel="noopener" href="https://search.maven.org">https://search.maven.org</a> can take up to four hours.</p>
</blockquote>
<p>也就是30分钟内即可从 <code>Maven</code> 中央仓库下载 <code>JAR</code> 包，不过要想能在 <code>search.maven.org</code> 搜索到你的 <code>JAR</code> 包，需要等待至多4个小时。</p>
<p>另外，因为配置 <code>nexus-staging-maven-plugin</code> 时指定了 <code>autoReleaseAfterClose</code> 为 <code>true</code>，所以发包后不需要去 <code>https://oss.sonatype.org/#stagingRepositories</code> 手动执行 <code>close</code> 和 <code>release</code> 操作。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/publish-your-artifacts-to-maven-central">How to Publish Your Artifacts to Maven Central</a></li>
<li><a target="_blank" rel="noopener" href="https://central.sonatype.org/publish/requirements/coordinates/">Coordinates</a></li>
<li><a target="_blank" rel="noopener" href="https://central.sonatype.org/publish/requirements/gpg/">GPG</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/02/22/delete-node-in-binary-search-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/22/delete-node-in-binary-search-tree/" class="post-title-link" itemprop="url">二叉搜索树的删除</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-22T00:00:00+08:00">2022-02-22</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>二叉搜索树的删除可以分为三种情况。第一，被删除的节点是叶子节点：</p>
<p><img src="/images/bst-delete-1.png" alt="alt" /></p>
<p>第二，被删除的节点只有一个孩子节点：</p>
<p><img src="/images/bst-delete-2.png" alt="alt" /></p>
<p>第三，被删除的节点有两个孩子节点：</p>
<p><img src="/images/bst-delete-3.png" alt="alt" /></p>
<p>对于第一种情况，我们只需断开被删除的节点和其父节点的关联即可，即将节点3的左孩子节点指针置为空；对于第二种情况，我们可以用被删除的节点的孩子节点来替代被删除的节点，即将节点5的右孩子指针改为指向节点7；第三种情况是最为复杂的情况，相当于删除一个子树的根节点，为了保持二叉搜索树的性质，我们可以使用左子树中的最大值或右子树的最小值来替代被删除的根节点。</p>
<p>不过在实现时，考虑到实现的简便，对于第三种情况会通过直接修改当前节点的值来替代修改节点的指针指向，以上述例子来说，如果使用指针修改的方式，则需要修改节点5的左孩子指针，修改节点2的左孩子指针和右孩子指针（这里假设使用节点2来替代被删除的节点3），总共三处修改较为繁琐；而如果使用修改节点值的方式，只需要先将节点3的值改为2（这里假设使用节点2来替代被删除的节点3），然后就可以将问题转化为在余下的左子树中删除节点2。具体代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">                root.val = self._find_min(root.right)</span><br><span class="line">                root.right = self.deleteNode(root.right, root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root.left <span class="keyword">or</span> root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_min</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/02/13/mit-6.824-map-reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/13/mit-6.824-map-reduce/" class="post-title-link" itemprop="url">MIT 6.824 - MapReduce: Simplified Data Processing on Large Clusters</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-13T00:00:00+08:00">2022-02-13</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>26 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p><code>MapReduce: Simplified Data Processing on Large Clusters</code> 是 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/">6.824: Distributed Systems</a> 中所介绍的第一篇论文。它提出了一种针对大数据处理的编程模型和实现，使得编程人员无需并行和分布式系统经验就可以轻松构建大数据处理应用。该模型将大数据处理问题拆解为两步，即 <code>map</code> 和 <code>reduce</code>，<code>map</code> 阶段将一组输入的键值对转化为中间结果键值对，<code>reduce</code> 阶段对中间结果键值对按照相同的键进行值的合并，从而得到最终的结果。</p>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>对于 <code>Google</code> 来说，每天运行的系统会产生大量的原始数据，同时又要对这些原始数据进行加工产生各种衍生数据，虽然大部分数据加工的逻辑都较为简单，然而由于数据量过于庞大，为了在合理的时间内完成数据处理，通常需要将待处理的数据分发到几百或几千台机器上并行计算，这就存在几个问题：</p>
<ol>
<li>如何使计算可并行</li>
<li>如何分发数据</li>
<li>如何处理异常</li>
</ol>
<p>如果每一个数据加工任务都需要独立去解决上述的问题，一方面会使得原本简单的代码逻辑变得庞大、复杂和难以维护，另一方面也是在重复工作。受 <code>Lisp</code> 等其他函数式编程语言中的 <code>map</code> 和 <code>reduce</code> 函数的启发，<code>Google</code> 的工程师们发现大部分的数据处理遵循如下的模式：</p>
<ol>
<li>对输入的每一条数据应用一个 <code>map</code> 函数产生一组中间结果键值对</li>
<li>对中间结果键值对按照相同的键聚合后，应用 <code>reduce</code> 函数生成最终的衍生数据</li>
</ol>
<p>因此，<code>Google</code> 的工程师们抽象出了 <code>MapReduce</code> 框架，使得应用开发人员可以专注于计算逻辑实现而无需关心底层运行细节，统一由框架层处理并行、容错、数据分发和负载均衡等系统问题。现在再来看前面提到的问题是如何解决的：</p>
<ol>
<li>如何使计算可并行：在 <code>map</code> 阶段，对数据分发后，各任务间无依赖，可并行执行；在 <code>reduce</code> 阶段，不同 <code>key</code> 的数据处理间无依赖，可并行执行</li>
<li>如何分发数据：在 <code>map</code> 阶段，可按执行 <code>map</code> 任务的节点数量平均分发（这只是一种可能的策略，具体分发策略见后文描述）；在 <code>reduce</code> 阶段，可按 <code>key</code> 相同的数据聚合后分发</li>
<li>如何处理异常：重新执行某个节点上失败的 <code>map</code> 或 <code>reduce</code> 任务作为首要的容错手段</li>
</ol>
<h2 id="编程模型"><a class="markdownIt-Anchor" href="#编程模型"></a> 编程模型</h2>
<p>假设需要统计一组文档中每个单词出现的次数，在 <code>MapReduce</code> 框架下用户需要编写 <code>map</code> 和 <code>reduce</code> 函数，近似的伪代码表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    // key: document name</span><br><span class="line">    // value: document contents</span><br><span class="line">    for each word w in value:</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    // key: a word</span><br><span class="line">    // values: a list of counts</span><br><span class="line">    int result = 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        result += ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>假设有两个文档 <code>hello.txt</code> 和 <code>world.txt</code>，其内容分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello.txt:</span><br><span class="line">It was the best of times</span><br><span class="line"></span><br><span class="line">world.txt:</span><br><span class="line">it was the worst of times</span><br></pre></td></tr></table></figure>
<p>对上述 <code>map</code> 和 <code>reduce</code> 函数来说，<code>map</code> 函数每次处理一个文档，<code>key</code> 为文档的名称，<code>value</code> 为文档的内容，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map(&quot;hello.txt&quot;, &quot;It was the best of times&quot;)</span><br><span class="line">map(&quot;world.txt&quot;, &quot;it was the worst of times&quot;)</span><br></pre></td></tr></table></figure>
<p><code>map</code> 函数执行时会遍历文档的内容，对每个单词输出中间结果键值对（作为示例，这里省去了将文档内容拆分为单词的过程，同时也忽略了标点符号、大小写等与示例无关的内容），键为单词，值为 <code>&quot;1&quot;</code>，所有 <code>map</code> 函数执行完成后生成的中间结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hello.txt:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">best 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br><span class="line"></span><br><span class="line">world.txt:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">worst 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br></pre></td></tr></table></figure>
<p>然后，<code>MapReduce</code> 框架对所有中间结果按照相同的键进行聚合，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">was [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">the [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">best [&quot;1&quot;]</span><br><span class="line">worst [&quot;1&quot;]</span><br><span class="line">of [&quot;1&quot;, &quot;1&quot;]</span><br><span class="line">times [&quot;1&quot;, &quot;1&quot;]</span><br></pre></td></tr></table></figure>
<p>最后，<code>MapReduce</code> 框架将上述聚合后的数据分发给 <code>reduce</code> 函数执行，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reduce(&quot;it&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;was&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;the&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;best&quot;, [&quot;1&quot;])</span><br><span class="line">reduce(&quot;worst&quot;, [&quot;1&quot;])</span><br><span class="line">reduce(&quot;of&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br><span class="line">reduce(&quot;times&quot;, [&quot;1&quot;, &quot;1&quot;])</span><br></pre></td></tr></table></figure>
<p><code>reduce</code> 函数执行时会遍历 <code>values</code>，将每个字符串转换为整型后累加，然后作为 <code>reduce</code> 的结果返回，最终得到所有单词出现的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it 2</span><br><span class="line">was 2</span><br><span class="line">the 2</span><br><span class="line">best 1</span><br><span class="line">worst 1</span><br><span class="line">of 2</span><br><span class="line">times 2</span><br></pre></td></tr></table></figure>
<p>实际执行 <code>reduce</code> 函数时，并不会将 <code>values</code> 一次性传给某个 <code>reduce</code> 函数，因为有可能数据量太大无法完全载入内存，所以 <code>values</code> 在实现时是个迭代器，<code>reduce</code> 函数能以流式的形式获取值。</p>
<p>另外，虽然在上述的例子中 <code>map</code> 和 <code>reduce</code> 处理的都是字符串类型的数据，但是也可以支持其他类型的数据，<code>map</code> 和 <code>reduce</code> 处理的数据类型遵循如下的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map (k1, v1) -&gt; list(k2, v2)</span><br><span class="line">reduce (k2, list(v2)) -&gt; list(v2)</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>map</code> 产生的中间结果的数据类型和最终结果的数据类型是一致的。对整个框架来说，最初的输入和最终的输出都是某种形式的字节流或字符串，因此在 <code>Google</code> 的 <code>C++</code> 实现中，提供了专门的数据转换接口，用户可实现该接口用于字符串和 <code>map</code>、<code>reduce</code> 需要的数据类型之间转换。</p>
<h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2>
<p><code>MapReduce</code> 的具体实现视硬件环境的不同而不同，论文中描述的实现是针对 <code>Google</code> 内部广泛使用的硬件环境，即通过交换以太网相连的大量廉价 <code>PC</code> 组成的集群：</p>
<ol>
<li>每台机器的配置一般为双核 <code>x86</code> 处理器，<code>2-4 GB</code> 内存，运行 <code>Linux</code> 系统</li>
<li>使用廉价网络硬件，带宽一般为 <code>100 Mbit/s</code> 或 <code>1 Gbit/s</code>，不过平均来说会小于 <code>bisection bandwidth</code>（<code>bisection bandwidth</code> 指当某个网络被分成两部分时，这两部分间的带宽）</li>
<li>一个集群一般由几百上千台机器组成，所以机器异常是家常便饭</li>
<li>存储使用的是廉价的 <code>IDE</code> 硬盘，并直接装载到了机器上。不过 <code>Google</code> 内部实现了一套分布式文件存储系统来管理这些硬盘上的数据，并通过数据冗余作为在不可靠的硬件上实现可用性和可靠性的手段。</li>
<li>用户向调度系统提交一组任务，每个任务包含多个子任务，调度系统会为每个任务分配一批集群内的机器执行。</li>
</ol>
<h3 id="执行概览"><a class="markdownIt-Anchor" href="#执行概览"></a> 执行概览</h3>
<p>在 <code>map</code> 执行阶段，框架会自动将输入数据分为 <code>M</code> 片，从而将 <code>map</code> 任务分发到多台机器上并行执行，每台机器只处理某一片的数据。同样的，在 <code>reduce</code> 阶段，框架首先将中间结果数据根据分片函数（例如 <code>hash(key) mod R</code>）拆分为 <code>R</code> 片，然后分发给 <code>reduce</code> 任务执行，用户可自行指定 <code>R</code> 的值和实现具体的分片函数。</p>
<p>下图展示了 <code>Google</code> 所实现的 <code>MapReduce</code> 框架的整体执行流程：</p>
<p><img src="/images/map-reduce.png" alt="alt" /></p>
<p>当用户提交 <code>MapReduce</code> 任务后，框架会执行以下一系列流程（下文中的序号和上图中的序号对应）：</p>
<ol>
<li>首先 <code>MapReduce</code> 框架将输入数据分为 <code>M</code> 片，每片数据大小一般为 <code>16 MB</code> 至 <code>64 MB</code>（具体大小可由用户入参控制），然后将 <code>MapReduce</code> 程序复制到集群中的一批机器上运行。</li>
<li>在所有的程序拷贝中，某台机器上的程序会成为主节点（<code>master</code>），其余称为工作节点（<code>worker</code>），由主节点向工作节点分派任务，一共有 <code>M</code> 个 <code>map</code> 任务和 <code>R</code> 个 <code>reduce</code> 任务需要分派。主节点会选择空闲的工作节点分派 <code>map</code> 或 <code>reduce</code> 任务。</li>
<li>如果某个工作节点被分派了 <code>map</code> 任务则会读取当前的数据分片，然后将输入数据解析为一组键值对后传递给用户自定义的 <code>map</code> 函数执行。<code>map</code> 函数产生的中间结果键值对会暂存在内存中。</li>
<li>暂存在内存中的中间结果键值对会周期性的写入到本地磁盘中，并根据某个分片函数将这些数据写入到本地磁盘下的 <code>R</code> 个区，这样相同键的中间结果数据在不同的 <code>map</code> 节点下属于同一个区号，就可以在后续将同一个键的中间结果数据全部发给同一个 <code>reduce</code> 节点。同时，这些数据写入后的地址会回传给 <code>master</code> 节点，<code>master</code> 节点会将这些数据的地址发送给相应的 <code>reduce</code> 节点。</li>
<li>当 <code>reduce</code> 节点接收到 <code>master</code> 节点发送的中间结果数据地址通知后，将通过 <code>RPC</code> 请求根据数据地址读取 <code>map</code> 节点生成的数据。在所有中间结果数据都读取完成后，<code>reduce</code> 节点会先将所有中间结果数据按照键进行排序，这样所有键相同的数据就聚合在了一起。之所以要排序是因为一个 <code>reduce</code> 节点会分发处理多个键下的中间结果数据。如果中间结果数据量太大不足以完全载入内存，则需要使用外部排序。</li>
<li><code>reduce</code> 节点执行时会先遍历排序后的中间结果数据，每遇到一个新的键就会将该键及其对应的所有中间结果数据传递给用户自定义的 <code>reduce</code> 函数执行。<code>reduce</code> 函数执行的结果数据会追加到当前 <code>reduce</code> 节点的最终输出文件里。</li>
<li>当所有 <code>map</code> 任务和 <code>reduce</code> 任务都执行完成后，<code>master</code> 节点会唤醒用户程序，并将控制权交还给用户代码。</li>
</ol>
<p>当成功结束 <code>MapReduce</code> 任务后，其执行结果就保存在了 <code>R</code> 个文件中（每个文件对应一个 <code>reduce</code> 节点的产出，文件的名字由用户所指定）。一般来说，用户不必将这 <code>R</code> 个输出文件合并成一个，它们通常会作为另一个 <code>MapReduce</code> 任务的输入，或交由其他分布式应用处理。</p>
<p>基于上述流程，再来看在 <code>编程模型</code> 这节中的例子。假设有6个文档，分别是 <code>1.txt</code> 到 <code>6.txt</code>，每个文档中的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.txt:</span><br><span class="line">It was the best of times</span><br><span class="line"></span><br><span class="line">2.txt:</span><br><span class="line">it was the worst of times</span><br><span class="line"></span><br><span class="line">3.txt:</span><br><span class="line">it was the age of wisdom</span><br><span class="line"></span><br><span class="line">4.txt:</span><br><span class="line">it was the age of foolishness</span><br><span class="line"></span><br><span class="line">5.txt:</span><br><span class="line">it was the epoch of belief</span><br><span class="line"></span><br><span class="line">6.txt:</span><br><span class="line">it was the epoch of incredulity</span><br></pre></td></tr></table></figure>
<p>对应 <code>MapReduce</code> 执行流程为：</p>
<ol>
<li>我们假设每两个文档的数据大小为 <code>16 MB</code>，则6个文档对应3片数据</li>
<li>由1所知一共有3个 <code>map</code> 任务，不妨将 <code>reduce</code> 任务也设为3个，并将6个文档按顺序每两个一组依次分发给每个 <code>map</code> 节点</li>
<li>每个 <code>map</code> 节点处理的数据分片为两个文档，所产生的中间结果数据分别为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">map worker 1:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">best 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">worst 1</span><br><span class="line">of 1</span><br><span class="line">times 1</span><br><span class="line"></span><br><span class="line">map worker 2:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">age 1</span><br><span class="line">of 1</span><br><span class="line">wisdom 1</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">age 1</span><br><span class="line">of 1</span><br><span class="line">foolishness 1</span><br><span class="line"></span><br><span class="line">map worker 3:</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">epoch 1</span><br><span class="line">of 1</span><br><span class="line">belief 1</span><br><span class="line">it 1</span><br><span class="line">was 1</span><br><span class="line">the 1</span><br><span class="line">epoch 1</span><br><span class="line">of 1</span><br><span class="line">incredulity 1</span><br></pre></td></tr></table></figure>
</li>
<li>在每个 <code>map</code> 节点上将中间结果数据按照某个哈希函数分发到3个区，不妨为以下结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">map worker 1:</span><br><span class="line">    region 1:</span><br><span class="line">    it 1</span><br><span class="line">    best 1</span><br><span class="line">    it 1</span><br><span class="line"></span><br><span class="line">    region 2:</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    was 1</span><br><span class="line">    worst 1</span><br><span class="line">    of 1</span><br><span class="line"></span><br><span class="line">    region 3:</span><br><span class="line">    the 1</span><br><span class="line">    times 1</span><br><span class="line">    the 1</span><br><span class="line">    times 1</span><br><span class="line"></span><br><span class="line">map worker 2:</span><br><span class="line">    region 1:</span><br><span class="line">    it 1</span><br><span class="line">    age 1</span><br><span class="line">    it 1</span><br><span class="line">    age 1</span><br><span class="line">    foolishness 1</span><br><span class="line"></span><br><span class="line">    region 2:</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    of 1</span><br><span class="line">    wisdom 1</span><br><span class="line">    was 1</span><br><span class="line"></span><br><span class="line">    region 3:</span><br><span class="line">    the 1</span><br><span class="line">    the 1</span><br><span class="line"></span><br><span class="line">map worker 3:</span><br><span class="line">    region 1:</span><br><span class="line">    it 1</span><br><span class="line">    epoch 1</span><br><span class="line">    belief 1</span><br><span class="line">    it 1</span><br><span class="line">    epoch 1</span><br><span class="line">    </span><br><span class="line">    region 2:</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    was 1</span><br><span class="line">    of 1</span><br><span class="line">    </span><br><span class="line">    region 3:</span><br><span class="line">    the 1</span><br><span class="line">    the 1</span><br><span class="line">    incredulity 1</span><br></pre></td></tr></table></figure>
</li>
<li><code>reduce</code> 节点按照数据分区接收到所有中间结果数据后将其按照键排序： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">reduce worker 1:</span><br><span class="line">age 1</span><br><span class="line">age 1</span><br><span class="line">belief 1</span><br><span class="line">best 1</span><br><span class="line">epoch 1</span><br><span class="line">epoch 1</span><br><span class="line">foolishness 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line">it 1</span><br><span class="line"></span><br><span class="line">reduce worker 2:</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">of 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">was 1</span><br><span class="line">wisdom 1</span><br><span class="line">worst 1</span><br><span class="line"></span><br><span class="line">reduce worker 3:</span><br><span class="line">incredulity 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">the 1</span><br><span class="line">times 1</span><br><span class="line">times 1</span><br></pre></td></tr></table></figure>
</li>
<li><code>reduce</code> 节点调用用户自定义 <code>reduce</code> 函数计算单词出现次数，最终每个 <code>reduce</code> 节点的输出文件为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">reduce worker 1 output:</span><br><span class="line">age 2</span><br><span class="line">belief 1</span><br><span class="line">best 1</span><br><span class="line">epoch 2</span><br><span class="line">foolishness 1</span><br><span class="line">it 6</span><br><span class="line"></span><br><span class="line">reduce worker 2 output:</span><br><span class="line">of 6</span><br><span class="line">was 6</span><br><span class="line">wisdom 1</span><br><span class="line">worst 1</span><br><span class="line"></span><br><span class="line">reduce worker 3 output:</span><br><span class="line">incredulity 1</span><br><span class="line">the 6</span><br><span class="line">times 2</span><br></pre></td></tr></table></figure>
</li>
<li>将代码控制权交还给用户代码</li>
</ol>
<h3 id="master-节点数据结构"><a class="markdownIt-Anchor" href="#master-节点数据结构"></a> Master 节点数据结构</h3>
<p><code>master</code> 节点需要维护当前所有的 <code>map</code> 和 <code>reduce</code> 任务，每个任务需区分不同的状态（空闲、进行中、完成），同时还需要知道每个任务对应的工作节点。作为 <code>map</code> 节点和 <code>reduce</code> 节点间中间结果数据的传输媒介，<code>master</code> 节点需保存 <code>R</code> 个中间结果分区，每当一个 <code>map</code> 节点执行成功时，会将生成的 <code>R</code> 个中间结果文件地址发送给 <code>master</code> 节点，当 <code>master</code> 节点收到通知后，会将其转发给对应进行中的 <code>reduce</code> 节点。</p>
<p>对应数据结构简单示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 任务状态</span><br><span class="line">enum TaskState &#123;</span><br><span class="line">    // 空闲</span><br><span class="line">    Idle,</span><br><span class="line"></span><br><span class="line">    // 进行中</span><br><span class="line">    InProgress,</span><br><span class="line"></span><br><span class="line">    // 完成</span><br><span class="line">    Completed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个 map 或 reduce 任务</span><br><span class="line">class Task &#123;</span><br><span class="line">    // 任务状态</span><br><span class="line">    TaskState state;</span><br><span class="line"></span><br><span class="line">    // 对应的工作节点 id</span><br><span class="line">    int workerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工作节点</span><br><span class="line">class Worker &#123;</span><br><span class="line">    // 节点 id</span><br><span class="line">    int id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Map 任务产生的中间结果文件，一个 map 任务一般会产生多个中间结果文件</span><br><span class="line">class IntermediateFile &#123;</span><br><span class="line">    // 文件地址</span><br><span class="line">    string location;</span><br><span class="line"></span><br><span class="line">    // 文件大小</span><br><span class="line">    long size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间结果文件集，所有 map 任务产生的中间结果文件会根据分片函数划分到本地磁盘下的 R 个区</span><br><span class="line">class IntermediateFileRegion &#123;</span><br><span class="line">    // 中间结果文件</span><br><span class="line">    IntermediateFile[] intermediateFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Map 节点</span><br><span class="line">class MapWorker : Worker &#123;</span><br><span class="line">    // 中间结果文件集，一共有 R 个</span><br><span class="line">    IntermediateFileRegion[] intermediateFileRegions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Reduce 节点</span><br><span class="line">class ReduceWorker : Worker &#123;</span><br><span class="line">    // 中间结果文件，master 节点会不断发送中间结果文件给 reduce 节点，当所有中间结果文件都收到后，reduce 节点开始工作</span><br><span class="line">    IntermediateFile[] intermediateFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主节点</span><br><span class="line">class Master &#123;</span><br><span class="line">    // Map 任务，一共有 M 个</span><br><span class="line">    Task[] mapTasks;</span><br><span class="line"></span><br><span class="line">    // Reduce 任务，一共有 R 个</span><br><span class="line">    Task[] reduceTasks;</span><br><span class="line"></span><br><span class="line">    // 工作节点，最多有 M + R 个，一个工作节点并不是只负责 map 或者 reduce 任务，master 节点会选择空闲节点分派 map 或者 reduce 任务</span><br><span class="line">    Worker[] workers;</span><br><span class="line"></span><br><span class="line">    // 中间结果文件集，一共有 R 个，由 map 节点下的中间结果文件集聚合而来，某个 map 节点执行成功后会将生成的 R 个中间结果文件地址发送给 master 节点，由 master 节点将某个区下的中间结果文件地址转发给对应 reduce 节点</span><br><span class="line">    IntermediateFileRegion[] intermediateFileRegions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容错"><a class="markdownIt-Anchor" href="#容错"></a> 容错</h3>
<p>因为 <code>MapReduce</code> 框架借助几百或几千台机器来处理海量数据，所以必须优雅的应对机器异常。</p>
<h4 id="工作节点异常"><a class="markdownIt-Anchor" href="#工作节点异常"></a> 工作节点异常</h4>
<p><code>master</code> 节点会周期性的对工作节点进行探活。如果某个工作节点在一段时间内无响应，则 <code>master</code> 节点会将该工作节点标记为异常。该工作节点完成的所有 <code>map</code> 任务的状态都会被重置为空闲，可重新被 <code>master</code> 节点调度到其他工作节点上执行。类似的，该工作节点所有进行中的 <code>map</code> 或 <code>reduce</code> 任务也都会被重置为空闲，并重新接受调度。</p>
<p>之所以这里已完成的 <code>map</code> 任务也需要重新执行是因为所产生的中间结果文件是保存在 <code>map</code> 节点的本地磁盘上，当该节点无响应时便认为无法与之连通从而认为无法通过 <code>RPC</code> 请求获取这些数据。而如果 <code>reduce</code> 节点异常，它所完成的 <code>reduce</code> 任务不需要重新执行是因为 <code>reduce</code> 节点执行成功后产生的输出文件是保存在全局的文件系统上。</p>
<p>如果某个 <code>map</code> 任务一开始由工作节点 <code>A</code> 执行，之后由工作节点 <code>B</code> 执行（因为节点 <code>A</code> 发生了异常），则所有执行 <code>reduce</code> 任务的节点都会被通知，其中所有要从节点 <code>A</code> 读取数据但还未读取的 <code>reduce</code> 节点会转而从节点 <code>B</code> 读取数据。</p>
<p><code>MapReduce</code> 框架能从容应对大量的节点异常。例如，在某次 <code>MapReduce</code> 任务中，由于对运行中的集群进行网络维护一次性造成了80台机器在几分钟内无法连通。<code>MapReduce</code> 框架可直接重新分发和执行这些不连通的节点正在处理的任务，然后继续后续流程，并最终完成当次任务。</p>
<h4 id="主节点异常"><a class="markdownIt-Anchor" href="#主节点异常"></a> 主节点异常</h4>
<p>类似于游戏的自动存档，我们可以定期为主节点内部的数据结构保存检查点。如果主节点发生异常，则可以重新启动一个主节点程序并加载最新的检查点数据。然而对于单个主节点来说，主节点异常发生的概率较小，所以在 <code>Google</code> 的实现中，如果主节点发生异常，则会直接中断当次 <code>MapReduce</code> 任务。客户端可捕获到这种情况，并根据自身需要决定是否进行重试。</p>
<h4 id="执行语义"><a class="markdownIt-Anchor" href="#执行语义"></a> 执行语义</h4>
<p>如果用户编写的 <code>map</code> 和 <code>reduce</code> 函数是确定性的函数（即对于相同的输入始终返回相同的输出），则对于同一份输入，分布式的 <code>MapReduce</code> 框架的执行结果和一个串行执行且没有任何异常的 <code>MapReduce</code> 框架的执行结果相同。</p>
<p>不论是 <code>map</code> 还是 <code>task</code> 任务，都需要将执行结果写入到文件系统上，通过原子性的写入提交，可实现上述的语义保证。每个进行中的任务会先将输出结果写入到私有临时文件中，对 <code>reduce</code> 任务来说，最终只产生一个文件，而对于 <code>map</code> 任务则会产生 <code>R</code> 个文件（每个文件对应一个 <code>reduce</code> 任务）。当一个 <code>map</code> 任务执行完成时，<code>map</code> 节点会发送一条消息给 <code>master</code> 节点，这条消息中包含了 <code>map</code> 任务所生成的 <code>R</code> 个临时文件的名字。如果 <code>master</code> 节点收到了一条已经完成的 <code>map</code> 任务的消息，则会忽略该消息，否则将 <code>R</code> 个临时文件的名字保存在内部的数据结构中。</p>
<p>当 <code>reduce</code> 任务执行完成时，<code>reduce</code> 节点能原子性的将其生成的临时文件重命名为最终的输出文件。如果同一个 <code>reduce</code> 任务有多个工作节点执行（因为网络连通问题导致 <code>master</code> 重新分发 <code>reduce</code> 任务），则对同一个最终输出文件会有多个文件重命名的请求。通过底层文件系统的原子性重命名保证，最终的输出文件只会对应一个 <code>reduce</code> 任务的结果。</p>
<p>在 <code>Google</code> 内部大部分的 <code>map</code> 和 <code>reduce</code> 函数都是确定性的，在这种情况下分布式程序执行的结果和串行程序执行的结果相同的语义性保证使得开发人员能很容易的审视所编写的程序的行为（即如果程序的执行结果不符合预期，那么可以基本肯定的是开发人员编写的 <code>map</code> 或者 <code>reduce</code> 函数存在问题，而不是 <code>MapReduce</code> 框架存在问题）。当 <code>map</code> 或者 <code>reduce</code> 函数不具有确定性时，框架能提供稍弱一级但仍是合理的语义性保证。在非确定性的函数下，某个 <code>reduce</code> 任务 <code>R1</code> 由分布式执行的结果等价于一个串行执行的程序 <code>A</code> 执行 <code>R1</code> 后的结果。但是，另一个 <code>reduce</code> 任务 <code>R2</code> 的执行结果也可能等同于由另一个不同的串行执行的程序 <code>B</code> 执行后的结果。</p>
<p>假设有一个 <code>map</code> 任务 <code>M</code>，以及总共有两个 <code>reduce</code> 任务 <code>R1</code> 和 <code>R2</code>，记 <code>e(Ri)</code> 表示 <code>Ri</code> 执行并提交成功的结果。以前面的单词统计为例，假设发送给 <code>map</code> 任务的只有两个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.txt:</span><br><span class="line">It was the best of times</span><br><span class="line"></span><br><span class="line">2.txt:</span><br><span class="line">it was the worst of times</span><br></pre></td></tr></table></figure>
<p>在 <code>map</code> 函数是非确定性的情况下，不妨这样实现 <code>map</code> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    // key: document name</span><br><span class="line">    // value: document contents</span><br><span class="line">    for each word w in value:</span><br><span class="line">        r = Random(0, 1)</span><br><span class="line"></span><br><span class="line">        if r &gt; 0.5:</span><br><span class="line">            EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line">        else:</span><br><span class="line">            EmitIntermediate(w, &quot;0&quot;);</span><br></pre></td></tr></table></figure>
<p>即对于某个单词，<code>map</code> 函数有一半的概率计数为1，一半的概率计数为0。</p>
<p>类似的，以同样的手段来实现 <code>reduce</code> 函数，对于某个单词的所有出现次数，<code>reduce</code> 函数有一半的概率会计数，一半的概率会忽略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    // key: a word</span><br><span class="line">    // values: a list of counts</span><br><span class="line">    int result = 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        r = Random(0, 1)</span><br><span class="line"></span><br><span class="line">        if r &gt; 0.5:</span><br><span class="line">            result += ParseInt(v);</span><br><span class="line">        else:</span><br><span class="line">            result += 0;</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>令 <code>R1</code> 为统计单词 <code>it</code> 的个数，经过 <code>map</code> 任务后，生成的中间结果键值对可能为以下四种情况：</p>
<ol>
<li>[0, 1]</li>
<li>[1, 0]</li>
<li>[1, 1]</li>
<li>[0, 0]</li>
</ol>
<p>最后由 <code>reduce</code> 任务执行后的结果可能为0、1、2三种情况，而相同的输入由一个串行执行的程序来执行也是同样的结果，即不管是分布式的程序还是串行的程序最终结果都是相同的集合，所以认为两者是等价的，也是合理的。</p>
<p>在确定性的函数下，相同的输入必然返回相同的输出，而在不确定性的函数下，不同的输入可能返回相同的输出或者相同的输入可能返回不同的输出。这就类似于知道 <code>x</code> 的定义域是 <code>&#123;1, 2, 3&#125;</code>，<code>y</code> 值域是 <code>&#123;4, 5, 6&#125;</code>，求 <code>f(x)</code>，显然 <code>f(x)</code> 存在不止唯一的解。</p>
<p>记上述的 <code>map</code> 和 <code>reduce</code> 函数组成的串行程序为 <code>A</code>，假设有另一个串行程序 <code>B</code>，其中 <code>map</code> 函数不变，<code>reduce</code> 函数变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    // key: a word</span><br><span class="line">    // values: a list of counts</span><br><span class="line">    int result = 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        r = Random(0, 1)</span><br><span class="line"></span><br><span class="line">        if r &gt; 0.5:</span><br><span class="line">            result += 0;</span><br><span class="line">        else:</span><br><span class="line">            result += ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>令 <code>R2</code> 为统计单词 <code>was</code> 的个数，由 <code>A</code> 或 <code>B</code> 执行的最终结果都等于集合 <code>&#123;0, 1, 2&#125;</code>，相比于确定性的函数，开发人员因此无法有效的审视所编写函数的行为。</p>
<h3 id="局部性"><a class="markdownIt-Anchor" href="#局部性"></a> 局部性</h3>
<p>在 <code>Google</code> 内部的运行环境中网络带宽属于稀缺资源，不管是 <code>map</code> 还是 <code>reduce</code> 任务都依托于文件的读取，不可避免的会产生大量网络 <code>IO</code>。而在前面提到，<code>Google</code> 内部实现了一套分布式文件存储系统（<code>GFS</code>）来管理存储在集群内机器本地磁盘上的文件，对于每一个文件 <code>GFS</code> 会将其切分为若干个 <code>64MB</code> 的数据块，每个数据块存有多份冗余（一般是3份）保存在不同的机器上。对于 <code>MapReduce</code> 框架来说，原始的数据输入是保存在本地磁盘上的，依据这个特性，框架在分发 <code>map</code> 任务时，根据输入数据在 <code>GFS</code> 内的位置会优先选择本地磁盘上存有对应输入数据的工作节点。如果找不到这样的工作节点，则会选择一个距离输入数据最近的工作节点（例如工作节点和存有输入数据的节点由同一个交换机相连）。当运行大量的 <code>MapReduce</code> 任务时，大部分的输入数据都是从本地读取从而不消耗任何网络带宽。</p>
<h3 id="任务粒度"><a class="markdownIt-Anchor" href="#任务粒度"></a> 任务粒度</h3>
<p>如前文所述 <code>MapReduce</code> 框架会根据输入数据拆分为 <code>M</code> 个 <code>map</code> 任务和 <code>R</code> 个 <code>reduce</code> 任务。理想情况下，<code>M</code> 和 <code>R</code> 的值应该远大于工作节点的数量。为什么需要远大于？首先，<code>M</code> 和 <code>R</code> 的数量比工作节点的数量少是不适合的，会造成资源空闲；其次，如果 <code>M</code> 和 <code>R</code> 的数量和工作节点相等，由于每台机器的处理能力有差异或者输入数据不同，每个工作节点完成某个任务需要的时间也不同，会存在部分机器先完成任务的情况，同样会造成资源空闲，另一方面 <code>MapReduce</code> 面向的是大数据处理，输入数据的数据量远大于工作节点的数量，<code>M</code> 和 <code>R</code> 数量较少的情况下单个工作节点需要处理的数据量则较大，单次处理时间可能较慢，而如果发生了异常，重新执行的成本也较高。所以 <code>M</code> 和 <code>R</code> 的数量设置较大能更好的应对负载均衡，性能好的机器在完成任务后可以继续处理其他任务，同时当某个任务执行异常时也能更快的恢复：该异常的工作节点已完成的 <code>map</code> 任务可分发给余下的工作节点执行。</p>
<p>当然 <code>M</code> 和 <code>R</code> 的数量也是存在上限的，对于 <code>master</code> 节点来说，它需要维护 <code>M</code> 个 <code>map</code> 任务和 <code>R</code> 个 <code>reduce</code> 任务，时间复杂度是 <code>O(M + R)</code>，另一方面每个 <code>map</code> 任务会产出 <code>R</code> 份中间结果数据，对应 <code>R</code> 个 <code>reduce</code> 任务，所以 <code>master</code> 节点也需要 <code>O(M * R)</code> 的空间复杂度来维护这样的对应关系（<code>Google</code> 实际实现时，每个 <code>map/reduce</code> 关系对约占据 <code>1 byte</code> 内存）。</p>
<p>另外，由于每个 <code>reduce</code> 任务的最终产出结果是一个单独的文件所以 <code>R</code> 的数量受用户设置限制。在实践中，会趋向于让每个 <code>map</code> 任务处理 <code>16 MB</code> 到 <code>64 MB</code> 的输入数据来确定 <code>M</code> 的大小，因为 <code>64 MB</code> 正好是 <code>GFS</code> 单个数据块的大小，这样每个 <code>map</code> 任务必然能从本地磁盘读取输入数据而不会涉及网络 <code>IO</code>（如果能将任务分发给存有对应输入数据的节点的话），而 <code>R</code> 的数量会在工作节点的数量上乘上一个较小的常数得到。<code>Google</code> 内部运行 <code>MapReduce</code> 任务时通常设置 <code>M</code> 为200000，使用2000台机器的情况下设置 <code>R</code> 为5000。</p>
<h3 id="后备任务"><a class="markdownIt-Anchor" href="#后备任务"></a> 后备任务</h3>
<p>类似于木桶原理，一次 <code>MapReduce</code> 任务完成的时间取决于最慢的机器完成 <code>map</code> 或 <code>reduce</code> 任务的时间，这也是造成 <code>MapReduce</code> 任务耗时长的常见原因之一。某台机器执行慢可能有好几个原因造成，例如某台机器的磁盘存在异常，可能频繁遭遇可校正的异常，从而使得磁盘的读速度从 <code>30 MB/s</code> 降低到 <code>1 MB/s</code>。而调度系统同时有可能分配了其他的任务给这台机器，会进一步引发 <code>CPU</code>、内存、本地磁盘、网络带宽的竞争，从而造成执行 <code>MapReduce</code> 任务的耗时更长。<code>Google</code> 内部曾经遇到一个问题，由于机器初始化代码中的一个 <code>bug</code> 造成处理器的缓存被禁用，在这些受影响的机器上运行的任务耗时增长了超过100倍。</p>
<p>针对这个问题，<code>Google</code> 提出了一个通用的缓解机制。当一次 <code>MapReduce</code> 任务快执行结束时，框架会将剩余还在进行中的任务分配给其他机器执行。不管是原先分配的机器执行完成，还是新分配的机器执行完成，对应的任务都将标记为完成。让一个任务由两台机器同时执行势必存在资源浪费，<code>Google</code> 通过调优使得耗费的计算资源控制在了增加几个百分比以内。这个机制在处理一个数据量巨大的 <code>MapReduce</code> 任务时能大幅降低整体耗时。在某个约需处理 <code>1T</code> 数据的排序任务中，不启用这个机制的情况下整体耗时会增加44%。</p>
<h2 id="改进"><a class="markdownIt-Anchor" href="#改进"></a> 改进</h2>
<p>大多数情况下用户仅需编写 <code>map</code> 和 <code>reduce</code> 函数就能满足需求，本节主要描述一些 <code>MapReduce</code> 的扩展，可能在某些场合下会比较有用。</p>
<h3 id="分片函数"><a class="markdownIt-Anchor" href="#分片函数"></a> 分片函数</h3>
<p>用户可指定 <code>MapReduce</code> 任务最终输出文件的数量 <code>R</code>，也即 <code>reduce</code> 任务的数量。那么由 <code>map</code> 任务产生的中间结果数据应该发给哪个 <code>reduce</code> 节点执行呢？这个就交由分片函数决定，默认的分片函数是哈希函数（例如 <code>hash(key) mod R</code>），这种分片结果一般比较均匀。不过，有时候自定义分片函数会更有用，例如，当最终结果文件的键是 <code>URL</code> 时，我们希望同属于一个 <code>host</code> 下的 <code>URL</code> 对应的数据最终都在同一个文件里，用户可自定义分片函数来实现，例如 <code>hash(Hostname(urlkey)) mod R</code>，即先通过 <code>urlkey</code> 提取 <code>host</code>，然后对 <code>host</code> 计算哈希最后取模 <code>R</code>。</p>
<h3 id="顺序保证"><a class="markdownIt-Anchor" href="#顺序保证"></a> 顺序保证</h3>
<p><code>MapReduce</code> 框架保证在同一个中间结果分区内，即同一个 <code>reduce</code> 任务内，中间结果数据是按照键的升序处理的，因为 <code>reduce</code> 任务处理前会先将中间结果数据按照键进行排序。这样在 <code>reduce</code> 任务处理完成后，最终结果文件内的数据也是按照键的顺序排序的，这就有利于对最终结果文件按键进行高效的随机查找，或方便其他需要排好序的数据的场景。</p>
<h3 id="合并函数"><a class="markdownIt-Anchor" href="#合并函数"></a> 合并函数</h3>
<p>在某些场景下，<code>map</code> 任务产生的中间结果数据的键存在大量的重复，同时用户编写的 <code>reduce</code> 函数又符合交换律和结合律（即 <code>a + b = b + a</code>，<code>(a + b) + c = a + (b + c)</code>）。一个典型案例就是前文描述的单词计数程序，每个 <code>map</code> 任务都会产生成百上千的形如 <code>&lt;the, 1&gt;</code> 的中间结果数据，其中 <code>the</code> 指某个单词，1表示该单词出现的次数。这些同键的中间结果数据接着会经过网络传输发送给 <code>reduce</code> 任务，然后由 <code>reduce</code> 函数合并相加。为了减少这种雷同数据的网络传输，用户可编写自定义的合并函数，<code>map</code> 任务在生成中间结果数据前先进行同键的合并，从而将原来成百上千的同键网络传输降低为1次。</p>
<p>一般来说，合并函数和 <code>reduce</code> 函数的用户代码实现是相同的。不同在于 <code>MapReduce</code> 框架如何处理这两个函数产出的结果，<code>reduce</code> 函数的产出结果会写到最终的结果文件里，而合并函数的产出结果会写到中间结果文件里，然后发送给 <code>reduce</code> 任务。</p>
<p>在特定情况下，由于省去了大量的网络 <code>IO</code>，合并函数能显著的降低一次 <code>MapReduce</code> 任务执行的耗时。</p>
<h3 id="输入和输出类型"><a class="markdownIt-Anchor" href="#输入和输出类型"></a> 输入和输出类型</h3>
<p><code>MapReduce</code> 框架支持从多个数据格式读取输入数据。例如，<code>text</code> 模式下将输入数据的每一行作为键值对，其中键通过在文本中的偏移量来确定，而值就是当前行的内容。另一种通用支持的格式是本身保存了已排好序的键值对。不管是哪种输入格式，<code>MapReduce</code> 都能从原始输入中准确切分出键值对供 <code>map</code> 任务使用（例如 <code>text</code> 模式保证以每一行的结束进行切分）。用户也可实现自定义的 <code>reader</code> 接口来支持读取新的输入格式，不过大部分情况下内置的输入格式已经能满足需求。</p>
<p>虽然前文描述过 <code>MapReduce</code> 的原始输入数据来源于文本文件，不过用户自定义的 <code>reader</code> 接口并不一定要从文本文件读取，例如还可以从数据库或内存中读取。</p>
<p>类似的，<code>MapReduce</code> 框架也支持不同的最终输出数据的格式，用户也同样可实现支持自定义的输出格式。</p>
<h3 id="副作用"><a class="markdownIt-Anchor" href="#副作用"></a> 副作用</h3>
<p>在某些情况下，用户可能希望在 <code>map</code> 或 <code>reduce</code> 阶段生成额外的辅助文件，这就要求开发人员自己保证输出文件的原子性和幂等性，特别是用户程序先将数据写入到临时文件内，最后在所有数据写入完成后能原子性的将临时文件重命名。</p>
<p>不过，<code>MapReduce</code> 框架本身并不支持两阶段协议来保证 <code>map</code> 或 <code>reduce</code> 任务输出多个文件时的一致性，同样的，这也需要开发人员自己来保证。因此多文件一致性对应的任务应当是确定性的，否则如何确定产出的文件是符合一致性的？而在实践中要求任务是确定性的并不是个问题。</p>
<h3 id="忽略异常数据"><a class="markdownIt-Anchor" href="#忽略异常数据"></a> 忽略异常数据</h3>
<p>有时候由于用户编写的 <code>map</code> 或 <code>reduce</code> 函数存在 <code>bug</code>，导致处理某些数据时 <code>map</code> 或 <code>reduce</code> 函数必然发生异常，这就造成 <code>MapReduce</code> 任务无法正常完成。正常来说应当修复 <code>bug</code>，但有时候不可行，例如造成 <code>bug</code> 的代码可能是第三方库引入的。另一方面，有时候忽略这些造成异常的数据也是可以接受的，例如在对一个数据量非常庞大的数据集做统计分析时。因此，<code>MapReduce</code> 框架提供了一种可选的执行模式，当其检测到某些输入数据必然造成异常时，则会跳过这些数据从而使得执行流程能继续走下去。</p>
<p>为了实现这个功能，首先每个工作节点上都安装了一个 <code>signal handler</code> 程序用于捕获段异常和总线异常。在执行 <code>map</code> 或 <code>reduce</code> 任务之前，<code>MapReduce</code> 框架首先将当前任务需要的输入数据所对应的序号保存在工作节点内的一个全局变量中，在执行 <code>map</code> 或 <code>reduce</code> 任务时，如果用户代码发生异常，此时 <code>signal handler</code> 能捕获到相应的异常信号，然后 <code>signal handler</code> 会发送一个 <code>UDP</code> 数据包给主节点，该数据包中包含了执行当次任务的输入数据序号。如果主节点发现某个数据对应的任务执行失败了多次，则会忽略该数据而不是重新执行 <code>map</code> 或 <code>reduce</code> 任务。按照这样的描述，被忽略的数据是数据片维度，而不是键值对维度，因为每片的数据块大小相比于总数据量的大小来说微乎其微，所以整体影响不大。</p>
<h3 id="本地执行"><a class="markdownIt-Anchor" href="#本地执行"></a> 本地执行</h3>
<p>调试分布式程序并不是件简单的事，对于 <code>MapReduce</code> 任务来说，一次任务会被分发到几千台机器上执行，每台机器实际执行的任务也无法预测。为了方便调试、性能分析和小规模测试，<code>Google</code> 实现的 <code>MapReduce</code> 框架也提供了一个串行执行的版本，能在单台机器上串行执行所有任务。同时，用户也可通过参数控制一次 <code>MapReduce</code> 任务只执行些特定的 <code>map</code> 任务。通过在启动程序时指定调试参数，用户就可轻松的使用调试或测试工具（如 <code>gdb</code>）对编写的程序进行调试和测试。</p>
<h3 id="状态信息"><a class="markdownIt-Anchor" href="#状态信息"></a> 状态信息</h3>
<p>主节点内部同时运行了一个 <code>HTTP</code> 服务，用于提供给用户查看一系列状态信息。状态信息页面展示了当前任务的进度，例如有多少个任务已经完成，有多少个任务正在进行中，输入数据的大小，中间结果数据的大小，最终结果数据的大小，任务处理百分比等。同时，状态页面也提供了每个任务执行产生的标准错误输出和标准输出文件。用户可根据这些信息来预测任务需要多久才能完成，以及是否需要添加更多的计算资源。状态页面也可用于判断当前任务执行耗时是否比预期的长。</p>
<p>此外，状态页面也显示了失败的工作节点，以及这些失败的工作节点对应的 <code>map</code> 或 <code>reduce</code> 任务。这有助于用户排查编写的代码中是否有 <code>bug</code>。</p>
<h3 id="计数器"><a class="markdownIt-Anchor" href="#计数器"></a> 计数器</h3>
<p><code>MapReduce</code> 框架内部提供了一个计数器用于统计各个事件发生的次数。例如，用户可能希望统计一次任务中一共处理了多少个单词，或者有多少个德语文档建立了索引。</p>
<p>如果要开启这个功能，用户需要编写一个命名计数器，然后在 <code>map</code> 或 <code>reduce</code> 函数中在需要的时候对计数器自增，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(&quot;uppercase);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">    for each word w in contents:</span><br><span class="line">        if (IsCapitalized(w)):</span><br><span class="line">            uppsercase-&gt;Increment();</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br></pre></td></tr></table></figure>
<p>每个工作节点上的计数器的值会周期性的发送给主节点（如前文所述，主节点会周期性的对工作节点进行心跳探测，工作节点会在响应结果中带上计数器的值）。主节点会对执行成功的 <code>map</code> 和 <code>reduce</code> 任务返回的计数器聚合，当整个 <code>MapReduce</code> 任务完成将控制权交还给用户代码时，用户代码可获取到创建的计数器的值。当前的计数器的值也同样会展示在状态页面，用户也可根据此信息来观测整个任务的进展。在对计数器聚合时，和主节点会忽略已完成的某个任务的重复通知一样，主节点同样会忽略某个来自已完成任务的计数器更新，从而避免重复计数（任务的重复执行主要有两种情况，一种是由于网络不连通，导致主节点重新分配某个 <code>map</code> 或 <code>reduce</code> 任务到新的工作节点上；另一种是触发了后备任务，主节点主动分发同一个 <code>map</code> 或 <code>reduce</code> 任务给多个工作节点执行）。</p>
<p><code>MapRecue</code> 框架本身也维护了一些计数器，例如已处理的输入数据键值对的数量，以及已生成的最终数据键值对的数量。</p>
<p>用户能很方便的通过计数器来检查 <code>MapReduce</code> 任务的行为。例如，在任务执行时用户可通过计数器来确保输出的键值对数量是否等于输入的键值对数量，或者已处理的德语文档的数量在全部已处理的文档数量中的占比是否符合预期。</p>
<h2 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h2>
<p>这一节主要描述 <code>MapReduce</code> 在 <code>Google</code> 内部环境下运行的性能情况，这里不再赘述。简单举例来说，在1800台机器上执行一个 <code>10T</code> 数据量的分布式 <code>grep</code> 搜索耗时约150秒。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>最后，来自 <code>Google</code> 的总结：</p>
<ol>
<li>限制性的编程模型使得计算并行化变得容易，以及有着较好的容错性，这也体现了计算机领域的一个重要思想：抽象</li>
<li>对于大型系统来说，网络 <code>IO</code> 容易成为瓶颈</li>
<li>冗余执行可以作为有效降低成为性能短板的机器带来的影响的手段，另外冗余也是应对机器异常、数据丢失的方式</li>
</ol>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce: Simplified Data Processing on Large Clusters</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bisection_bandwidth">Bisection bandwidth</a></li>
<li><a target="_blank" rel="noopener" href="https://networkengineering.stackexchange.com/questions/28894/understanding-bisection-bandwidth">Understanding bisection bandwidth</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/02/07/add-node-in-binary-search-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/07/add-node-in-binary-search-tree/" class="post-title-link" itemprop="url">二叉搜索树的插入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T00:00:00+08:00">2022-02-07</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>3 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>往一个二叉搜索树中插入一个节点后的结果并不唯一，例如对于下面的二叉搜索树：</p>
<p><img src="/images/bst-add-1.png" alt="alt" /></p>
<p>如果要插入节点2，可以将2作为3的左子节点：</p>
<p><img src="/images/bst-add-2.png" alt="alt" /></p>
<p>或者将2作为1的右子节点：</p>
<p><img src="/images/bst-add-3.png" alt="alt" /></p>
<p>对于第一种方法，类似于往单链表的中间插入节点，既要更新前继节点的 <code>next</code> 指针，又要将新的节点的 <code>next</code> 指针指向下一个节点；而对于第二种方法，只需要将新节点挂载到目标节点的左子节点或右子节点即可，实现上较为简洁，可分为非递归和递归两种解法。</p>
<h2 id="非递归"><a class="markdownIt-Anchor" href="#非递归"></a> 非递归</h2>
<p>整体算法分为两步：</p>
<ol>
<li>找到要挂载的叶子节点</li>
<li>将新节点挂载到该叶子节点的左子节点或右子节点上</li>
</ol>
<p>第一步等同于二叉搜索树的查找，从根节点开始，将目标值和当前节点的值进行比较，如果当前节点的值比目标值小，说明要找的节点在右子树中，移动到右子节点中查找；如果当前节点的值比目标值大，说明要找的节点在左子树中，移动到左子节点中查找。</p>
<p>找到目标叶子节点后，比较该叶子节点的值和目标值的大小，来决定新节点是作为左子节点还是右子节点插入：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">        prev, current = <span class="literal">None</span>, root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            prev = current</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current.val &lt; val:</span><br><span class="line">                current = current.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prev.val &gt; val:</span><br><span class="line">            prev.left = TreeNode(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev.right = TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>一般的二叉树问题的递归解法遵循如下的模式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="comment"># 处理终止条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 一种情况是左右子树只处理一边</span></span><br><span class="line">    <span class="keyword">if</span> some condition:</span><br><span class="line">        dfs(root.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 另一种情况是左右子树都处理</span></span><br><span class="line">    dfs(root.left)</span><br><span class="line">    dfs(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure>
<p>在当前的问题下，终止条件发生的条件为找到了目标叶子节点，此时需要新建一个节点；而对于递归的处理，这里适用于第一种情况，即左右子树只处理一边，判断条件为比较当前节点的值和目标值的大小，所以可以粗略的构造出程序的框架：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        create new node <span class="keyword">with</span> val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">        dfs(root.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure>
<p>下一个问题是，这个递归函数的返回值是什么？从终止条件的处理可以看到递归函数返回的是某个节点，联想到往一个二叉搜索树中插入一个节点后需要返回一个新的树，所以这里递归函数的返回值应该是根节点。</p>
<p>然而还缺少一步，就是新节点的挂载，目前新节点返回后并没有任何节点引用它，需要在终止条件的上层调用中处理，即每次递归调用时都重新赋值左子树或右子树的根节点：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2022/02/02/binary-tree-traverse-with-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/02/binary-tree-traverse-with-stack/" class="post-title-link" itemprop="url">二叉树非递归遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-02T00:00:00+08:00">2022-02-02</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>8 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>二叉树的遍历直观的解法是使用递归求解，不过同样也可使用非递归方式求解。</p>
<h2 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h2>
<p>先来看前序遍历的递归求解：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        values = []</span><br><span class="line"></span><br><span class="line">        self._preorder_traversal(root, values)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_preorder_traversal</span>(<span class="params">self, root: TreeNode, values: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        values.append(root.val)</span><br><span class="line"></span><br><span class="line">        self._preorder_traversal(root.left, values)</span><br><span class="line">        self._preorder_traversal(root.right, values)</span><br></pre></td></tr></table></figure>
<p>对于如下的二叉树：</p>
<p><img src="/images/binary-tree.jpg" alt="alt" /></p>
<p>其调用链为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_preorder_traversal(1)</span><br><span class="line">    _preorder_traversal(2)</span><br><span class="line">        _preorder_traversal(4)</span><br><span class="line">        _preorder_traversal(5)</span><br><span class="line">    _preorder_traversal(3)</span><br></pre></td></tr></table></figure>
<p>可以看到越深的节点对应的函数调用越先返回，对应先进后出的模型，即栈，所以递归转非递归可借助栈实现。</p>
<p>由于前序遍历是先访问根节点，所以对于每个子树，可以先将根节点入栈，然后依次弹出栈顶的节点，从而实现先访问根节点，然后将左右子树的根节点入栈，由于左子树需要先于右子树被访问，所以右子树的根节点要先入栈，然后再入栈左子树的根节点：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        values = []</span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current = stack.pop()</span><br><span class="line">            values.append(current.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current.right:</span><br><span class="line">                stack.append(current.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current.left:</span><br><span class="line">                stack.append(current.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h2>
<p>在递归的方案下，前序遍历改为中序遍历只需改变 <code>values.append(root.val)</code> 的执行位置即可，而在非递归方案下，并不能通过直接改变 <code>values.append(current.val)</code> 的执行位置来实现，因为不管放到哪个位置，都会提前访问到根节点。</p>
<p>中序遍历下，最左下方的节点是最先被访问的，沿着左子树的根节点这条线，等同于一个单链表的倒序访问，单链表的倒序如果用栈来实现则是将单链表的所有节点从链表头开始遍历依次放入栈，然后再依次出栈，类似的，只要当前节点存在左子树，则持续将左子树的根节点压入栈，这样下次出栈时，就会先访问最左下方的节点。当某个节点出栈时，由于上述的操作，它必然是某个子树的最左下方的节点，此时需要转到该节点的右子树重复上述流程从而访问右子树的全部节点：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        values = []</span><br><span class="line">        stack = []</span><br><span class="line">        current = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            current = stack.pop()</span><br><span class="line">            values.append(current.val)</span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure>
<p>虽然前序遍历的非递归方案不适用于中序遍历，不过中序遍历的递归方案可略微修改适用于前序遍历，只需将 <code>values.append(current.val)</code> 放在不断入栈左子树的循环中即可：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        values = []</span><br><span class="line">        stack = []</span><br><span class="line">        current = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                values.append(current.val)</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            current = stack.pop()</span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h2>
<p>后序遍历和中序遍历相同，最先访问的都是最左下方的节点，所以对左子树不断入栈这段逻辑不变，不同的是当出栈时，当前出栈的节点有可能存在右子树，而右子树还还没有被访问，所以当前节点还不能出栈。因此，需要先判断栈顶的节点是否存在右子树，以及右子树是否被访问过，如果存在右子树且未被访问则转向右子树重复上述流程，否则可弹出栈顶节点。而判断栈顶的右子树是否被访问可通过比较栈顶的右子树和上一个被访问的节点来实现，如果两者相等，说明栈顶的右子树刚被访问过，否则未被访问过：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        current = root</span><br><span class="line">        stack = []</span><br><span class="line">        values = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line"></span><br><span class="line">            top = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> top.right <span class="keyword">and</span> prev != top.right:</span><br><span class="line">                current = top.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = stack.pop()</span><br><span class="line">                values.append(current.val)</span><br><span class="line">                prev = current</span><br><span class="line">                current = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure>
<h2 id="通用模板"><a class="markdownIt-Anchor" href="#通用模板"></a> 通用模板</h2>
<p>上述各非递归方案各不相同，是否存在和递归方案类似的通用模板方案？<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/1736072/Java-This-simple-template-can-be-used-for-3-traversals">这里</a> 给出了一种通用方案，首先需要额外引入一个数据结构来标记节点是否被访问过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> visited;</span><br><span class="line">    TreeNode node;</span><br><span class="line"></span><br><span class="line">    Pair(TreeNode node, <span class="type">boolean</span> visited) &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.visited = visited;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Python</code> 中，可简单通过元组来实现，对应模板代码为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xxxTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack = [(root, <span class="literal">False</span>)]</span><br><span class="line">        values = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            current, visited = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                values.append(current.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 在这里处理左子树，右子树，根节点的入栈顺序</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure>
<p>对于三种遍历方式，上述模板方法仅在处理左子树，右子树，根节点的入栈顺序上不同，实际入栈顺序和遍历顺序相反：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="keyword">if</span> current.right:</span><br><span class="line">    stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.left:</span><br><span class="line">    stack.append((current.left, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">stack.append((current, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="keyword">if</span> current.right:</span><br><span class="line">    stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">stack.append((current, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.left:</span><br><span class="line">    stack.append((current.left, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line">stack.append((current, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.right:</span><br><span class="line">    stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current.left:</span><br><span class="line">    stack.append((current.left, <span class="literal">False</span>))</span><br></pre></td></tr></table></figure>
<p>从出栈的角度来说，上述方法和理论遍历顺序并不一致，每个节点会入栈两次，第二次入栈时才会设置 <code>visited</code> 为 <code>True</code>，但从 <code>visited</code> 的角度来说顺序是和理论遍历顺序一致的。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/1736072/Java-This-simple-template-can-be-used-for-3-traversals">[Java] This simple template can be used for 3 traversals</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45551/Preorder-Inorder-and-Postorder-Iteratively-Summarization">Preorder, Inorder, and Postorder Iteratively Summarization</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://frederick-s.github.io/2021/12/26/build-and-push-docker-image-to-docker-hub-with-github-actions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiaodan Mao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Übung macht den Meister">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/26/build-and-push-docker-image-to-docker-hub-with-github-actions/" class="post-title-link" itemprop="url">使用 GitHub Actions 自动构建和推送 Docker 镜像到 Docker Hub</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-26T00:00:00+08:00">2021-12-26</time>
    </span>

  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>974</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Docker Hub</code> 的免费账户已不再支持关联 <code>GitHub</code> 仓库并自动构建镜像的功能，不过可以通过 <code>GitHub Actions</code> 来自动构建和推送镜像。实现方式非常简单，<code>Docker</code> 官方已给出了示例（<a target="_blank" rel="noopener" href="https://github.com/marketplace/actions/build-and-push-docker-images">Build and push Docker images</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">name: ci</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  docker:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      -</span><br><span class="line">        name: Set up QEMU</span><br><span class="line">        uses: docker/setup-qemu-action@v1</span><br><span class="line">      -</span><br><span class="line">        name: Set up Docker Buildx</span><br><span class="line">        uses: docker/setup-buildx-action@v1</span><br><span class="line">      -</span><br><span class="line">        name: Login to DockerHub</span><br><span class="line">        uses: docker/login-action@v1 </span><br><span class="line">        with:</span><br><span class="line">          username: $&#123;&#123; secrets.DOCKERHUB_USERNAME &#125;&#125;</span><br><span class="line">          password: $&#123;&#123; secrets.DOCKERHUB_TOKEN &#125;&#125;</span><br><span class="line">      -</span><br><span class="line">        name: Build and push</span><br><span class="line">        id: docker_build</span><br><span class="line">        uses: docker/build-push-action@v2</span><br><span class="line">        with:</span><br><span class="line">          push: true</span><br><span class="line">          tags: user/app:latest</span><br></pre></td></tr></table></figure>
<p>一共有三处要注意，第一开头的 <code>branches</code> 下对于新建的仓库需要填写 <code>main</code> 而不是 <code>master</code>。</p>
<p>第二需要为 <code>Login to DockerHub</code> 阶段设置 <code>Docker</code> 的 <code>Access Token</code>，<code>Access Token</code> 可以通过 <code>Docker Hub</code> 的 <code>Account Settings -&gt; Security -&gt; New Access Token</code> 创建，然后通过 <code>GitHub</code> 仓库的 <code>Settings -&gt; Secrets -&gt; New repository secret</code> 分别创建 <code>DOCKERHUB_USERNAME</code> 和 <code>DOCKERHUB_TOKEN</code>。</p>
<p>第三最后的 <code>tags: user/app:latest</code> 中的 <code>user</code> 和 <code>app</code> 需要修改为实际的用户名和镜像名。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61989951/github-action-workflow-not-running">GitHub Action workflow not running</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Xiaodan Mao</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Frederick-S" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
